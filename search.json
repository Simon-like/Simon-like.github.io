[{"title":"【秋招备战】JavaScript 集合类型深度解析","url":"/2025/08/05/【秋招备战】JavaScript 集合类型深度解析/","content":"\n在 JavaScript 的世界里，除了我们熟悉的对象（Object）和数组（Array），ES6 还引入了四种新的集合类型：Map、Set、WeakMap 和 WeakSet。这些数据结构不仅丰富了我们的工具箱，更是在现代前端框架的底层实现中扮演着重要角色。今天，让我们深入探讨这些集合类型的特性、使用场景，以及它们在 React 和 Vue 源码中的精妙应用。\n\n## 一、Map：更强大的键值对集合\n\n### 基本概念\n\nMap 是一个键值对的集合，与普通对象最大的区别在于：**Map 的键可以是任意类型**，而不仅仅是字符串或 Symbol。\n\n```javascript\nconst map = new Map();\n\n// 基本用法\nmap.set('name', 'JavaScript');\nmap.set(42, 'The Answer');\nmap.set(true, 'Boolean key');\n\n// 对象作为键\nconst objKey = { id: 1 };\nmap.set(objKey, 'Object as key');\n\n// 函数作为键\nconst funcKey = () => {};\nmap.set(funcKey, 'Function as key');\n\nconsole.log(map.get(objKey)); // 'Object as key'\nconsole.log(map.size); // 5\n```\n\n### Map 的核心特性\n\n1. **键的唯一性**：Map 中的键是唯一的，重复设置会覆盖之前的值\n2. **保持插入顺序**：Map 会记住键值对的插入顺序\n3. **可迭代**：Map 实现了迭代器协议\n\n```javascript\nconst map = new Map([\n  ['first', 1],\n  ['second', 2],\n  ['third', 3]\n]);\n\n// 遍历方法\nfor (const [key, value] of map) {\n  console.log(`${key}: ${value}`);\n}\n\n// 获取所有键\nconsole.log([...map.keys()]); // ['first', 'second', 'third']\n\n// 获取所有值\nconsole.log([...map.values()]); // [1, 2, 3]\n\n// 获取所有键值对\nconsole.log([...map.entries()]); // [['first', 1], ['second', 2], ['third', 3]]\n```\n\n### Map vs Object 的性能对比\n\n```javascript\n// 性能测试：频繁增删操作\nconst testSize = 100000;\n\n// Object 测试\nconsole.time('Object');\nconst obj = {};\nfor (let i = 0; i < testSize; i++) {\n  obj[`key${i}`] = i;\n  delete obj[`key${i}`];\n}\nconsole.timeEnd('Object');\n\n// Map 测试\nconsole.time('Map');\nconst map = new Map();\nfor (let i = 0; i < testSize; i++) {\n  map.set(`key${i}`, i);\n  map.delete(`key${i}`);\n}\nconsole.timeEnd('Map');\n\n\n// Object: 40.439ms\n// Map: 15.457ms\n// Map 在频繁增删操作时性能更优\n```\n\n### 实际应用场景\n\n```javascript\n// 缓存管理\nclass LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();\n  }\n\n  get(key) {\n    if (!this.cache.has(key)) return -1;\n    \n    // 将访问的元素移到最后（最新）\n    const value = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, value);\n    return value;\n  }\n\n  put(key, value) {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    }\n    \n    this.cache.set(key, value);\n    \n    // 超出容量，删除最旧的（第一个）\n    if (this.cache.size > this.capacity) {\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n  }\n}\n```\n\n## 二、Set：独特值的集合\n\n### 基本概念\n\nSet 是一个值的集合，其中每个值都是唯一的，不会重复。\n\n```javascript\nconst set = new Set();\n\n// 添加值\nset.add(1);\nset.add(2);\nset.add(2); // 重复值不会被添加\nset.add('2'); // 字符串'2'和数字2是不同的\n\nconsole.log(set.size); // 3\nconsole.log(set.has(2)); // true\n\n// 数组去重\nconst numbers = [1, 2, 2, 3, 4, 4, 5];\nconst uniqueNumbers = [...new Set(numbers)];\nconsole.log(uniqueNumbers); // [1, 2, 3, 4, 5]\n```\n\n### Set 的高级应用\n\n```javascript\n// 1. 数组操作\nconst setA = new Set([1, 2, 3, 4]);\nconst setB = new Set([3, 4, 5, 6]);\n\n// 并集\nconst union = new Set([...setA, ...setB]);\nconsole.log([...union]); // [1, 2, 3, 4, 5, 6]\n\n// 交集\nconst intersection = new Set([...setA].filter(x => setB.has(x)));\nconsole.log([...intersection]); // [3, 4]\n\n// 差集\nconst difference = new Set([...setA].filter(x => !setB.has(x)));\nconsole.log([...difference]); // [1, 2]\n\n// 2. 对象去重\nconst users = [\n  { id: 1, name: 'Alice' },\n  { id: 2, name: 'Bob' },\n  { id: 1, name: 'Alice' },\n  { id: 3, name: 'Charlie' }\n];\n\nconst uniqueUsers = Array.from(\n  new Map(users.map(user => [user.id, user])).values()\n);\nconsole.log(uniqueUsers); // 去重后的用户数组\n```\n\n### 性能优势\n\n```javascript\n// Set 的 has 方法性能测试\nconst arr = Array.from({ length: 10000 }, (_, i) => i);\nconst set = new Set(arr);\n\nconsole.time('Array includes');\nfor (let i = 0; i < 1000; i++) {\n  arr.includes(9999);\n}\nconsole.timeEnd('Array includes');\n\nconsole.time('Set has');\nfor (let i = 0; i < 1000; i++) {\n  set.has(9999);\n}\nconsole.timeEnd('Set has');\n\n// Set.has() 的时间复杂度是 O(1)，而 Array.includes() 是 O(n)\n```\n\n## 三、WeakMap：弱引用的键值对集合\n\n### 核心特性\n\nWeakMap 与 Map 类似，但有几个关键区别：\n\n1. **键必须是对象**（不能是原始值）\n2. **键是弱引用的**，不会阻止垃圾回收\n3. **不可迭代**，没有 size 属性\n\n```javascript\nconst wm = new WeakMap();\n\n// 只能使用对象作为键\nconst obj1 = { name: 'object1' };\nconst obj2 = { name: 'object2' };\n\nwm.set(obj1, 'value1');\nwm.set(obj2, 'value2');\n\nconsole.log(wm.get(obj1)); // 'value1'\n\n// 不能使用原始值作为键\n// wm.set('string', 'value'); // TypeError\n\n// 弱引用特性\nlet obj3 = { name: 'object3' };\nwm.set(obj3, 'value3');\nobj3 = null; // obj3 可以被垃圾回收，对应的 WeakMap 条目也会被清除\n```\n\n### WeakMap 的实际应用\n\n```javascript\n// 1. 私有属性实现\nconst privateData = new WeakMap();\n\nclass Person {\n  constructor(name, age) {\n    privateData.set(this, { name, age });\n  }\n\n  getName() {\n    return privateData.get(this).name;\n  }\n\n  getAge() {\n    return privateData.get(this).age;\n  }\n}\n\nconst person = new Person('Alice', 30);\nconsole.log(person.getName()); // 'Alice'\nconsole.log(person.name); // undefined\n\n// 2. DOM 元素关联数据\nconst elementData = new WeakMap();\n\nfunction attachData(element, data) {\n  elementData.set(element, data);\n}\n\nfunction getData(element) {\n  return elementData.get(element);\n}\n\n// 使用\nconst button = document.querySelector('#myButton');\nattachData(button, { clickCount: 0 });\n\nbutton.addEventListener('click', () => {\n  const data = getData(button);\n  data.clickCount++;\n  console.log(`Clicked ${data.clickCount} times`);\n});\n```\n\n### 内存管理优势\n\n```javascript\n// 使用 Map 可能造成内存泄漏\nconst cache = new Map();\n\nfunction processData(obj) {\n  if (cache.has(obj)) {\n    return cache.get(obj);\n  }\n  \n  const result = expensiveOperation(obj);\n  cache.set(obj, result); // obj 被 Map 引用，无法被垃圾回收\n  return result;\n}\n\n// 使用 WeakMap 避免内存泄漏\nconst weakCache = new WeakMap();\n\nfunction processDataSafe(obj) {\n  if (weakCache.has(obj)) {\n    return weakCache.get(obj);\n  }\n  \n  const result = expensiveOperation(obj);\n  weakCache.set(obj, result); // obj 可以被正常垃圾回收\n  return result;\n}\n```\n\n## 四、WeakSet：弱引用的值集合\n\n### 基本特性\n\nWeakSet 与 Set 类似，但具有以下特点：\n\n1. **只能存储对象**\n2. **对象是弱引用的**\n3. **不可迭代**\n\n```javascript\nconst ws = new WeakSet();\n\nconst obj1 = { id: 1 };\nconst obj2 = { id: 2 };\n\nws.add(obj1);\nws.add(obj2);\n\nconsole.log(ws.has(obj1)); // true\n\n// 不能添加原始值\n// ws.add(1); // TypeError\n\n// 防止重复添加\nws.add(obj1); // 不会报错，但也不会重复添加\n```\n\n### 实际应用场景\n\n```javascript\n// 1. 标记对象状态\nconst disabledElements = new WeakSet();\n\nfunction disableElement(element) {\n  disabledElements.add(element);\n  element.classList.add('disabled');\n}\n\nfunction enableElement(element) {\n  disabledElements.delete(element);\n  element.classList.remove('disabled');\n}\n\nfunction isDisabled(element) {\n  return disabledElements.has(element);\n}\n\n// 2. 防止递归调用\nconst processing = new WeakSet();\n\nfunction processObject(obj) {\n  if (processing.has(obj)) {\n    console.log('Already processing this object');\n    return;\n  }\n  \n  processing.add(obj);\n  \n  try {\n    // 处理对象\n    console.log('Processing:', obj);\n    \n    // 如果对象有子对象，递归处理\n    if (obj.children) {\n      obj.children.forEach(child => processObject(child));\n    }\n  } finally {\n    processing.delete(obj);\n  }\n}\n```\n\n## 五、在 React 中的应用\n\n### React Fiber 中的 WeakMap 使用\n\nReact 的 Fiber 架构中使用 WeakMap 来存储组件相关的信息：\n\n```javascript\n// React 源码简化示例\nconst fiberNodeMap = new WeakMap();\n\nfunction createFiberNode(element) {\n  const fiber = {\n    type: element.type,\n    props: element.props,\n    // ... 其他 fiber 属性\n  };\n  \n  // 将 DOM 元素与 Fiber 节点关联\n  if (element.dom) {\n    fiberNodeMap.set(element.dom, fiber);\n  }\n  \n  return fiber;\n}\n\nfunction getFiberFromDOM(domElement) {\n  return fiberNodeMap.get(domElement);\n}\n```\n\n### React Hooks 中的 Map 应用\n\n```javascript\n// React Hooks 实现原理简化\nlet currentComponent = null;\nconst hooksMap = new Map();\n\nfunction useState(initialState) {\n  const component = currentComponent;\n  \n  if (!hooksMap.has(component)) {\n    hooksMap.set(component, []);\n  }\n  \n  const hooks = hooksMap.get(component);\n  const hookIndex = hooks.length;\n  \n  if (hooks[hookIndex] === undefined) {\n    hooks[hookIndex] = {\n      state: initialState,\n      setState: (newState) => {\n        hooks[hookIndex].state = newState;\n        reRender(component);\n      }\n    };\n  }\n  \n  return [hooks[hookIndex].state, hooks[hookIndex].setState];\n}\n```\n\n## 六、在 Vue 中的应用\n\n### Vue 3 响应式系统中的 WeakMap\n\nVue 3 的响应式系统大量使用了 WeakMap 来存储依赖关系：\n\n```javascript\n// Vue 3 响应式原理简化\nconst targetMap = new WeakMap();\n\nfunction track(target, key) {\n  let depsMap = targetMap.get(target);\n  if (!depsMap) {\n    targetMap.set(target, (depsMap = new Map()));\n  }\n  \n  let dep = depsMap.get(key);\n  if (!dep) {\n    depsMap.set(key, (dep = new Set()));\n  }\n  \n  dep.add(activeEffect);\n}\n\nfunction trigger(target, key) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) return;\n  \n  const dep = depsMap.get(key);\n  if (!dep) return;\n  \n  dep.forEach(effect => effect());\n}\n\n// 创建响应式对象\nfunction reactive(target) {\n  return new Proxy(target, {\n    get(target, key, receiver) {\n      track(target, key);\n      return Reflect.get(target, key, receiver);\n    },\n    set(target, key, value, receiver) {\n      const result = Reflect.set(target, key, value, receiver);\n      trigger(target, key);\n      return result;\n    }\n  });\n}\n```\n\n### Vue 组件实例管理\n\n```javascript\n// Vue 组件实例缓存\nconst instanceMap = new WeakMap();\n\nclass VueComponent {\n  constructor(options) {\n    this.options = options;\n    \n    // 将组件实例与其 DOM 元素关联\n    if (options.el) {\n      instanceMap.set(options.el, this);\n    }\n  }\n  \n  static getInstance(element) {\n    return instanceMap.get(element);\n  }\n}\n\n// KeepAlive 组件的缓存实现\nconst cache = new Map();\nconst keys = new Set();\n\nfunction pruneCache(keepAliveInstance, filter) {\n  cache.forEach((entry, key) => {\n    const name = getComponentName(entry.componentInstance);\n    if (name && !filter(name)) {\n      pruneCacheEntry(key);\n    }\n  });\n}\n\nfunction pruneCacheEntry(key) {\n  const cached = cache.get(key);\n  if (cached) {\n    cached.componentInstance.$destroy();\n  }\n  cache.delete(key);\n  keys.delete(key);\n}\n```\n\n## 七、性能优化最佳实践\n\n### 选择合适的数据结构\n\n```javascript\n// 场景1：需要频繁检查元素是否存在\n// ❌ 不推荐：使用数组\nconst permissions = ['read', 'write', 'delete'];\nif (permissions.includes('write')) { } // O(n)\n\n// ✅ 推荐：使用 Set\nconst permissionSet = new Set(['read', 'write', 'delete']);\nif (permissionSet.has('write')) { } // O(1)\n\n// 场景2：需要关联 DOM 元素和数据\n// ❌ 不推荐：使用 Map（可能造成内存泄漏）\nconst elementDataMap = new Map();\n\n// ✅ 推荐：使用 WeakMap\nconst elementDataWeakMap = new WeakMap();\n\n// 场景3：需要有序的键值对\n// ✅ Map 保持插入顺序\nconst orderedMap = new Map([\n  ['first', 1],\n  ['second', 2],\n  ['third', 3]\n]);\n```\n\n### 内存管理注意事项\n\n```javascript\n// 避免内存泄漏的模式\nclass EventManager {\n  constructor() {\n    // 使用 WeakMap 存储事件监听器\n    this.listeners = new WeakMap();\n  }\n  \n  addEventListener(element, event, handler) {\n    if (!this.listeners.has(element)) {\n      this.listeners.set(element, new Map());\n    }\n    \n    const elementListeners = this.listeners.get(element);\n    if (!elementListeners.has(event)) {\n      elementListeners.set(event, new Set());\n    }\n    \n    elementListeners.get(event).add(handler);\n    element.addEventListener(event, handler);\n  }\n  \n  removeEventListener(element, event, handler) {\n    const elementListeners = this.listeners.get(element);\n    if (!elementListeners) return;\n    \n    const eventHandlers = elementListeners.get(event);\n    if (!eventHandlers) return;\n    \n    eventHandlers.delete(handler);\n    element.removeEventListener(event, handler);\n    \n    // 清理空的集合\n    if (eventHandlers.size === 0) {\n      elementListeners.delete(event);\n    }\n    if (elementListeners.size === 0) {\n      this.listeners.delete(element);\n    }\n  }\n}\n```\n\n## 八、总结与建议\n\n### 何时使用 Map/Set\n\n- **Map**：当你需要键值对集合，且键可能是对象或需要保持插入顺序时\n- **Set**：当你需要存储唯一值，或进行集合运算（并集、交集、差集）时\n\n### 何时使用 WeakMap/WeakSet\n\n- **WeakMap**：当你需要将数据与对象关联，且不想阻止对象被垃圾回收时\n- **WeakSet**：当你需要标记对象，或创建对象的弱引用集合时\n\n### 性能考虑\n\n1. **查找性能**：Map/Set 的查找是 O(1)，而数组是 O(n)\n2. **内存管理**：WeakMap/WeakSet 有助于防止内存泄漏\n3. **迭代性能**：Map/Set 可以直接迭代，性能优于对象的 Object.keys()\n\n这四种集合类型极大地丰富了 JavaScript 的数据结构选择，合理使用它们不仅能让代码更简洁、更具表现力，还能在性能和内存管理方面带来显著的提升。在现代前端框架的开发中，它们更是不可或缺的基础设施。\n","tags":["秋招","ES"],"categories":["秋招准备"]},{"title":"React渲染时机完全指南：从一个电商组件的优化说起","url":"/2025/07/24/【从项目到技术】React渲染时机指南/","content":"\n## 前言\n\n作为前端开发者，我们每天都在和 React 打交道，但你真的了解 React 的渲染时机吗？\n\n- 为什么有时候获取 DOM 元素的高度是 0？\n- 为什么设置的动画效果没有生效？\n- 为什么页面会出现闪烁？\n- useEffect 和 useLayoutEffect 到底该用哪个？\n- requestAnimationFrame 在 React 中有什么用？\n\n在这篇文章中，我将通过一个真实的电商项目案例去搞懂 React 的渲染时机。\n\n## 一、从一个真实的电商场景说起\n\n### 1.1 业务背景\n\n在电商项目中，商品分类筛选是一个非常常见的功能。想象一下淘宝或京东的商品列表页，顶部通常会有这样的筛选器：\n\n```\n手机通讯 > 手机 > 华为 | 小米 | OPPO | vivo | 苹果 | 三星 | 荣耀 | realme | 一加 | 魅族...\n```\n\n当分类项特别多时，我们需要：\n\n- 默认只显示 2 行，多余的折叠起来\n- 提供展开/收起按钮\n- 支持平滑的展开/收起动画\n- 切换一级分类时，二级分类需要重置\n\n### 1.2 组件效果演示\n\n![类目筛选框](/Applications/PersonalWork/website/Blog_simonicle/source/postImage/【从项目到技术】React渲染时机指南/category.png)\n\n![类目筛选区-展开](/Applications/PersonalWork/website/Blog_simonicle/source/postImage/【从项目到技术】React渲染时机指南/category_expanded.png)\n\n(gif效果太差了。。。。)\n\n### 1.3 核心技术挑战\n\n看似简单的需求，实现起来却遇到了不少挑战：\n\n1. **高度计算问题**：如何准确获取内容的完整高度？\n2. **动画流畅性**：如何实现平滑的高度过渡动画？\n3. **状态切换问题**：切换分类时如何避免不必要的动画？\n4. **响应式适配**：如何在不同屏幕尺寸下保持良好体验？\n\n这些问题的核心都指向一个关键点：**我们需要在正确的时机执行正确的操作**。\n\n## 二、React 渲染机制深度解析\n\n### 2.1 React 的工作流程\n\n在深入代码之前，我们先来理解 React 的完整工作流程：\n\n```mermaid\ngraph TB\n    A[用户交互/Props变化] --> B[触发状态更新]\n    B --> C[React 调度更新]\n    C --> D[Render Phase<br/>渲染阶段]\n    D --> E[Reconciliation<br/>协调过程]\n    E --> F[生成 Fiber 树]\n    F --> G[Commit Phase<br/>提交阶段]\n    G --> H[更新 DOM]\n    H --> I[执行 useLayoutEffect]\n    I --> J[浏览器绘制]\n    J --> K[执行 useEffect]\n    K --> L[用户看到更新]\n    \n    style D fill:#f9f,stroke:#333,stroke-width:2px\n    style G fill:#9ff,stroke:#333,stroke-width:2px\n    style J fill:#ff9,stroke:#333,stroke-width:2px\n```\n\n### 2.2 三个关键阶段\n\n#### 阶段一：Render Phase（渲染阶段）\n\n- **特点**：可中断、可恢复、可并发\n- **任务**：调用组件函数，生成新的虚拟 DOM 树\n- **限制**：不能执行副作用（side effects）\n\n```javascript\n// 这个阶段执行的代码\nfunction MyComponent({ data }) {\n  // ✅ 纯计算\n  const processedData = useMemo(() => processData(data), [data]);\n  \n  // ❌ 不要在这里执行副作用\n  // document.title = 'New Title'; // 错误！\n  \n  return <div>{processedData}</div>;\n}\n```\n\n#### 阶段二：Commit Phase（提交阶段）\n\n- **特点**：同步执行，不可中断\n- **任务**：将变更应用到真实 DOM\n- **时机**：useLayoutEffect 在此阶段执行\n\n```javascript\nfunction MyComponent() {\n  useLayoutEffect(() => {\n    // 这里 DOM 已更新，但浏览器还未绘制\n    // 适合进行 DOM 测量或紧急的样式调整\n    const height = ref.current.scrollHeight;\n    console.log('真实高度:', height);\n  });\n}\n```\n\n#### 阶段三：Browser Paint（浏览器绘制）\n\n- **特点**：浏览器的工作，React 不参与\n- **任务**：计算布局、绘制像素\n- **时机**：useEffect 在此之后执行\n\n### 2.3 时序对比图\n\n让我们通过一个详细的时序图来对比不同 Hook 的执行时机：\n\n```mermaid\nsequenceDiagram\n    participant User as 用户\n    participant React as React\n    participant DOM as DOM\n    participant Browser as 浏览器\n    participant Effect as useEffect\n    participant LayoutEffect as useLayoutEffect\n    \n    User->>React: 点击按钮\n    React->>React: setState 更新状态\n    \n    rect rgb(255, 230, 230)\n        Note over React: Render Phase 开始\n        React->>React: 调用组件函数\n        React->>React: 生成虚拟 DOM\n        React->>React: Diff 算法对比\n        Note over React: Render Phase 结束\n    end\n    \n    rect rgb(230, 255, 230)\n        Note over React,DOM: Commit Phase 开始\n        React->>DOM: 更新真实 DOM\n        DOM-->>React: DOM 更新完成\n        React->>LayoutEffect: 同步执行 useLayoutEffect\n        LayoutEffect-->>React: 执行完成\n        Note over React,DOM: Commit Phase 结束\n    end\n    \n    rect rgb(230, 230, 255)\n        Note over Browser: Paint Phase 开始\n        DOM->>Browser: 触发重排/重绘\n        Browser->>Browser: 计算布局\n        Browser->>Browser: 绘制像素\n        Browser->>User: 显示更新后的界面\n        Note over Browser: Paint Phase 结束\n    end\n    \n    Browser->>Effect: 异步执行 useEffect\n    Effect-->>React: 执行完成\n```\n\n## 三、代码实战：剖析折叠组件的实现\n\n现在让我们来看看实际的代码实现，我会逐步解析每个关键部分。\n\n### 3.1 组件整体结构\n\n首先，让我们了解组件的整体结构：\n\n```javascript\n// 主组件：SecondCategoryBox\nconst SecondCategoryBox = ({\n  categoryList,        // 分类数据\n  defaultCategoryIds,  // 默认选中项\n  maxVisibleRows,      // 最大可见行数\n  onCategoryChange     // 选中项变化回调\n}) => {\n  // 状态管理\n  const [activeIDList, setActiveIDList] = useState([]);\n  \n  // 使用自定义 Hook 管理折叠逻辑\n  const { containerRef, isExpanded, showToggleButton, setIsExpanded } = useCollapse({\n    maxVisibleRows,\n    dependencies: [categoryList]\n  });\n  \n  // 渲染逻辑...\n};\n```\n\n### 3.2 核心难点一：精确的高度计算\n\n这是整个组件最核心的部分。我们需要：\n\n1. 获取内容的完整高度（展开时的高度）\n2. 计算折叠时应该显示的高度\n3. 决定是否需要显示展开/收起按钮\n\n```javascript\nconst calculateHeightsWithScale = useCallback(() => {\n  if (!containerRef.current) return;\n  \n  const container = containerRef.current;\n  \n  // 步骤1：临时解除高度限制\n  const originalHeight = container.style.height;\n  const originalOverflow = container.style.overflow;\n  \n  container.style.height = 'auto';\n  container.style.overflow = 'visible';\n  \n  // 步骤2：测量真实高度\n  // 注意：这里必须等待浏览器完成布局计算\n  const fullHeight = container.scrollHeight;\n  \n  // 步骤3：计算折叠高度\n  const visibleHeight = rowHeight * maxVisibleRows + gap * (maxVisibleRows - 1);\n  \n  // 步骤4：恢复原始样式\n  container.style.height = originalHeight;\n  container.style.overflow = originalOverflow;\n  \n  // 步骤5：更新状态\n  setHeights({ full: fullHeight, visible: visibleHeight });\n  setShowToggleButton(fullHeight > visibleHeight);\n}, [maxVisibleRows, rowHeight, gap]);\n```\n\n**关键问题：什么时候调用这个函数？**\n\n### 3.3 核心难点二：选择正确的执行时机\n\n这就涉及到我们要深入讨论的 React 渲染时机问题。让我们看看不同方案的对比：\n\n#### 方案一：使用 useEffect（❌ 会闪烁）\n\n```javascript\nuseEffect(() => {\n  calculateHeightsWithScale();\n}, [categoryList]);\n```\n\n**问题分析**：\n\n```mermaid\ngraph LR\n    A[分类数据变化] --> B[组件重新渲染]\n    B --> C[DOM 更新]\n    C --> D[浏览器绘制]\n    D --> E[用户看到错误高度]\n    E --> F[useEffect 执行]\n    F --> G[计算并设置正确高度]\n    G --> H[再次渲染]\n    H --> I[用户看到正确高度]\n    \n    style E fill:#ffcccc\n    style I fill:#ccffcc\n```\n\n用户会先看到错误的高度，然后突然跳到正确高度——这就是\"闪烁\"！\n\n#### 方案二：使用 useLayoutEffect（⚠️ 可能阻塞渲染）\n\n```javascript\nuseLayoutEffect(() => {\n  calculateHeightsWithScale();\n}, [categoryList]);\n```\n\n**优点**：在浏览器绘制前执行，避免闪烁 **缺点**：同步执行，可能阻塞渲染，影响性能\n\n#### 方案三：使用 requestAnimationFrame（✅ 最佳方案）\n\n```javascript\nuseEffect(() => {\n  requestAnimationFrame(() => {\n    calculateHeightsWithScale();\n  });\n}, [categoryList]);\n```\n\n**为什么这是最佳方案？**\n\n```mermaid\ngraph TB\n    A[useEffect 执行] --> B[注册 RAF 回调]\n    B --> C[浏览器完成当前帧绘制]\n    C --> D[布局信息已确定]\n    D --> E[RAF 回调执行]\n    E --> F[准确获取高度]\n    F --> G[更新组件状态]\n    \n    style D fill:#ccffcc\n    style F fill:#ccffcc\n```\n\nrequestAnimationFrame 确保：\n\n1. 不阻塞当前的渲染\n2. 在下一帧开始前执行\n3. 此时布局计算已完成，可以准确获取尺寸\n\n### 3.4 核心难点三：优雅地处理动画\n\n当用户切换一级分类时，我们需要重置二级分类，但不希望用户看到收起动画：\n\n```javascript\nuseEffect(() => {\n  if (firstUpdate) {\n    // 首次加载，使用默认选中项\n    setActiveIDList(defaultCategoryIds);\n    setFirstUpdate(false);\n  } else {\n    // 切换分类时的处理\n    \n    // 步骤1：立即禁用 CSS 过渡\n    setEnableTransition(false);\n    \n    // 步骤2：重置所有状态\n    setIsExpanded(false);\n    setActiveIDList([]);\n    \n    // 步骤3：在下一帧恢复过渡效果\n    requestAnimationFrame(() => {\n      setEnableTransition(true);\n    });\n  }\n}, [categoryList]);\n```\n\n**时序分析**：\n\n```mermaid\nsequenceDiagram\n    participant User as 用户\n    participant Component as 组件\n    participant CSS as CSS动画\n    participant Browser as 浏览器\n    \n    User->>Component: 切换一级分类\n    Component->>Component: categoryList 变化\n    Component->>CSS: 禁用 transition\n    Component->>Component: 重置状态（高度变为折叠状态）\n    Note over CSS: 无动画，瞬间变化\n    Component->>Browser: 请求下一帧\n    Browser-->>Component: 下一帧开始\n    Component->>CSS: 启用 transition\n    Note over CSS: 后续交互有动画\n```\n\n### 3.5 性能优化：响应式设计\n\n组件还实现了一个巧妙的响应式系统：\n\n```javascript\nconst calculateScale = useCallback(() => {\n  const currentWidth = window.innerWidth;\n  const scale = currentWidth / baseWidth;\n  \n  // 限制缩放范围，避免极端情况\n  const clampedScale = Math.max(0.8, Math.min(1.5, scale));\n  \n  return {\n    scale: clampedScale,\n    rowHeight: Math.round(baseRowHeight * clampedScale),\n    gap: Math.round(baseGap * clampedScale)\n  };\n}, [baseWidth, baseRowHeight, baseGap]);\n```\n\n这确保了组件在不同设备上都有合适的显示效果。\n\n## 四、深入理解 useEffect 和 useLayoutEffect\n\n### 4.1 本质区别\n\n```javascript\n// useEffect：在浏览器完成绘制后异步执行\nuseEffect(() => {\n  console.log('1. DOM 已更新');\n  console.log('2. 浏览器已绘制');\n  console.log('3. 用户已看到变化');\n  console.log('4. 现在执行不会阻塞渲染');\n});\n\n// useLayoutEffect：在浏览器绘制前同步执行\nuseLayoutEffect(() => {\n  console.log('1. DOM 已更新');\n  console.log('2. 浏览器还未绘制');\n  console.log('3. 用户还看不到变化');\n  console.log('4. 可以在这里调整样式避免闪烁');\n});\n```\n\n### 4.2 使用场景对比\n\n```mermaid\ngraph TB\n    A[需要执行副作用] --> B{是否影响视觉呈现?}\n    \n    B -->|是| C{是否需要 DOM 测量?}\n    B -->|否| D[使用 useEffect]\n    \n    C -->|是| E{测量是否紧急?}\n    C -->|否| F[使用 useLayoutEffect]\n    \n    E -->|是| G[useLayoutEffect]\n    E -->|否| H[useEffect + RAF]\n    \n    D --> I[数据获取<br/>事件订阅<br/>日志上报]\n    F --> J[阻止闪烁<br/>同步滚动<br/>焦点管理]\n    G --> K[关键布局计算<br/>动画初始状态]\n    H --> L[非关键测量<br/>性能优化]\n    \n    style B fill:#ffffcc\n    style C fill:#ffffcc\n    style E fill:#ffffcc\n```\n\n### 4.3 实际案例对比\n\n让我们通过几个实际例子来加深理解：\n\n#### 案例1：工具提示定位\n\n```javascript\nfunction Tooltip({ children, content }) {\n  const [position, setPosition] = useState({ top: 0, left: 0 });\n  const triggerRef = useRef();\n  const tooltipRef = useRef();\n  \n  // ✅ 使用 useLayoutEffect 避免工具提示闪烁\n  useLayoutEffect(() => {\n    if (triggerRef.current && tooltipRef.current) {\n      const triggerRect = triggerRef.current.getBoundingClientRect();\n      const tooltipRect = tooltipRef.current.getBoundingClientRect();\n      \n      setPosition({\n        top: triggerRect.top - tooltipRect.height - 8,\n        left: triggerRect.left + (triggerRect.width - tooltipRect.width) / 2\n      });\n    }\n  }, []);\n  \n  return (\n    <>\n      <span ref={triggerRef}>{children}</span>\n      <div \n        ref={tooltipRef}\n        className=\"tooltip\"\n        style={{ position: 'fixed', ...position }}\n      >\n        {content}\n      </div>\n    </>\n  );\n}\n```\n\n#### 案例2：滚动位置恢复\n\n```javascript\nfunction ScrollRestore({ location }) {\n  // ✅ 使用 useLayoutEffect 立即恢复滚动位置\n  useLayoutEffect(() => {\n    const savedPosition = sessionStorage.getItem(`scroll-${location}`);\n    if (savedPosition) {\n      window.scrollTo(0, parseInt(savedPosition));\n    }\n  }, [location]);\n  \n  // ✅ 使用 useEffect 保存滚动位置（非紧急）\n  useEffect(() => {\n    const handleScroll = () => {\n      sessionStorage.setItem(`scroll-${location}`, window.scrollY);\n    };\n    \n    window.addEventListener('scroll', handleScroll);\n    return () => window.removeEventListener('scroll', handleScroll);\n  }, [location]);\n}\n```\n\n#### 案例3：动画序列\n\n```javascript\nfunction AnimatedList({ items }) {\n  const [visibleItems, setVisibleItems] = useState([]);\n  \n  // ❌ 错误：在 useLayoutEffect 中做复杂计算\n  // useLayoutEffect(() => {\n  //   items.forEach((item, index) => {\n  //     setTimeout(() => {\n  //       setVisibleItems(prev => [...prev, item]);\n  //     }, index * 100);\n  //   });\n  // }, [items]);\n  \n  // ✅ 正确：使用 useEffect + RAF\n  useEffect(() => {\n    let frameId;\n    let index = 0;\n    \n    const animate = () => {\n      if (index < items.length) {\n        setVisibleItems(prev => [...prev, items[index]]);\n        index++;\n        frameId = requestAnimationFrame(animate);\n      }\n    };\n    \n    frameId = requestAnimationFrame(animate);\n    \n    return () => {\n      if (frameId) {\n        cancelAnimationFrame(frameId);\n      }\n    };\n  }, [items]);\n}\n```\n\n## 五、requestAnimationFrame 的高级应用\n\n### 5.1 什么是 requestAnimationFrame？\n\nrequestAnimationFrame（简称 RAF）是浏览器提供的一个 API，用于在下一次重绘之前执行动画。它的执行时机非常特殊：\n\n```mermaid\ngraph LR\n    A[帧开始] --> B[处理用户输入]\n    B --> C[JS 执行]\n    C --> D[RAF 回调]\n    D --> E[样式计算]\n    E --> F[布局]\n    F --> G[绘制]\n    G --> H[合成]\n    H --> I[帧结束]\n    \n    style D fill:#ffcccc\n```\n\n### 5.2 在 React 中的应用场景\n\n#### 场景1：确保布局完成后测量\n\n```javascript\nfunction useMeasure() {\n  const ref = useRef();\n  const [bounds, setBounds] = useState({});\n  \n  useEffect(() => {\n    if (!ref.current) return;\n    \n    // 确保在布局稳定后测量\n    const measure = () => {\n      requestAnimationFrame(() => {\n        if (ref.current) {\n          setBounds(ref.current.getBoundingClientRect());\n        }\n      });\n    };\n    \n    measure();\n    window.addEventListener('resize', measure);\n    \n    return () => window.removeEventListener('resize', measure);\n  }, []);\n  \n  return [ref, bounds];\n}\n```\n\n#### 场景2：批量 DOM 操作\n\n```javascript\nfunction batchDOMUpdates(updates) {\n  requestAnimationFrame(() => {\n    // 在一个帧内完成所有 DOM 操作\n    updates.forEach(update => update());\n    \n    // 强制浏览器立即计算样式（如果需要读取）\n    // 注意：这会触发强制同步布局，谨慎使用\n    if (needsRead) {\n      document.body.offsetHeight; // 强制重排\n    }\n  });\n}\n```\n\n#### 场景3：平滑动画\n\n```javascript\nfunction useAnimation(duration = 300) {\n  const [progress, setProgress] = useState(0);\n  const frameRef = useRef();\n  const startTimeRef = useRef();\n  \n  const start = useCallback(() => {\n    startTimeRef.current = performance.now();\n    \n    const animate = (currentTime) => {\n      const elapsed = currentTime - startTimeRef.current;\n      const progress = Math.min(elapsed / duration, 1);\n      \n      setProgress(progress);\n      \n      if (progress < 1) {\n        frameRef.current = requestAnimationFrame(animate);\n      }\n    };\n    \n    frameRef.current = requestAnimationFrame(animate);\n  }, [duration]);\n  \n  useEffect(() => {\n    return () => {\n      if (frameRef.current) {\n        cancelAnimationFrame(frameRef.current);\n      }\n    };\n  }, []);\n  \n  return [progress, start];\n}\n```\n\n### 5.3 RAF vs setTimeout/setInterval\n\n```javascript\n// ❌ 不推荐：可能导致掉帧或不流畅\nuseEffect(() => {\n  const timer = setInterval(() => {\n    setPosition(prev => prev + 1);\n  }, 16); // 约 60fps\n  \n  return () => clearInterval(timer);\n}, []);\n\n// ✅ 推荐：与浏览器刷新率同步\nuseEffect(() => {\n  let frameId;\n  \n  const animate = () => {\n    setPosition(prev => prev + 1);\n    frameId = requestAnimationFrame(animate);\n  };\n  \n  frameId = requestAnimationFrame(animate);\n  \n  return () => cancelAnimationFrame(frameId);\n}, []);\n```\n\n## 六、常见问题与最佳实践\n\n### 6.1 常见错误及解决方案\n\n#### 错误1：在渲染阶段读取 DOM\n\n```javascript\n// ❌ 错误\nfunction BadComponent() {\n  const ref = useRef();\n  // 这里 ref.current 可能是 null\n  const height = ref.current?.offsetHeight || 0;\n  \n  return <div ref={ref}>Content</div>;\n}\n\n// ✅ 正确\nfunction GoodComponent() {\n  const ref = useRef();\n  const [height, setHeight] = useState(0);\n  \n  useEffect(() => {\n    if (ref.current) {\n      setHeight(ref.current.offsetHeight);\n    }\n  }, []);\n  \n  return <div ref={ref}>Content</div>;\n}\n```\n\n#### 错误2：过度使用 useLayoutEffect\n\n```javascript\n// ❌ 错误：非视觉相关操作\nuseLayoutEffect(() => {\n  // 数据获取不应该阻塞渲染\n  fetch('/api/data').then(setData);\n}, []);\n\n// ✅ 正确\nuseEffect(() => {\n  fetch('/api/data').then(setData);\n}, []);\n```\n\n#### 错误3：忽视清理函数\n\n```javascript\n// ❌ 错误：内存泄漏\nuseEffect(() => {\n  const timer = setInterval(() => {\n    console.log('tick');\n  }, 1000);\n  // 忘记清理！\n}, []);\n\n// ✅ 正确\nuseEffect(() => {\n  const timer = setInterval(() => {\n    console.log('tick');\n  }, 1000);\n  \n  return () => clearInterval(timer);\n}, []);\n```\n\n### 6.2 性能优化建议\n\n#### 1. 避免不必要的布局计算\n\n```javascript\n// ❌ 性能差：每次渲染都计算\nfunction BadComponent({ items }) {\n  const heights = items.map(item => {\n    const element = document.getElementById(item.id);\n    return element?.offsetHeight || 0;\n  });\n}\n\n// ✅ 性能好：只在必要时计算\nfunction GoodComponent({ items }) {\n  const [heights, setHeights] = useState([]);\n  \n  useEffect(() => {\n    requestAnimationFrame(() => {\n      const newHeights = items.map(item => {\n        const element = document.getElementById(item.id);\n        return element?.offsetHeight || 0;\n      });\n      setHeights(newHeights);\n    });\n  }, [items]);\n}\n```\n\n#### 2. 批量更新 DOM\n\n```javascript\n// ✅ 批量读取和写入\nfunction BatchUpdate({ items }) {\n  useLayoutEffect(() => {\n    // 第一阶段：批量读取\n    const measurements = items.map(item => ({\n      id: item.id,\n      height: document.getElementById(item.id)?.offsetHeight || 0\n    }));\n    \n    // 第二阶段：批量写入\n    measurements.forEach(({ id, height }) => {\n      const element = document.getElementById(id);\n      if (element) {\n        element.style.transform = `translateY(${height}px)`;\n      }\n    });\n  }, [items]);\n}\n```\n\n#### 3. 使用 CSS 代替 JS 动画\n\n```javascript\n// ❌ JS 动画（性能较差）\nconst [height, setHeight] = useState(0);\nuseEffect(() => {\n  let current = 0;\n  const timer = setInterval(() => {\n    current += 5;\n    setHeight(current);\n    if (current >= 100) clearInterval(timer);\n  }, 16);\n}, []);\n\n// ✅ CSS 动画（性能更好）\nconst [expanded, setExpanded] = useState(false);\nreturn (\n  <div \n    className={`container ${expanded ? 'expanded' : ''}`}\n    style={{\n      transition: 'height 0.3s ease-out',\n      height: expanded ? '100px' : '0px'\n    }}\n  />\n);\n```\n\n### 6.3 调试技巧\n\n#### 1. 可视化渲染时机\n\n```javascript\nfunction useRenderLog(name) {\n  console.log(`${name} rendering`);\n  \n  useLayoutEffect(() => {\n    console.log(`${name} layout effect`);\n  });\n  \n  useEffect(() => {\n    console.log(`${name} effect`);\n    \n    requestAnimationFrame(() => {\n      console.log(`${name} next frame`);\n    });\n  });\n}\n```\n\n#### 2. 性能监控\n\n```javascript\nfunction usePerformanceMonitor(name) {\n  const renderStart = performance.now();\n  \n  useLayoutEffect(() => {\n    const layoutEffectTime = performance.now();\n    console.log(`${name} to layout effect: ${layoutEffectTime - renderStart}ms`);\n  });\n  \n  useEffect(() => {\n    const effectTime = performance.now();\n    console.log(`${name} to effect: ${effectTime - renderStart}ms`);\n    \n    requestAnimationFrame(() => {\n      const frameTime = performance.now();\n      console.log(`${name} to next frame: ${frameTime - renderStart}ms`);\n    });\n  });\n}\n```\n\n## 七、React 18 并发特性与渲染时机\n\n### 7.1 并发渲染的影响\n\nReact 18 引入的并发特性改变了一些渲染行为：\n\n```javascript\nimport { startTransition, useDeferredValue, useId } from 'react';\n\nfunction ConcurrentComponent({ searchTerm, items }) {\n  // 延迟非紧急更新\n  const deferredSearchTerm = useDeferredValue(searchTerm);\n  \n  // 标记低优先级更新\n  const handleExpensiveUpdate = () => {\n    startTransition(() => {\n      // 这个更新可以被中断\n      setExpensiveState(calculateExpensiveValue());\n    });\n  };\n  \n  // 紧急更新仍然同步处理\n  const handleUrgentUpdate = () => {\n    setUrgentState(value); // 立即响应\n  };\n}\n```\n\n### 7.2 并发渲染下的 useEffect\n\n在并发模式下，组件可能会多次渲染但只提交一次：\n\n```mermaid\ngraph TB\n    A[开始渲染] --> B{高优先级更新?}\n    B -->|是| C[中断当前渲染]\n    B -->|否| D[继续渲染]\n    C --> E[处理高优先级]\n    E --> F[重新开始低优先级]\n    D --> G[提交到 DOM]\n    F --> D\n    G --> H[执行 Effects]\n    \n    style C fill:#ffcccc\n    style E fill:#ffcccc\n```\n\n### 7.3 实践建议\n\n```javascript\nfunction SearchResults({ query }) {\n  const [results, setResults] = useState([]);\n  const [isSearching, setIsSearching] = useState(false);\n  \n  // 使用 useDeferredValue 优化搜索体验\n  const deferredQuery = useDeferredValue(query);\n  \n  // 紧急：显示加载状态\n  useEffect(() => {\n    setIsSearching(query !== deferredQuery);\n  }, [query, deferredQuery]);\n  \n  // 非紧急：执行搜索\n  useEffect(() => {\n    let cancelled = false;\n    \n    async function doSearch() {\n      const data = await searchAPI(deferredQuery);\n      if (!cancelled) {\n        startTransition(() => {\n          setResults(data);\n        });\n      }\n    }\n    \n    doSearch();\n    \n    return () => {\n      cancelled = true;\n    };\n  }, [deferredQuery]);\n  \n  return (\n    <div>\n      {isSearching && <Spinner />}\n      <ResultsList results={results} />\n    </div>\n  );\n}\n```\n\n## 八、实战总结：回到我们的折叠组件\n\n现在，让我们用学到的知识重新审视最初的折叠组件，看看它是如何解决各种渲染时机问题的：\n\n### 8.1 问题与解决方案对照\n\n| 问题                 | 解决方案             | 原理                  |\n| -------------------- | -------------------- | --------------------- |\n| 获取准确的内容高度   | useEffect + RAF      | 确保布局计算完成      |\n| 切换分类时的动画闪烁 | 禁用/启用 transition | 精确控制 CSS 动画时机 |\n| 响应式适配           | 动态计算缩放比例     | 避免频繁的 DOM 操作   |\n| 首次加载的默认状态   | firstUpdate 标记     | 区分初始化和更新      |\n\n### 8.2 完整的渲染流程\n\n```mermaid\nsequenceDiagram\n    participant U as 用户\n    participant C as 组件\n    participant D as DOM\n    participant B as 浏览器\n    \n    Note over U,B: 场景1：组件首次加载\n    U->>C: 页面加载\n    C->>C: 初始化状态\n    C->>D: 渲染 DOM\n    C->>C: useEffect 执行\n    C->>B: RAF 注册回调\n    B->>C: 下一帧执行测量\n    C->>C: 设置正确高度\n    C->>D: 更新 DOM\n    B->>U: 显示完整内容\n    \n    Note over U,B: 场景2：用户点击展开\n    U->>C: 点击展开按钮\n    C->>C: setIsExpanded(true)\n    C->>D: 更新高度样式\n    Note over D,B: CSS transition 生效\n    B->>U: 平滑展开动画\n    \n    Note over U,B: 场景3：切换分类\n    U->>C: 选择新分类\n    C->>C: 禁用 transition\n    C->>C: 重置状态\n    C->>D: 立即更新（无动画）\n    C->>B: RAF 注册回调\n    B->>C: 下一帧恢复 transition\n    Note over C,B: 后续交互恢复动画\n```\n\n### 8.3 关键代码片段回顾\n\n```javascript\n// 1. 自定义 Hook 封装复杂逻辑\nexport const useCollapse = (options) => {\n  const { maxVisibleRows = 2, dependencies = [] } = options;\n  const containerRef = useRef();\n  const [isExpanded, setIsExpanded] = useState(false);\n  const [showToggleButton, setShowToggleButton] = useState(false);\n  \n  // 2. 使用 RAF 确保准确测量\n  useEffect(() => {\n    requestAnimationFrame(() => calculateHeightsWithScale());\n  }, dependencies);\n  \n  // 3. 返回必要的状态和引用\n  return {\n    containerRef,\n    isExpanded,\n    showToggleButton,\n    setIsExpanded,\n    containerStyle: {\n      height: !showToggleButton ? 'auto' : \n              isExpanded ? heights.full : heights.visible,\n      overflow: 'hidden',\n      transition: 'height 0.3s ease-in-out'\n    }\n  };\n};\n```\n\n## 九、写在最后\n\n通过这个真实的电商项目案例，我们深入探讨了 React 的渲染时机问题。让我们再次总结一下核心要点：\n\n### 9.1 核心原则\n\n1. **理解时机**：知道代码在 React 生命周期的哪个阶段执行\n2. **选对工具**：useEffect、useLayoutEffect、RAF 各有适用场景\n3. **避免闪烁**：需要立即生效的视觉变化用 useLayoutEffect\n4. **性能优先**：非紧急操作放在 useEffect 中异步执行\n5. **精确控制**：使用 RAF 在正确的时机进行 DOM 测量\n\n### 9.2 决策流程图\n\n```mermaid\ngraph TD\n    A[需要副作用?] -->|是| B[影响视觉?]\n    A -->|否| Z[纯组件逻辑]\n    \n    B -->|是| C[需要 DOM 测量?]\n    B -->|否| D[useEffect]\n    \n    C -->|是| E[测量紧急?]\n    C -->|否| F[useLayoutEffect]\n    \n    E -->|是| G[useLayoutEffect]\n    E -->|否| H[useEffect + RAF]\n    \n    D --> I[异步操作<br/>数据获取<br/>事件订阅]\n    F --> J[防止闪烁<br/>滚动恢复]\n    G --> K[关键测量<br/>初始定位]\n    H --> L[性能优化<br/>非关键测量]\n    \n    style A fill:#f9f,stroke:#333,stroke-width:4px\n    style B fill:#bbf,stroke:#333,stroke-width:2px\n    style C fill:#bbf,stroke:#333,stroke-width:2px\n    style E fill:#bbf,stroke:#333,stroke-width:2px\n```\n\n### 9.3 从理论到实践\n\n理解 React 的渲染时机不仅仅是理论知识，更是解决实际问题的关键。当你遇到以下问题时，请想起这篇文章：\n\n- 页面闪烁 → 检查是否应该使用 useLayoutEffect\n- 获取的尺寸为 0 → 使用 RAF 确保布局完成\n- 动画卡顿 → 考虑使用 CSS 动画或 RAF\n- 性能问题 → 将非紧急操作移到 useEffect\n\n## 十、参考资料\n\n1. [React 官方文档 - Hooks Reference](https://react.dev/reference/react)\n2. [React 源码解析 - Fiber 架构](https://github.com/facebook/react)\n3. [Web 性能优化 - requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)\n4. [React 18 Working Group](https://github.com/reactwg/react-18)\n5. [浏览器渲染原理](https://developers.google.com/web/fundamentals/performance/rendering)\n\n------\n\n*如果这篇文章对你有帮助，欢迎点赞、收藏和分享。有任何问题或不同见解，也欢迎在评论区讨论！*\n","tags":["React","项目案例","性能优化","前端开发"],"categories":["从项目到技术"]},{"title":"【概念解析】前端开发中的polypill","url":"/2025/07/22/【概念解析】前端开发中的Polyfill/","content":"\n\n\n## 什么是 Polyfill？\n\n**Polyfill** 是一段代码（通常是 JavaScript），用来为旧浏览器提供它没有原生支持的较新的功能。\n\n### 名字的由来 🎨\n\n\"Polyfill\" 这个词来源于一种建筑材料 Polyfilla（一种用于填补墙面裂缝的腻子），形象地表示\"填补浏览器功能的空缺\"。\n\n## 为什么需要 Polyfill？\n\n```javascript\n// 🌰 例子：旧浏览器不支持 Array.includes\nconst fruits = ['apple', 'banana', 'orange'];\n\n// 新浏览器可以直接使用\nconsole.log(fruits.includes('banana')); // true\n\n// 旧浏览器会报错：fruits.includes is not a function\n```\n\n## 常见的 Polyfill 示例\n\n### 1. Array.includes Polyfill\n\n```javascript\n// 检查是否已经存在\nif (!Array.prototype.includes) {\n  Array.prototype.includes = function(searchElement, fromIndex) {\n    // 严格模式\n    'use strict';\n    \n    const O = Object(this);\n    const len = parseInt(O.length) || 0;\n    \n    if (len === 0) return false;\n    \n    const n = parseInt(fromIndex) || 0;\n    let k = Math.max(n >= 0 ? n : len + n, 0);\n    \n    while (k < len) {\n      if (searchElement === O[k]) return true;\n      k++;\n    }\n    \n    return false;\n  };\n}\n```\n\n### 2. Promise Polyfill\n\n```javascript\n// 简化版 Promise polyfill\nif (typeof Promise === 'undefined') {\n  window.Promise = function(executor) {\n    // Promise 实现代码...\n  };\n}\n```\n\n### 3. Object.assign Polyfill\n\n```javascript\nif (!Object.assign) {\n  Object.assign = function(target) {\n    'use strict';\n    \n    if (target == null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n    \n    const output = Object(target);\n    \n    for (let index = 1; index < arguments.length; index++) {\n      const source = arguments[index];\n      if (source != null) {\n        for (const key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            output[key] = source[key];\n          }\n        }\n      }\n    }\n    \n    return output;\n  };\n}\n```\n\n### 4. String.padStart Polyfill\n\n```javascript\nif (!String.prototype.padStart) {\n  String.prototype.padStart = function(targetLength, padString) {\n    targetLength = targetLength >> 0; // 转为整数\n    padString = String(padString || ' ');\n    \n    if (this.length >= targetLength) {\n      return String(this);\n    }\n    \n    targetLength = targetLength - this.length;\n    if (targetLength > padString.length) {\n      padString += padString.repeat(targetLength / padString.length);\n    }\n    \n    return padString.slice(0, targetLength) + String(this);\n  };\n}\n```\n\n## Polyfill vs 其他概念\n\n### 1. Polyfill vs Transpile（转译）\n\n```javascript\n// Polyfill：运行时补充缺失的 API\nArray.prototype.find = Array.prototype.find || function() { /* ... */ };\n\n// Transpile：编译时转换语法（如 Babel）\n// ES6 箭头函数\nconst add = (a, b) => a + b;\n// 转译后\nvar add = function(a, b) { return a + b; };\n```\n\n### 2. Polyfill vs Shim\n\n- **Polyfill**：实现标准 API，行为与规范一致\n- **Shim**：可能有自己的 API，不一定遵循标准\n\n## 如何使用 Polyfill？\n\n### 1. 手动引入\n\n```html\n<!-- 引入特定的 polyfill -->\n<script src=\"https://polyfill.io/v3/polyfill.min.js?features=Promise,Array.from\"></script>\n```\n\n### 2. 使用 core-js\n\n```javascript\n// 安装\nnpm install core-js\n\n// 使用\nimport 'core-js/features/array/includes';\nimport 'core-js/features/promise';\n```\n\n### 3. 使用 @babel/polyfill（已废弃）\n\n```javascript\n// 新的推荐方式\nnpm install core-js regenerator-runtime\n\n// babel.config.js\nmodule.exports = {\n  presets: [\n    ['@babel/preset-env', {\n      useBuiltIns: 'usage',\n      corejs: 3\n    }]\n  ]\n};\n```\n\n## 最佳实践\n\n### 1. 按需加载\n\n```javascript\n// 只在需要时加载 polyfill\nif (!window.Promise) {\n  // 动态加载 Promise polyfill\n  loadScript('promise-polyfill.js');\n}\n```\n\n### 2. 使用 polyfill.io 服务\n\n```html\n<!-- 根据用户浏览器自动返回需要的 polyfill -->\n<script src=\"https://polyfill.io/v3/polyfill.min.js\"></script>\n```\n\n### 3. 特性检测\n\n```javascript\n// 使用特性检测而不是浏览器检测\nfunction loadPolyfills() {\n  const polyfills = [];\n  \n  if (!window.Promise) {\n    polyfills.push(import('promise-polyfill'));\n  }\n  \n  if (!Array.prototype.includes) {\n    polyfills.push(import('array-includes-polyfill'));\n  }\n  \n  return Promise.all(polyfills);\n}\n\n// 加载完 polyfill 后再启动应用\nloadPolyfills().then(() => {\n  // 启动应用\n  startApp();\n});\n```\n\n## 常用的 Polyfill 库\n\n1. **core-js** - 最全面的 polyfill 库\n2. **polyfill.io** - 自动化 polyfill 服务\n3. **es5-shim/es6-shim** - ES5/ES6 polyfill\n4. **fetch-polyfill** - Fetch API polyfill\n5. **intersection-observer** - IntersectionObserver polyfill\n\n## 注意事项 ⚠️\n\n1. **性能影响**：Polyfill 会增加代码体积\n2. **选择性加载**：只加载需要的 polyfill\n3. **版本兼容**：确保 polyfill 支持目标浏览器\n4. **原生优先**：优先使用原生实现\n\n```javascript\n// 好的做法：先检测再添加\nif (!Array.prototype.flat) {\n  // 添加 polyfill\n}\n\n// 避免：直接覆盖\nArray.prototype.flat = function() { /* ... */ };\n```\n\n总之，Polyfill 是前端开发中实现向后兼容的重要手段，让我们能够在旧浏览器中使用新特性！","tags":["前端开发","概念解析"],"categories":["前端知识小册"]},{"title":"【秋招准备】面试手撕大集合","url":"/2025/07/22/【秋招备战】面试手撕大集合/","content":"\n# **所有遍历数组的方法**\n\n\n\n## forEach\n\n```JavaScript\n// 自定义 forEach 函数，添加到 Array 原型链\nArray.prototype.myForEach = function (callback, thisArg) {\n\n    // 类型检查：确保 callback 是一个函数\n    if (typeof callback !== 'function') {\n        throw new TypeError('第一个参数必须是一个函数');\n    }\n\n    // 遍历数组，调用 callback 函数\n    for (let i = 0; i < this.length; i++) {\n        // 如果数组的当前元素是 undefined 或 null, 则跳过\n        if (i in this) {//对于数组而言，in运算符用于检查是否有这个索引值\n            callback.call(thisArg, this[i], i, this);\n        }\n    }\n};\n```\n\n## map\n\n```JavaScript\n// 自定义 Map 函数，添加到 Array 原型链\nArray.prototype.myMap = function (callback) {\n\n    // 类型检查：确保 callback 是一个函数\n    if (typeof callback !== 'function') {\n        throw new TypeError('第一个参数必须是一个函数');\n    }\n    let res = [];\n\n    // 遍历数组，调用 callback 函数\n    for (let i = 0; i < this.length; i++) {\n        // 如果数组的当前元素是 undefined 或 null, 则跳过\n        if (i in this) {\n            res.push(callback(this[i], i, this));\n        }\n    }\n    return res\n};\n```\n\n## Filter\n\n```JavaScript\nArray.prototype.my_filter = function (cb) {\n    let newArr = []\n    for (var i = 0; i < this.length; i++) {\n        if (cb(this[i], i, this)) {\n            newArr.push(this[i])\n        }\n    }\n    return newArr\n}\n```\n\n## every(判断数组中的每一个元素是否都满足某个条件)\n\n```JavaScript\nArray.prototype.my_every = function (cb) {\n    for (let i = 0; i < this.length; i++) {\n        if (!cb(this[i], i, this)) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n## some（判断数组中是否存在一个元素满足某个条件）\n\n```JavaScript\nArray.prototype.my_some = function (cb) {\n    for (let i = 0; i < this.length; i++) {\n        if (cb(this[i], i, this)) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n## reduce\n\n```JavaScript\nArray.prototype.my_reduce = function (cb, ...args) {\n    let start, index = 0\n    if (args.length) {\n        start = args[0]\n    } else {\n        start = this[0];\n        index = 1\n    }\n    for (let i = index; i < this.length; i++) {\n        start = cb(start, this[i], i, this);\n    }\n    return start;\n}\n```\n\n## includes\n\n```JavaScript\nArray.prototype.my_includes = function (item, ...args) {\n    let index\n    if (args.length && !Number.isNaN(Number(args[0])) && Number(args[0])>0) {\n        index = Number(args[0])\n    } else {\n        index = 0;\n    }\n    for (let i = index; i < this.length; i++) {\n        if (this[i] === item) return true;\n    }\n    return false\n}\n```\n\n## splice\n\n```JavaScript\nArray.prototype.mySplice = function (start, len, ...args) {\n    let newArr = [], resArr = [];\n    if (arguments.length === 0) return resArr;\n\n    if (typeof len === 'undefined') {\n        len = 0;\n    }\n    if (typeof start === 'undefined') {\n        start = 0;\n    } else if (start < 0) {\n        start = start + this.length;\n        start = start < 0 ? 0 : start;\n    } else if (start >= this.length) {\n        start = this.length;\n    }\n\n    for (let i = 0; i < this.length; ++i) {\n        if (i < start || i >= start + len) {\n            newArr.push(this[i]);\n        } else {\n            resArr.push(this[i]);\n        }\n        if (i === start || start + i === this.length * 2 - 1) {\n            newArr.push(...args);\n        }\n    }\n    while (this.length) {\n        this.pop();\n    }\n    this.push(...newArr);\n    return resArr;\n}\n```\n\n# JS内置方法、对象以及运算符\n\n## new运算符\n\n```javascript\nfunction myNew (Func, ...arg){\n        if (fn.prototype === undefined) throw new TypeError('function is not a constructor');\n        let obj = {}  //定义了一个对象。\n        obj.__proto__ = Func.prototype  \n        //将Func.prototype赋值为对象的__proto__属性,即原型链的概念\n        let res = Func.call(obj, ...arg) //更改Func的this指向\n        return res instanceof Object ? res : obj \n}\n```\n\n## 手撕curry\n\n```javascript\nconst my_curry = (fn, ...args) =>\n    args.length >= fn.length\n        ? fn(...args)\n        : (...args1) => my_curry(fn, ...args, ...args1);\n\nfunction adder(x, y, z) {\n    return x + y + z;\n}\nconst add = my_curry(adder);\nconsole.log(add(1, 2, 3));  //6\nconsole.log(add(1)(2)(3));  //6\nconsole.log(add(1, 2)(3));  //6\nconsole.log(add(1)(2, 3));  //6\n```\n\n## 手写compose函数\n\n```JavaScript\nconst compose = (...fns)=>(x)=>fns.reduceRight((v, fn)=>fn(v),x);\nconst doubleAndSuare = compose(double, square);//先翻倍再平方\nconsole.log(doubleAndSuare(3));\n```\n\n## 手撕vue3响应式代理\n\n```javascript\n//测试代码\nclass Depend {\n  constructor() {\n    this.reactiveFns = new Set()//依赖组\n  }\n\n  // 更好的收集依赖\n  depend() {\n    if (activeReactiveFn) this.reactiveFns.add(activeReactiveFn)\n  }\n\n  //对所有依赖进行统一通知处理\n  notify() {\n    console.log(this.reactiveFns)\n    this.reactiveFns.forEach(fn => {\n      //遍历依赖处理\n      if (fn) fn()\n    })\n  }\n}\n\n// 封装响应式函数\nlet activeReactiveFn = null\nfunction watchFn(fn) {\n  activeReactiveFn = fn\n  fn()\n  activeReactiveFn = null\n}\n\n// 封装一个获取depend函数\nconst targetMap = new WeakMap()\nfunction getDepend(target, key) {\n  // 1、根据target对象获取map的过程\n  let map = targetMap.get(target)\n  if (!map) {\n    map = new Map()\n    targetMap.set(target, map)\n  }\n  // 2、根据对象属性获取depend依赖\n  let depend = map.get(key)\n  if (!depend) {\n    depend = new Depend()\n    map.set(key, depend)\n  }\n  return depend\n}\n\n\n//使用Proxy监听对象变化\nfunction reactive(obj) {\n  return new Proxy(obj, {\n    get: function (target, key, receiver) {\n      const depend = getDepend(target, key)\n      depend.depend()\n      return Reflect.get(target, key, receiver)\n    },\n    set: function (target, key, newValue, receiver) {\n      Reflect.set(target, key, newValue, receiver)\n      const depend = getDepend(target, key)\n      depend.notify()\n    }\n  })\n}\n\nconst obj = {\n  name: \"coderwhy\",//depend实例对象\n  age: 18//depend实例对象\n}\n\nconst info = {\n  name:\"小余\",\n  age:18\n}\n//响应式开关媒介\nconst objRef = reactive({\n  name: \"coderwhy\",\n  age: 18\n})\nconst infoRef = reactive({\n  name:\"小余\",\n  age:18\n})\n\nwatchFn(() => {\n  console.log(infoRef.name);  \n})\nwatchFn(() => {\n  console.log(objRef.name);  \n})\n\ninfoRef.name = '响应式-小余'\nobjRef.name = '响应式-coderwhy'\n\n// 小余\n// coderwhy\n// Set(1) { [Function (anonymous)] }\n// 响应式-小余\n// Set(1) { [Function (anonymous)] }\n// 响应式-coderwhy\n```\n\n## 手撕instanceof\n\n```sql\nconst myInstanceOf=(Left,Right)=>{\n  if(!Left){\n    return false\n  }\n  while(Left){\n    if(Left.__proto__===Right.prototype){\n      return true\n    }else{\n      Left=Left.__proto__\n    }\n  }\n  return false\n}\n\n//验证\nconsole.log(myInstanceOf({},Array));  //false\n```\n\n## call，bind，apply\n\n```javascript\nfunction foo(x,y){\n  console.log(this.a,x+y);\n}\n\nconst obj={\n  a:1\n}\n\nFunction.prototype.myCall=function(context,...args){\n  if(typeof this !== 'function')  return new TypeError('is not a function')\n  const fn = Symbol('fn') //使用Symbol尽可能降低myCall对其他的影响\n  context[fn] = this  //this指向foo\n  const res = context[fn](...args)  //解构，调用fn\n  delete context[fn]  //不要忘了删除obj上的工具函数fn\n  return res  //将结果返回\n}\n\n//验证\nfoo.myCall(obj,1,2)   //1,3\n\nfunction foo(x,y){\n  console.log(this.a,x+y);\n}\n\nconst obj={\n  a:1\n}\n\nFunction.prototype.myApply=function(context,args){\n  if(typeof this !== 'function')  return new TypeError('is not a function')\n  const fn = Symbol('fn') //使用Symbol尽可能降低myCall对其他的影响\n  context[fn] = this  //this指向foo\n  const res = context[fn](...args)  //解构，调用fn\n  delete context[fn]  //不要忘了删除obj上的工具函数fn\n  return res  //将结果返回\n}\n\n//验证\nfoo.myApply(obj,1,2)   //1,3\n\nfunction foo(x,y,z){\n  this.name='zt'\n  console.log(this.a,x+y+z);\n}\n\nconst obj={\n  a:1\n}\n\nFunction.prototype.myBind=function(context,...args){\n  if(typeof this !== 'function')  return new TypeError('It is not a function');\n  context = context || window; // 上下文环境\n  const _this = this; // 当前的函数的上下文this\n  return function F(...arg) {\n    //判断返回出去的F有没有被new，有就要把foo给到new出来的对象\n    if (this instanceof F) {\n       return new _this(...args, ...arg);\n    } else {\n       _this.call(this, ...args, ...arg);\n    }\n  }\n}\n\n//验证\nconst bar=foo.myBind(obj,1,2)\nconsole.log(new bar(3));   //undefined 6  foo { name: 'zt' }\n```\n\n## 值相等\n\n```javascript\nfunction compare(data1, data2) {\n  if (typeof data1 != typeof data2) {\n    return false;\n  }\n\n  if (typeof data1 != \"object\" && typeof data1 == typeof data2) {\n    return data1 === data2;\n  }\n\n  if ((!data1 instanceof Array && data2 instanceof Array) || (data1 instanceof Array && !data2 instanceof Array)) {\n    return false;\n  } else if (data1 instanceof Array  && data2 instanceof Array) {\n    if (data1.length == data2.length) {\n      for (let i = 0; i < data1.length; i++) {\n        if (!compare(data1[i], data2[i])) {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n  } else {\n      if (Object.keys(data1).length == Object.keys(data2).length) {\n      for (let key in data1) {\n        if (!data2[key] || !compare(data1[key], data2[key])) {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\n```\n\n## 深拷贝\n\n```javascript\nfunction isObject(value) {\n  const valueType = typeof value\n  return (value !== null) && (valueType === \"object\" || valueType === \"function\")\n}\n\nfunction deepClone(originValue) {\n  // 判断传入的originValue是否是一个对象类型\n  if (!isObject(originValue)) {\n    return originValue\n  }\n\n  const newObject = {}\n  for (const key in originValue) {\n    newObject[key] = deepClone(originValue[key])\n  }\n  //返回通过递归深层遍历赋值后，全新的数据对象\n  return newObject\n}\n```\n\n## 实现Object.create()\n\n创建一个空对象，定义其原型对象并设置其枚举属性\n\n```javascript\n// proto 可以是object 或者function\nObject.myCreate = function (proto, defineProperties){\n    if((typeof proto === 'object' && proto !== null) || typeof proto === 'function'){\n        let obj = {};\n\n        // obj.__proto__ = proto;\n        Object.setPrototypeOf(obj, proto);\n        Object.defineProperty(obj, defineProperties);\n        return obj;\n    }else {\n        throw new TypeError('类型错误');\n    }\n}\n```\n\n## 实现Object.assign（浅拷贝）\n\n```javascript\nfunction myAssign(target,...objs){\n    if(target === null || target === undefined){\n        throw new TypeError(\"can not convert null or undefined to object\")\n    }\n    let res = Object(target)\n    objs.forEach(obj => {\n        'use strict'\n        if(obj != null && obj != undefined){\n            for(let key in obj){\n                //hasOwnProperty用来判断一个属性是定义在对象本身而不是继承自原型链的\n                if(Object.prototype.hasOwnProperty.call(obj,key)){\n                    res[key] = obj[key]\n                }\n            }\n        }\n    })\n    return res\n}\nObject.defineProperty(Object,'myAssign',{\n    value: myAssign,\n    writable: true,\n    configurable: true,\n    enumerable: false\n})\n```\n\n## trim方法\n\n```javascript\nfunction myTrim(str) {\n  const reg = /^\\s+|\\s+$/g;\n  return str.replace(reg, '');\n}\n```\n\n## 模板字符串\n\n```javascript\nconst render = (template, data) => {\n    const reg = /\\$\\{(.*?)\\}/g;\n    template = template.replace(reg, (match, key) => {\n        let keys = key.trim().split('.');\n        return keys.reduce((obj, k) => obj?.[k], data) || '';\n    })\n    return template;\n}\n```\n\n## sleep函数\n\n```javascript\nfunction sleep(ms) {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            console.log('sleep...')\n            resolve()\n        }, ms);\n    })\n}\n\nasync function test(){\n    console.log('1');\n    await sleep(400)\n    console.log('2')\n}\n\ntest();\n```\n\n## 利用setTimeout实现setInterval\n\n```javascript\nfunction coustomSetInterval(callback, time) {\n    let intervalId = null;\n    function loop() {\n        intervalId = setTimeout(() => {\n            callback();\n            loop();\n        }, time)\n    }\n    loop();\n    return () => clearTimeout(intervalId)\n}\nconst interval = coustomSetInterval(() => {\n    console.log('想你了')\n}, 1000)\n\nsetTimeout(() => {\n    interval()\n}, 5000)\n```\n\n# 🚀 Promise 源码实现完全指南 - 从零手写 Promise\n\n> 🎯 **阅读本节你将收获**：\n>\n> - 深入理解 Promise 内部运行机制\n> - 手写一个符合 Promise/A+ 规范的 Promise\n> - 掌握面试中 Promise 相关的核心考点\n> - 理解 async/await 的实现原理\n\n## 📌 开篇：为什么要手写 Promise？\n\n在面试中，Promise 相关的题目可以说是必考题。但很多同学只会用，不知道其内部原理。今天我们就一起来揭开 Promise 的神秘面纱，手写一个完整的 Promise！\n\n## 一、Promise 基础架构 - 搭建地基 🏗️\n\n### 1.1 最简单的 Promise 结构\n\n我们先从最简单的结构开始，就像盖房子要先打地基：\n\n```javascript\nclass MyPromise {\n    constructor(executor) {\n        // executor 是使用者传入的函数，形如 (resolve, reject) => {}\n        \n        // 定义 resolve 函数\n        const resolve = (value) => {\n            console.log('调用了 resolve，值为：', value);\n        }\n        \n        // 定义 reject 函数\n        const reject = (reason) => {\n            console.log('调用了 reject，原因为：', reason);\n        }\n        \n        // 立即执行 executor\n        executor(resolve, reject);\n    }\n}\n\n// 测试一下\nnew MyPromise((resolve, reject) => {\n    resolve('成功啦！');\n});\n```\n\n### 1.2 Promise 的三种状态 - 状态机 🚦\n\nPromise 就像一个有三种状态的交通灯：\n\n- 🟡 **pending**（等待态）：初始状态，既不是成功，也不是失败\n- 🟢 **fulfilled**（成功态）：操作成功完成\n- 🔴 **rejected**（失败态）：操作失败\n\n**重要特性**：\n\n1. 状态只能从 `pending` → `fulfilled` 或 `pending` → `rejected`\n2. 状态一旦改变，就永远不会再变（这就是为什么叫 \"Promise\" - 承诺）\n\n让我们加上状态管理：\n\n```javascript\nclass MyPromise {\n    constructor(executor) {\n        // 初始状态为 pending\n        this.status = 'pending';\n        // 成功的值\n        this.value = undefined;\n        // 失败的原因\n        this.reason = undefined;\n        \n        // resolve 函数：将状态从 pending 改为 fulfilled\n        const resolve = (value) => {\n            // 只有在 pending 状态才能改变状态（保证状态只改变一次）\n            if (this.status === 'pending') {\n                this.status = 'fulfilled';\n                this.value = value;\n            }\n        }\n        \n        // reject 函数：将状态从 pending 改为 rejected\n        const reject = (reason) => {\n            if (this.status === 'pending') {\n                this.status = 'rejected';\n                this.reason = reason;\n            }\n        }\n        \n        // 立即执行 executor，并传入 resolve 和 reject\n        try {\n            executor(resolve, reject);\n        } catch (error) {\n            // 如果执行器抛出异常，Promise 应该被拒绝\n            reject(error);\n        }\n    }\n}\n```\n\n## 二、实现 then 方法 - Promise 的灵魂 ✨\n\n### 2.1 then 方法的基本实现\n\n`then` 方法是 Promise 的核心，它用来注册当 Promise 状态改变时的回调函数。\n\n```javascript\nclass MyPromise {\n    // ... 前面的代码\n\n    then(onFulfilled, onRejected) {\n        // 如果状态是 fulfilled，执行成功回调\n        if (this.status === 'fulfilled') {\n            onFulfilled(this.value);\n        }\n        \n        // 如果状态是 rejected，执行失败回调\n        if (this.status === 'rejected') {\n            onRejected(this.reason);\n        }\n    }\n}\n\n// 测试同步情况\nconst promise = new MyPromise((resolve, reject) => {\n    resolve('成功！');\n});\n\npromise.then(\n    value => console.log('成功:', value),\n    reason => console.log('失败:', reason)\n);\n```\n\n### 2.2 处理异步情况 - 发布订阅模式 📢\n\n上面的代码有个问题：如果 executor 中有异步操作怎么办？\n\n```javascript\nconst promise = new MyPromise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('异步成功！');\n    }, 1000);\n});\n\n// 此时状态还是 pending，then 方法不会执行任何回调！\npromise.then(value => console.log(value));\n```\n\n解决方案：使用**发布订阅模式**，先把回调存起来，等状态改变时再执行：\n\n```javascript\nclass MyPromise {\n    constructor(executor) {\n        this.status = 'pending';\n        this.value = undefined;\n        this.reason = undefined;\n        \n        // 存储成功回调的数组\n        this.onFulfilledCallbacks = [];\n        // 存储失败回调的数组\n        this.onRejectedCallbacks = [];\n        \n        const resolve = (value) => {\n            if (this.status === 'pending') {\n                this.status = 'fulfilled';\n                this.value = value;\n                // 状态改变时，执行所有的成功回调\n                this.onFulfilledCallbacks.forEach(fn => fn());\n            }\n        }\n        \n        const reject = (reason) => {\n            if (this.status === 'pending') {\n                this.status = 'rejected';\n                this.reason = reason;\n                // 状态改变时，执行所有的失败回调\n                this.onRejectedCallbacks.forEach(fn => fn());\n            }\n        }\n        \n        try {\n            executor(resolve, reject);\n        } catch (error) {\n            reject(error);\n        }\n    }\n    \n    then(onFulfilled, onRejected) {\n        if (this.status === 'fulfilled') {\n            onFulfilled(this.value);\n        }\n        \n        if (this.status === 'rejected') {\n            onRejected(this.reason);\n        }\n        \n        // 如果是 pending 状态，将回调存储起来\n        if (this.status === 'pending') {\n            this.onFulfilledCallbacks.push(() => {\n                onFulfilled(this.value);\n            });\n            this.onRejectedCallbacks.push(() => {\n                onRejected(this.reason);\n            });\n        }\n    }\n}\n```\n\n### 2.3 链式调用的实现 - then 返回 Promise 🔗\n\nPromise 最强大的特性之一就是链式调用。要实现链式调用，`then` 方法必须返回一个新的 Promise：\n\n```javascript\nthen(onFulfilled, onRejected) {\n    // then 方法返回一个新的 Promise\n    return new MyPromise((resolve, reject) => {\n        // 封装一个执行函数，统一处理成功和失败的情况\n        const fulfilledMicrotask = () => {\n            // 使用 queueMicrotask 创建微任务，保证异步执行\n            queueMicrotask(() => {\n                try {\n                    const x = onFulfilled(this.value);\n                    // 处理返回值（详见下一节）\n                    resolvePromise(promise2, x, resolve, reject);\n                } catch (error) {\n                    reject(error);\n                }\n            });\n        };\n        \n        const rejectedMicrotask = () => {\n            queueMicrotask(() => {\n                try {\n                    const x = onRejected(this.reason);\n                    resolvePromise(promise2, x, resolve, reject);\n                } catch (error) {\n                    reject(error);\n                }\n            });\n        };\n        \n        if (this.status === 'fulfilled') {\n            fulfilledMicrotask();\n        } else if (this.status === 'rejected') {\n            rejectedMicrotask();\n        } else if (this.status === 'pending') {\n            this.onFulfilledCallbacks.push(fulfilledMicrotask);\n            this.onRejectedCallbacks.push(rejectedMicrotask);\n        }\n    });\n}\n```\n\n### 2.4 处理 then 的返回值 - resolvePromise 🎯\n\n这是实现 Promise 最复杂的部分，需要处理各种情况：\n\n```javascript\nfunction resolvePromise(promise2, x, resolve, reject) {\n    // 如果 x === promise2，会造成循环引用\n    if (x === promise2) {\n        return reject(new TypeError('Chaining cycle detected'));\n    }\n    \n    // 如果 x 是 Promise 实例\n    if (x instanceof MyPromise) {\n        // 等待 x 的状态改变，然后递归处理\n        x.then(\n            value => resolvePromise(promise2, value, resolve, reject),\n            reason => reject(reason)\n        );\n        return;\n    }\n    \n    // 如果 x 是对象或函数（可能是 thenable）\n    if (x !== null && (typeof x === 'object' || typeof x === 'function')) {\n        let then;\n        try {\n            then = x.then;\n        } catch (error) {\n            return reject(error);\n        }\n        \n        // 如果 then 是函数，认为 x 是 thenable\n        if (typeof then === 'function') {\n            let called = false; // 防止多次调用\n            try {\n                then.call(\n                    x,\n                    value => {\n                        if (called) return;\n                        called = true;\n                        resolvePromise(promise2, value, resolve, reject);\n                    },\n                    reason => {\n                        if (called) return;\n                        called = true;\n                        reject(reason);\n                    }\n                );\n            } catch (error) {\n                if (called) return;\n                reject(error);\n            }\n        } else {\n            // 如果 then 不是函数，直接 resolve\n            resolve(x);\n        }\n    } else {\n        // 如果 x 是普通值，直接 resolve\n        resolve(x);\n    }\n}\n```\n\n## 三、实现 Promise 的静态方法 🛠️\n\n### 3.1 Promise.resolve 和 Promise.reject\n\n```javascript\nclass MyPromise {\n    // 快速创建一个成功的 Promise\n    static resolve(value) {\n        // 如果 value 已经是 Promise，直接返回\n        if (value instanceof MyPromise) {\n            return value;\n        }\n        \n        return new MyPromise(resolve => resolve(value));\n    }\n    \n    // 快速创建一个失败的 Promise\n    static reject(reason) {\n        return new MyPromise((resolve, reject) => reject(reason));\n    }\n}\n```\n\n### 3.2 Promise.all - 一个都不能少 🎯\n\n`Promise.all` 接收一个 Promise 数组，只有全部成功才成功，有一个失败就失败：\n\n```javascript\nstatic all(promises) {\n    return new MyPromise((resolve, reject) => {\n        const results = [];\n        let completedCount = 0;\n        \n        // 处理空数组的情况\n        if (promises.length === 0) {\n            resolve(results);\n            return;\n        }\n        \n        promises.forEach((promise, index) => {\n            // 将非 Promise 值转换为 Promise\n            MyPromise.resolve(promise).then(\n                value => {\n                    results[index] = value;\n                    completedCount++;\n                    \n                    // 所有 Promise 都成功了\n                    if (completedCount === promises.length) {\n                        resolve(results);\n                    }\n                },\n                reason => {\n                    // 有一个失败就直接 reject\n                    reject(reason);\n                }\n            );\n        });\n    });\n}\n```\n\n### 3.3 Promise.race - 谁快用谁 🏃\n\n```javascript\nstatic race(promises) {\n    return new MyPromise((resolve, reject) => {\n        // 空数组永远 pending\n        if (promises.length === 0) return;\n        \n        promises.forEach(promise => {\n            // 谁先完成就用谁的结果\n            MyPromise.resolve(promise).then(resolve, reject);\n        });\n    });\n}\n```\n\n### 3.4 Promise.allSettled - 等待所有结果 📊\n\n不管成功还是失败，等所有 Promise 都有结果：\n\n```javascript\nstatic allSettled(promises) {\n    return new MyPromise((resolve) => {\n        const results = [];\n        let settledCount = 0;\n        \n        if (promises.length === 0) {\n            resolve(results);\n            return;\n        }\n        \n        promises.forEach((promise, index) => {\n            MyPromise.resolve(promise).then(\n                value => {\n                    results[index] = { status: 'fulfilled', value };\n                    settledCount++;\n                    if (settledCount === promises.length) {\n                        resolve(results);\n                    }\n                },\n                reason => {\n                    results[index] = { status: 'rejected', reason };\n                    settledCount++;\n                    if (settledCount === promises.length) {\n                        resolve(results);\n                    }\n                }\n            );\n        });\n    });\n}\n```\n\n### 3.5 Promise.any - 一个成功就够了 ✅\n\n```javascript\nstatic any(promises) {\n    return new MyPromise((resolve, reject) => {\n        const errors = [];\n        let rejectedCount = 0;\n        \n        if (promises.length === 0) {\n            reject(new AggregateError([], 'All promises were rejected'));\n            return;\n        }\n        \n        promises.forEach((promise, index) => {\n            MyPromise.resolve(promise).then(\n                value => {\n                    // 有一个成功就 resolve\n                    resolve(value);\n                },\n                reason => {\n                    errors[index] = reason;\n                    rejectedCount++;\n                    \n                    // 全部失败才 reject\n                    if (rejectedCount === promises.length) {\n                        reject(new AggregateError(errors, 'All promises were rejected'));\n                    }\n                }\n            );\n        });\n    });\n}\n```\n\n## 四、实现 catch 和 finally 🎣\n\n### 4.1 catch - 错误处理\n\n```javascript\ncatch(onRejected) {\n    // catch 就是 then 的语法糖\n    return this.then(null, onRejected);\n}\n```\n\n### 4.2 finally - 无论如何都要执行\n\n```javascript\nfinally(callback) {\n    return this.then(\n        // 成功时执行 callback，但传递原来的值\n        value => MyPromise.resolve(callback()).then(() => value),\n        // 失败时执行 callback，但传递原来的错误\n        reason => MyPromise.resolve(callback()).then(() => { throw reason })\n    );\n}\n```\n\n## 五、async/await 的实现原理 🔮\n\n### 5.1 理解 async/await\n\n`async/await` 本质上是 Generator + Promise 的语法糖。让我们看看它是如何工作的：\n\n```javascript\n// async 函数\nasync function fetchData() {\n    const user = await getUser();\n    const posts = await getPosts(user.id);\n    return posts;\n}\n\n// 等价于\nfunction fetchData() {\n    return spawn(function* () {\n        const user = yield getUser();\n        const posts = yield getPosts(user.id);\n        return posts;\n    });\n}\n```\n\n### 5.2 实现自动执行器\n\n```javascript\nfunction spawn(genFunc) {\n    return new Promise((resolve, reject) => {\n        const gen = genFunc();\n        \n        function step(nextFunc) {\n            let next;\n            try {\n                next = nextFunc();\n            } catch (error) {\n                return reject(error);\n            }\n            \n            // Generator 函数执行完毕\n            if (next.done) {\n                return resolve(next.value);\n            }\n            \n            // 将 yield 的值包装成 Promise，然后递归执行\n            Promise.resolve(next.value).then(\n                value => step(() => gen.next(value)),\n                error => step(() => gen.throw(error))\n            );\n        }\n        \n        // 开始执行\n        step(() => gen.next());\n    });\n}\n```\n\n### 5.3 一个更简单的实现\n\n```javascript\nfunction asyncToGenerator(generatorFunc) {\n    return function (...args) {\n        const gen = generatorFunc.apply(this, args);\n        \n        return new Promise((resolve, reject) => {\n            function step(key, arg) {\n                let generatorResult;\n                \n                try {\n                    generatorResult = gen[key](arg);\n                } catch (error) {\n                    return reject(error);\n                }\n                \n                const { value, done } = generatorResult;\n                \n                if (done) {\n                    return resolve(value);\n                } else {\n                    return Promise.resolve(value).then(\n                        val => step('next', val),\n                        err => step('throw', err)\n                    );\n                }\n            }\n            \n            step('next');\n        });\n    };\n}\n\n// 使用示例\nconst getData = asyncToGenerator(function* () {\n    const data1 = yield fetch('/api/1');\n    const data2 = yield fetch('/api/2');\n    return [data1, data2];\n});\n\ngetData().then(result => console.log(result));\n```\n\n## 🎯 面试高频考点总结\n\n1. **Promise 的状态机制**：三种状态，只能单向改变，一旦改变不可逆\n2. **then 的链式调用**：then 返回新的 Promise，根据回调函数的返回值决定新 Promise 的状态\n3. **微任务队列**：Promise 的回调在微任务队列中执行\n4. **错误处理**：catch 能捕获前面所有 then 中的错误\n5. **Promise.all vs Promise.race**：一个要全部成功，一个要最快完成\n6. **async/await 原理**：Generator + 自动执行器 + Promise\n\n# 模板渲染引擎\n\n```xml\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>模板渲染示例</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n\n    <script src=\"script.js\"></script>\n</body>\n</html>\n// 渲染引擎\nfunction renderTemplate(template, data) {\n\n    // 处理条件判断\n    template = template.replace(/{{\\s*#if\\s*(\\w+)\\s*}}([\\s\\S]*?){{\\s*\\/if\\s*}}/g, function (_, condition, content) {\n        return data[condition] ? content : '';\n    });\n\n    // 处理循环\n    template = template.replace(/{{\\s*#each\\s*(\\w+)\\s*}}([\\s\\S]*?){{\\s*\\/each\\s*}}/g, function (_, arrayKey, content) {\n        let result = '';\n        let array = data[arrayKey];\n        if (Array.isArray(array)) {\n            array.forEach((item, index) => {\n                // 创建一个独立作用域，避免冲突\n                let temp = content;\n                // 替换模板内的 {{ this }} 为循环项\n                temp = temp.replace(/{{\\s*this\\s*}}/g, function () {\n                    return item;\n                });\n                // 如果是对象，处理它的属性\n                temp = temp.replace(/{{\\s*this\\.(\\w+)\\s*}}/g, function (_, prop) {\n                    return item[prop] || '';\n                });\n                // 替换循环索引（如果需要）\n                temp = temp.replace(/{{\\s*index\\s*}}/g, index);\n                // 将处理后的结果添加到最终结果中\n                result += temp;\n            });\n        }\n        return result;\n    });\n    // 替换变量，一定要放到最后！！\n    template = template.replace(/\\{\\{(.*?)\\}\\}/g, (match, key) => {\n        let keys = key.trim().split('.');\n        return keys.reduce((obj, k) => obj?.[k], data) || '';\n    })\n\n    return template;\n}\n\n// 定义数据\nconst data = {\n    name: \"张三\",\n    age: 25,\n    isEmployed: true,\n    occupation: \"工程师\",\n    hobbies: [\"阅读\", \"编程\", \"旅游\"],\n    friends: [\n        { name: \"李四\", age: 26 },\n        { name: \"王五\", age: 24 }\n    ]\n};\n\n// 定义模板\nconst template = `\n    <h1>个人信息</h1>\n    <p>姓名: {{ name }}</p>\n    <p>年龄: {{ age }}</p>\n    <p>职业: {{ occupation }}</p>\n\n    {{#if isEmployed}}\n        <p>当前状态: 在职</p>\n    {{/if}}\n\n    <h2>兴趣爱好</h2>\n    <ul>\n        {{#each hobbies}}\n            <li>{{ this }}</li>\n        {{/each}}\n    </ul>\n\n    <h2>朋友列表</h2>\n    <ul>\n        {{#each friends}}\n            <li>{{ this.name }} - {{ this.age }} 岁</li>\n        {{/each}}\n    </ul>\n`;\n\n// 渲染模板并插入 HTML\ndocument.getElementById('app').innerHTML = renderTemplate(template, data);\n```\n\n# 防抖截流\n\n```JavaScript\nconst debounce = (fn, ms, Immediate = false) => {\n    // Immediate选择是否立即执行\n    let timer = null;\n    return function (...thisArgs) {\n        if (timer) {\n            clearTimeout(timer)\n        }\n        if (Immediate) {\n            let flag = !timer\n            flag && fn.apply(this, thisArgs)\n            timer = setTimeout(() => {\n                timer = null\n            }, ms)\n        } else {\n            timer = setTimeout(() => {\n                fn.apply(this, thisArgs)\n                timer = null\n            }, ms)\n        }\n    }\n}\n\nconst throttle = (fn, ms) => {\n    let timer = null;\n    return function (...thisArgs) {\n        if (!timer) {\n            fn.apply(this, thisArgs);\n            timer = setTimeout(() => {\n                timer = null;\n            }, ms);\n        }\n    }\n}\n```\n\n# 技巧\n\n## 数组去重\n\n```javascript\nlet arr = [1, 0, 2, 3, 4, 5, 2, 3, 4];\n//indexOf去重\nfunction removeRepeat(arr) {\n  let res = [];\n  for (let i of arr) {\n    if (res.indexOf(i) == -1) {\n      res.push(i);\n    }\n  }\n  return res;\n}\n// set 去重\nfunction removeRepeat(arr) {\n  let res = new Set(arr);\n  return Array.from(res);\n}\n// for循环去重\nfunction removeRepeat(arr) {\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] == arr[j]) {\n        arr.splice(j, 1);\n        j--;\n      }\n    }\n  }\n  return arr;\n}\n// filter 去重\nfunction removeRepeat(arr) {\n  return arr.filter((item, index) => {\n    return arr.indexOf(item) == index;\n  });\n}\n// includes 去重\nfunction removeRepeat(arr) {\n  let res = [];\n  for (let i of arr) {\n    if (!res.includes(i)) {\n      res.push(i);\n    }\n  }\n  return res;\n}\nlet res = removeRepeat(arr);\nconsole.log(res);\n```\n\n## 快排和归并\n\n```javascript\nArray.prototype.quicksort = function (l, r) {\n    if (l >= r) return this;\n    let key = this[l];\n    let i = l - 1, j = r + 1;\n    while (i < j) {\n        do i++; while (this[i] < key);\n        do j--; while (this[j] > key);\n        if (i < j) [this[i], this[j]] = [this[j], this[i]];\n    }\n    this.quicksort(l, j);\n    this.quicksort(j + 1, r);\n    return this;\n}\nlet arr = [5,8,3,6,4,2];\nconsole.log(arr.quicksort(0, arr.length-1));\n\n\nArray.prototype.mergesort = function (temp, l, r) {\n    if (l >= r) return this;\n    let mid = l + r >> 1;\n    this.mergesort(temp, l, mid);\n    this.mergesort(temp, mid + 1, r);\n\n    let i = l, j = mid + 1, k = 0;\n    while (i <= mid && j <= r) {\n        if (this[i] <= this[j]) temp[k++] = this[i++];\n        else temp[k++] = this[j++];\n    }\n    while (i <= mid) temp[k++] = this[i++];\n    while (j <= r) temp[k++] = this[j++];\n\n    for (let m = 0, n = l; n <= r; m++, n++) {\n        this[n] = temp[m];\n    }\n    return this;\n}\n\nlet arr = [7, 1, 0, 3, 0, 5, 6, 4];\nconsole.log(arr.mergesort(Array(arr.length).fill(0), 0, arr.length - 1));\n```\n\n## 下划线和驼峰相互转换\n\n```javascript\n//方式一：操作字符串数组\nfunction transformStr2Hump1(str) {\n    if(str == null) {\n        return \"\";\n    }\n    var strArr = str.split('-');\n    for(var i = 1; i < strArr.length; i++) {\n        strArr[i] = strArr[i].charAt(0).toUpperCase() + strArr[i].substring(1);\n    }\n    return strArr.join('');\n}\n\n//方式二：操作字符数组\nfunction transformStr2Hump2(str) {\n    if(str == null) {\n        return \"\";\n    }\n    var strArr  =str.split('');\n    for(var i = 0; i < strArr.length; i++) {\n        if(strArr[i] == \"-\"){\n            //删除-\n            strArr.splice(i, 1);\n            //将该处改为大写\n            if(i < strArr.length) {\n                strArr[i] = strArr[i].toUpperCase();\n            }\n        }\n    }\n    return strArr.join(\"\");\n}\n\n//方式三：利用正则\nfunction transformStr2Hump3(str) {\n    if(str == null) {\n        return \"\";\n    }\n    var reg = /-(\\w)/g;//匹配字母或数字或下划线或汉字\n    return str.replace(reg, function($0, $1) {\n        return $1.toUpperCase();\n    })\n}\n```\n\n## 懒加载\n\n- 首先，不要将图片地址放到src属性中，而是放到其它属性(data-original)中。\n- 页面加载完成后，根据scrollTop判断图片是否在用户的视野内，如果在，则将data-original属性中的值取出存放到src属性中。\n- 在滚动事件中重复判断图片是否进入视野，如果进入，则将data-original属性中的值取出存放到src属性中。\n\n>  elementNode.getAttribute(name)：方法通过名称获取属性的值。\n>\n>  elementNode.setAttribute(name, value)：方法创建或改变某个新属性。\n>\n>  elementNode.removeAttribute(name)：方法通过名称删除属性的值。\n\n```javascript\n//懒加载代码实现\nvar viewHeight = document.documentElement.clientHeight;//可视化区域的高度\n\nfunction lazyload () {\n    //获取所有要进行懒加载的图片\n    let eles = document.querySelectorAll('img[data-original][lazyload]');//获取属性名中有data-original的\n    Array.prototype.forEach.call(eles, function(item, index) {\n        let rect;\n        if(item.dataset.original === '') {\n            return;\n        }\n\n        rect = item.getBoundingClientRect();\n\n        //图片一进入可视区，动态加载\n        if(rect.bottom >= 0 && rect.top < viewHeight) {\n            !function () {\n                let img = new Image();\n                img.src = item.dataset.original;\n                img.onload = function () {\n                    item.src = img.src;\n                }\n                item.removeAttribute('data-original');\n                item.removeAttribute('lazyload');\n            }();\n        }\n    })\n}\n\nlazyload();\n\ndocument.addEventListener('scroll', lazyload);\n```\n\n## 数组扁平化\n\n```javascript\n//传入参数 决定扁平化的阶数\nArray.prototype._flat = function (n) {\n    let result = [];\n    let num = n;\n    for (let item of this) {\n        // 如果是数组\n        if (Array.isArray(item)) {\n            n--;\n            //   没有扁平化的空间 直接推入\n            if (n < 0) {\n                result.push(item);\n            }\n            // 继续扁平化 并将n传入 决定item这一个数组中的扁平化\n            else {\n                result.push(...item._flat(n));\n            }\n        }\n        // 不是数组直接推入\n        else {\n            result.push(item);\n        }\n        // 每次循环 重置n 为传入的参数 因为每一项都需要扁平化 需要进行判断\n        n = num;\n    }\n    return result;\n};\nlet arr = [1, 2, [3, 4], [5, 6, [7, 8]]];\nlet res = arr._flat(1);\nconsole.log(res); // [ 1, 2, 3, 4, 5, 6, [ 7, 8 ] ]\n```\n\n## 计算属性\n\n请不要为所有函数添加缓存！\n\n```javascript\nconst computed = (func, content) => {\n    let cache = Object.create(null);\n    content = content || this;\n    return (...key) => {\n        console.log(cache)\n        if (!cache[key]) {\n            cache[key] = func.apply(content, key);\n        }\n        return cache[key];\n    }\n}\n```\n\n## 有并发限制的Promise调度器\n\n```JavaScript\nclass Scheduler{\n    constructor(limit){\n        this.limit = limit;\n        this.running = 0;\n        this.queue = [];\n    }\n    createTask(callback, duration){\n        return ()=>{\n            return new Promise((resolve, reject)=>{\n                setTimeout(()=>{\n                    callback();\n                    resolve();\n                },duration);\n            });\n        };\n    }\n    \n    add(callback, duration){\n        const task = this.createTask(callback, duration);\n        this.queue.push(task);\n    }\n    \n    start(){\n        for(let i=0;i<this.limit;++i){\n            this.schedule();\n        }\n    }\n    schedule(){\n        if(this.queue.length === 0 || this.running >= this.limit)return;\n        this.running++;\n        const task = this.queue.shift();\n        \n        task().then(()=>{\n            this.running--;\n            schedule();\n        });\n    }\n}\n```\n\n# 网络请求和跨域解决方案\n\n## 原生ajax\n\n```javascript\nfunction sendajax() {\n    // 1、 初始化xhr对象\n    const xhr = new XMLHttpRequest();\n    //  2、 建立连接 设置请求方法和url\n    xhr.open(\"get\", \"./data.json\");\n    //   3、发送请求\n    xhr.send();\n    //   4、状态改变时 进行回调\n    xhr.onreadystatechange = function () {\n        // readyState 有0-4 五个值\n        // 0 代表 未初始化 1 代表 初始化成功 2 代表发送请求\n        // 3 代表返回了部分数据 4 代表返回了全部数据\n        if (xhr.readyState == 4) {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                //   进行成功的操作\n                console.log(xhr.responseText);\n            }\n        }\n    };\n}\nsendajax();\n```\n\n## JSONP跨域\n\n首先在客户端注册一个callback，然后把callback的名字传给服务器。此时，服务器先生成json数据，然后以JavaScript的语法方式，生成function，function的名字就是传递上来带参数的jsonp，最后将json数据直接以入参的方式，放置在function中，这样子就生成JavaScript语法文档，返回给客户端。客户端浏览器，通过解析，并执行返回JavaScript文档，此时数据作为参数，传入到客户端预先定义好的callback函数中，简单地说，就是**利用script标签没有跨域限制地漏洞来达到第三方通讯的目的（href、src 都不受同源策略的限制。）**\n\n**优点：**\n\n- 它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制，JSONP可以跨越同源策略；\n- 它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；\n\n**缺点:**\n\n- 它**只支持GET请求**而不支持POST等其它类型的HTTP请求\n- 它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。\n- jsonp在调用失败的时候不会返回各种HTTP状态码。\n- 需要后端配合\n\n```javascript\n        function jsonp({url,params,cb}){\n                return new Promise((resolve, reject)=>{\n                        window[cb] = function(data){\n                                console.log(data)\n                                resolve(data);\n                                document.body.removeChild(script);\n                        }//window对象上设置show方法\n                        params= {...params,cb}\n                        let arrs = [];\n                        for (let key in params){\n                                arrs.push(`${key}=${params[key]}`)\n                        }\n                        let script = document.createElement('script');\n                        script.src = `${url}?${arrs.join('&')}`;\n                        script.onerror = () => reject('加载失败') \n                        document.body.appendChild(script);\n                \n\n                })\n        }\n        jsonp({\n                url:\"http://localhost:3000/users\",\n                params:{name:\"jin\",age:12},\n                cb:'show'\n        }).then(data=>{\n                console.log(data)\n        })\n```\n\n后端：\n\n```javascript\nlet express = require('express');\nlet app = express();\napp.get('/users', function(req, res, next) {\n        // 模拟的数据\n        let {name,age,cb} = req.query\n        let data = `\"${name}现在${age}岁\"`\n        res.send(`${cb}(${data})`);// show(data)\n});\n\napp.listen(3000)\n```\n\n## cors跨域\n\n同源策略是不允许接收响应而不是不允许发送请求，所以可以通过在响应头中设置某些字段来允许满足条件的请求跨域，比如设置 `Access-Control-Allow-Origin` 字段允许来自某个源的请求跨域，比如设置 `Access-Control-Allow-Methods` 字段允许'GET'或者'POST'方式的请求跨域\n\n后端：\n\n```javascript\nlet express = require('express');\nlet app = express();\napp.all('*', function (req, res, next) {\n  let origin = req.headers.origin\n        //设置哪个源可以访问我\n  res.header(\"Access-Control-Allow-Origin\",origin);\n        // 允许携带哪个头访问我\n  res.header(\"Access-Control-Allow-Headers\", \"name\");\n        // 允许哪个方法访问我\n  res.header(\"Access-Control-Allow-Methods\", \"POST\");\n        // 允许携带cookie\n  res.set(\"Access-Control-Allow-Credentials\", true);\n        // 预检的存活时间\n  res.header(\"Access-Control-Max-Age\", 6);\n        // 允许前端获取哪个头\n        res.header(\"Access-Control-Expose-Headers\", \"name\");\n        // 请求头的格式\n  res.header(\"Content-Type\", \"application/json;charset=utf-8\");        \n  next();\n});\napp.post('/getData', function(req, res, next) {\n        console.log(req.headers)\n        res.send(\"你拿不到数据了！\");\n});\n\napp.listen(4000)\n```\n\n![img](https://k0x1mohrv2i.feishu.cn/space/api/box/stream/download/asynccode/?code=NDZkMzY0OGQyNDNmNjUxZDIwMjU1MWNlN2E0Mzg4MWFfa29GVk90bXpPWThOWlE3b2RzVFJJclhjRG45R01BaXFfVG9rZW46TlBKZGJkQlJ4b0F3V3h4NDRxWWNHNmxnbldjXzE3NTMxNjg3NjA6MTc1MzE3MjM2MF9WNA)\n\n非简单请求是那种对服务器有特殊要求的请求，比如请求方法是`PUT`或`DELETE`，或者`Content-Type`字段的类型是`application/json`。\n\n非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为\"预检\"请求（preflight）。\n\n浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。 代码修改一下：\n\n```javascript\n// 在请求头的设置中加上\nif(req.method ==='OPTIONS'){\n    res.end();//OPTIONS请求不做任何处理\n}\n```\n\n![img](https://k0x1mohrv2i.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGZhMjliNjM3ZDgyYTViMWZjYjdkZGJkOGMxZDE4YTBfclJZQzR4MzMwZmRpd3J4MEl3UWlqbVE3NEU2UDZwODFfVG9rZW46Qk53bWJ2T2dSb3BoZU14eXNFRmNZN1M0blNYXzE3NTMxNjg3NjA6MTc1MzE3MjM2MF9WNA)\n\n## postMessage跨域\n\n**「window.postMessage()」** 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 https），端口号（443 为 https 的默认值），以及主机 (两个页面的模数 [`Document.domain`]设置为相同的值) 时，这两个脚本才能相互通信。**「window.postMessage()」** 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。\n\n**用途**\n\n1.页面和其打开的新窗口的数据传递\n\n2.多窗口之间消息传递\n\n3.页面与嵌套的 iframe 消息传递\n\n**实现**\n\na.html\n\n```xml\n<iframe src=\"http://localhost:4000/b.html\" frameborder=\"0\" id=\"frame\" onload=\"load()\"></iframe>\n<script>\n    function load(){\n        let frame = document.getElementById('frame');\n        frame.contentWindow.postMessage('你好','http://localhost:4000/');\n        //接收\n        window.onmessage= function(e){\n            console.log(e.data)\n        }\n    }\n</script>\n```\n\nb.html\n\n```xml\nwindow.onmessage = function(e){\n    console.log(e.data);\n    //发送\n    e.source.postMessage('hello',e.origin)\n}\n```\n\n## 本地代理跨域\n\nproxy其实就是因为浏览器同源协议无法请求非同源的地址，但是服务器直接没有同源协议，利用将本地请求转到本地服务器进行代理转发，从而绕过了同源协议的限制，通过代理的实现可以解决跨域的问题\n\n通过设置一个 node 后端作为中间层，前端发送的请求首先到达这个中间层，然后再由中间层将请求转发到目标服务器。响应过程也是如此，服务器先响应给中间层，中间层再将响应数据发送回前端。\n\n这个中间层就起到了一个代理的作用。这样，浏览器看到的是同源请求，从而绕过了CORS限制。\n\n假设前端现在要将请求发送给 [http://192.168.1.63:3000](https://link.juejin.cn?target=http%3A%2F%2F192.168.1.63%3A3000) 这个后端，就可以先由本机的 3001 端口作一个代理\n\n```xml\n<!-- 前端 -->\n<body>\n    <script>\n        const xhr = new XMLHttpRequest()\n        xhr.open('GET', 'https://localhost:3001')\n        xhr.send()\n        xhr.onreadystatechange = function() {\n            if (xhr.readyState === 4 && xhr.status === 200) {\n                console.log(xhr.responseText)\n            }\n        }\n    </script>\n</body>\n```\n\n本机后端\n\n```javascript\n// 后端\nconst http = require('http')\n\n// 监听本机3001端口，有新请求时调用回调函数\nhttp.createServer((req, res)  => {\n\n    // 设置响应头，以允许前端应用访问响应内容\n    res.writeHead(200, {\n        'Access-Control-Allow-Origin': '*'\n    })\n\n    // 转发请求到目标服务器，并处理响应\n    http.request({\n        host: '192.168.1.63',\n        port: 3000,\n        path: '/',\n        method: 'GET',\n        headers: {}\n    }, proxyRes => {\n        proxyRes.on('data', chunk => {\n            res.end(chunk.toString())\n        })\n    }).end()\n    \n}).listen(3001)\n```\n\n### 各脚手架的proxy配置：\n\n#### Webpack (4.x)\n\n在`webpack`中可以配置`proxy`来快速获得接口代理的能力。\n\n```JavaScript\nconst path = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nmodule.exports = {\n  entry: {\n    index: \"./index.js\"\n  },\n  output: {\n    filename: \"bundle.js\",\n    path: path.resolve(__dirname, \"dist\")\n  },\n  devServer: {\n    port: 8000,\n    proxy: {\n      \"/api\": {\n        target: \"http://localhost:8080\"\n      }\n    }\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: \"index.html\",\n      template: \"webpack.html\"\n    })\n  ]\n};\n```\n\n#### **Vue-cli 2.x**\n\n```JavaScript\n// config/index.js\n\n...\nproxyTable: {\n  '/api': {\n     target: 'http://localhost:8080',\n  }\n},\n...\n```\n\n#### Vue-cli 3.x\n\n```JavaScript\n// vue.config.js 如果没有就新建\nmodule.exports = {\n  devServer: {\n    port: 8000,\n    proxy: {\n      \"/api\": {\n        target: \"http://localhost:8080\"\n      }\n    }\n  }\n};\n```\n\n#### vite\n\n```javascript\nimport { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\nimport styleImport, { VantResolve } from 'vite-plugin-style-import';\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [\n    vue(),\n    styleImport({\n      resolves: [VantResolve()],\n    }),],\n    server: { //主要是加上这段代码\n      host: '127.0.0.1',\n      port: 3000,\n      proxy: {\n        '/api': {\n          target: 'http://127.0.0.1:8888',        //实际请求地址\n          changeOrigin: true,\n          rewrite: (path) => path.replace(/^\\/api/, '')\n        },\n      }\n    }\n})\n```\n\n## nginx反向代理跨域\n\n反向代理与本地代理相反。本地代理是客户端搞定的，反向代理就是服务端搞定的\n\n反向代理的是在服务端内部完成。\n\n是服务端（数据应用）向服务端（网页应用）发送数据， 服务端向客户端发送数据 其本质是在服务端（网页应用）通过配置Access-Control-Allow-Origin * 来解决跨域问题。相当于对后端接口进行了统一的cors配置\n\n`Access-Control-Allow-Origin: *` 值表明，该资源可以被**任意**外源访问。\n\n```bash\n    #通过配置nginx文件既可\n    \n    events{}\n\nhttp{\n    include       mime.types;\n    default_type  application/octet-stream;\n    server{\n        listen 80;\n        server_name 127.0.0.1;\n        root D:/nginx-1.26.1/dist;\n        index index.html;\n        location / {\n   \n               location /api {\n                proxy_pass http://127.0.0.1:8080/;\n                proxy_set_header Host $host;\n                proxy_set_header X-Real-IP $remote_addr;\n                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n                proxy_set_header X-Forwarded-Proto $scheme;\n\n                # 解决跨域问题\n                add_header Access-Control-Allow-Origin *;\n                add_header Access-Control-Allow-Methods \"GET, POST, OPTIONS, HEAD, PUT, DELETE\";\n                add_header Access-Control-Allow-Headers \"Origin, X-Requested-With, Content-Type, Accept, Authorization, User-Agent, DNT\";\n                add_header Access-Control-Max-Age 86400;\n\n                \n            }\n        }\n    }\n}\n```\n\n# 设计模式\n\n## 单例模式\n\n```typescript\n// 单例模式示例代码\nclass Singleton {\n  constructor() {\n    if (!Singleton.instance) {\n      Singleton.instance = this;\n    }\n    return Singleton.instance;\n  }\n\n  createInstance() {\n    const object = { name: \"example\" };\n    return object;\n  }\n\n  getInstance() {\n    if (!Singleton.instance) {\n      Singleton.instance = this.createInstance();\n    }\n    return Singleton.instance;\n  }\n}\n\n// 使用示例\nconst instance1 = new Singleton();\nconst instance2 = new Singleton();\n\nconsole.log(instance1 === instance2); // true\n```\n\n## 工厂模式\n\n```javascript\nclass Product {\n  constructor(name) {\n    this.name = name;\n  }\n\n  getName() {\n    return this.name;\n  }\n}\n\nclass ProductFactory {\n  static createProduct(name) {\n    return new Product(name);\n  }\n}\n\n// 使用示例\nconst product = ProductFactory.createProduct(\"Example Product\");\nconsole.log(product.getName()); // \"Example Product\"\n```\n\n## 观察者模式\n\n```javascript\nclass Subject {\n  constructor() {\n    this.observers = [];\n  }\n\n  addObserver(observer) {\n    this.observers.push(observer);\n  }\n\n  removeObserver(observer) {\n    const index = this.observers.indexOf(observer);\n    if (index !== -1) {\n      this.observers.splice(index, 1);\n    }\n  }\n\n  notify(data) {\n    this.observers.forEach(observer => observer.update(data));\n  }\n}\n\nclass Observer {\n  update(data) {\n    console.log(`Received data: ${data}`);\n  }\n}\n\n// 使用示例\nconst subject = new Subject();\nconst observer1 = new Observer();\nconst observer2 = new Observer();\n\nsubject.addObserver(observer1);\nsubject.addObserver(observer2);\n\nsubject.notify(\"Hello World!\");\n```\n\n## 装饰器模式\n\n```java\ninterface Component {\n  operation(): void;\n}\n\nclass ConcreteComponent implements Component {\n  public operation(): void {\n    console.log(\"ConcreteComponent: operation.\");\n  }\n}\n\nclass Decorator implements Component {\n  protected component: Component;\n\n  constructor(component: Component) {\n    this.component = component;\n  }\n\n  public operation(): void {\n    console.log(\"Decorator: operation.\");\n    this.component.operation();\n  }\n}\n\nclass ConcreteDecoratorA extends Decorator {\n  public operation(): void {\n    super.operation();\n    console.log(\"ConcreteDecoratorA: operation.\");\n  }\n}\n\nclass ConcreteDecoratorB extends Decorator {\n  public operation(): void {\n    super.operation();\n    console.log(\"ConcreteDecoratorB: operation.\");\n  }\n}\n\n// 使用示例\nconst concreteComponent = new ConcreteComponent();\nconst concreteDecoratorA = new ConcreteDecoratorA(concreteComponent);\nconst concreteDecoratorB = new ConcreteDecoratorB(concreteDecoratorA);\n\nconcreteDecoratorB.operation();\n```\n\n## 代理模式\n\n```javascript\nconst target = {\n  method() {\n    console.log(\"Target method.\");\n  }\n};\n\nconst proxy = new Proxy(target, {\n  get(target, prop) {\n    console.log(`Called ${prop} method.`);\n    return target[prop];\n  }\n});\n\n// 使用示例\nproxy.method(); // \"Called method method. Target method.\"\n```\n\n## 适配器模式\n\n```javascript\nclass Adaptee {\n  specificRequest() {\n    return \"适配者中的业务代码被调用\";\n  }\n}\n\nclass Target {\n  constructor() {\n    this.adaptee = new Adaptee();\n  }\n\n  request() {\n    let info = this.adaptee.specificRequest();\n    return `${info} - 转换器 - 适配器代码被调用`;\n  }\n}\n\n// 使用示例\nlet target = new Target();\ntarget.request(); // \"适配者中的业务代码被调用 - 转换器 - 适配器代码被调用\"\n```\n\n## MVC模式\n\n```javascript\nclass Model {\n  constructor() {\n    this.data = {\n      name: \"example\",\n      age: 18,\n      gender: \"male\"\n    };\n  }\n\n  setData(key, value) {\n    this.data[key] = value;\n  }\n\n  getData() {\n    return this.data;\n  }\n}\n\nclass View {\n  constructor() {\n    this.container = document.createElement(\"div\");\n  }\n\n  render(data) {\n    const { name, age, gender } = data;\n    this.container.innerHTML = `\n      <p>Name: ${name}</p>\n      <p>Age: ${age}</p>\n      <p>Gender: ${gender}</p>\n    `;\n    document.body.appendChild(this.container);\n  }\n}\n\nclass Controller {\n  constructor(model, view) {\n    this.model = model;\n    this.view = view;\n    this.view.render(this.model.getData());\n  }\n\n  setData(key, value) {\n    this.model.setData(key, value);\n    this.view.render(this.model.getData());\n  }\n}\n\n// 使用示例\nconst model = new Model();\nconst view = new View();\nconst controller = new Controller(model, view);\n\ncontroller.setData(\"age\", 20);\n```\n\n## 策略模式\n\n表单验证情景：\n\n```ts\n// 验证策略\nconst validationStrategies = {\n  required: {\n    validate: (value) => value !== '',\n    message: '该字段不能为空'\n  },\n  \n  minLength: {\n    validate: (value, length) => value.length >= length,\n    message: (length) => `最少需要${length}个字符`\n  },\n  \n  email: {\n    validate: (value) => /^\\S+@\\S+\\.\\S+$/.test(value),\n    message: '请输入有效的邮箱地址'\n  },\n  \n  phone: {\n    validate: (value) => /^1[3-9]\\d{9}$/.test(value),\n    message: '请输入有效的手机号'\n  },\n  \n  custom: {\n    validate: (value, validator) => validator(value),\n    message: '自定义验证失败'\n  }\n};\n\n// 表单验证器\nclass FormValidator {\n  constructor() {\n    this.rules = [];\n  }\n  \n  // 添加验证规则\n  addRule(field, strategy, ...params) {\n    this.rules.push({\n      field,\n      strategy,\n      params\n    });\n  }\n  \n  // 执行验证\n  validate(formData) {\n    const errors = [];\n    \n    for (const rule of this.rules) {\n      const { field, strategy, params } = rule;\n      const value = formData[field];\n      const validationStrategy = validationStrategies[strategy];\n      \n      if (!validationStrategy.validate(value, ...params)) {\n        errors.push({\n          field,\n          message: typeof validationStrategy.message === 'function' \n            ? validationStrategy.message(...params)\n            : validationStrategy.message\n        });\n      }\n    }\n    \n    return {\n      isValid: errors.length === 0,\n      errors\n    };\n  }\n}\n\n// 使用示例\nconst validator = new FormValidator();\nvalidator.addRule('username', 'required');\nvalidator.addRule('username', 'minLength', 3);\nvalidator.addRule('email', 'required');\nvalidator.addRule('email', 'email');\nvalidator.addRule('phone', 'phone');\n\nconst formData = {\n  username: 'ab',\n  email: 'invalid-email',\n  phone: '12345678901'\n};\n\nconst result = validator.validate(formData);\nconsole.log(result);\n// {\n//   isValid: false,\n//   errors: [\n//     { field: 'username', message: '最少需要3个字符' },\n//     { field: 'email', message: '请输入有效的邮箱地址' },\n//     { field: 'phone', message: '请输入有效的手机号' }\n//   ]\n// }\n```\n\n","tags":["秋招","ES","面试题","前端手撕"],"categories":["秋招准备"]},{"title":"【秋招备战】计算机网络","url":"/2025/07/22/【秋招备战】计算机网络/","content":"\n# 前言\n\n计算机网络作为前端开发中绕不开的基础知识，面试时也特爱问，很多时候都有可能被打一个冷不防。这份文档旨在整理前端面试中高频出现的计算机网络知识点，希望能帮助到正在准备面试的你。\n\n内容基于个人面试经验和学习总结，如有不当之处，欢迎指正交流。  本文不追求面面俱到，而是聚焦于前端面试中的高频考点，力求每个知识点都讲透彻、讲实用。\n\n# 一、HTTP 协议篇\n\n## 1.1 HTTP 基础\n\n- HTTP 是什么？\n- HTTP 请求方法详解\n- HTTP 状态码分类及常见状态码\n- HTTP 报文结构\n  - \n\n## 1.2 HTTP 缓存机制\n\n- 强缓存 vs 协商缓存\n- Cache-Control 详解\n- ETag 和 Last-Modified\n- 缓存位置（Memory Cache、Disk Cache等）\n  - \n\n## 1.3 HTTP 版本演进\n\n- HTTP/1.0 vs HTTP/1.1\n- HTTP/2 的优势（多路复用、服务器推送等）\n- HTTP/3 和 QUIC 协议\n  - \n\n## 1.4 HTTPS 安全通信\n\n- HTTP vs HTTPS\n- HTTPS 加密原理\n- 证书验证过程\n- 中间人攻击\n  - \n\n# 二、TCP/IP 协议篇\n\n## 2.1 TCP 基础\n\n- TCP 三次握手详解\n- TCP 四次挥手详解\n- 为什么需要三次握手？两次行不行？\n- TIME_WAIT 状态的作用\n  - \n\n## 2.2 TCP 可靠传输\n\n- 序列号和确认应答\n- 超时重传机制\n- 流量控制（滑动窗口）\n- 拥塞控制\n  - \n\n## 2.3 TCP vs UDP\n\n- 两者的区别对比\n- 各自的应用场景\n- 为什么视频直播常用 UDP？\n  - \n\n# 三、浏览器网络篇\n\n## 3.1 跨域问题\n\n- 同源策略是什么？\n- 跨域的解决方案汇总\n- CORS 详解\n- JSONP 原理及限制\n- 其他跨域方案\n  - \n\n## 3.2 经典问题：从 URL 到页面展示\n\n- DNS 解析过程\n- 建立 TCP 连接\n- 发送 HTTP 请求\n- 服务器处理请求\n- 浏览器渲染页面\n  - \n\n## 3.3 WebSocket\n\n- WebSocket vs HTTP\n- WebSocket 连接过程\n- 应用场景\n  - \n\n# 四、Web 安全篇\n\n## 4.1 XSS 攻击\n\n- XSS 类型（反射型、存储型、DOM型）\n- XSS 防御策略\n- CSP 内容安全策略\n  - \n\n## 4.2 CSRF 攻击\n\n- CSRF 攻击原理\n- CSRF 防御方法\n- SameSite Cookie\n  - \n\n## 4.3 其他安全问题\n\n- SQL 注入\n- 点击劫持\n- 中间人攻击\n  - \n\n# 五、性能优化篇\n\n## 5.1 网络层优化\n\n- 减少 HTTP 请求数\n- 使用 HTTP/2\n- 启用 Gzip 压缩\n- 使用 CDN\n  - \n\n## 5.2 资源加载优化\n\n- 预加载（preload、prefetch）\n- 懒加载\n- 图片优化策略\n  - \n\n# 六、实战题目篇\n\n（收录各大公司真实面试题及详解）","tags":["秋招","计算机网络","面试八股文"],"categories":["秋招准备"]},{"title":"【建站日志】Simon成功搬家","url":"/2025/06/12/【建站日志】Simon已着陆/","content":"\n之前用Wordpress建的网站突然炸了T_T，只好搬家到Hexo这边来，虽然之前就想换成ssg静态网站就是了。毕竟Wordpress博客系统上传文章太便秘了，完全用不惯他的文本编辑器，还是MD大法好啊！\n","tags":["建站日志","生活记录"]}]