[{"title":"【概念解析】前端开发中的polypill","url":"/2025/07/22/【概念解析】前端开发中的Polyfill/","content":"\n\n\n## 什么是 Polyfill？\n\n**Polyfill** 是一段代码（通常是 JavaScript），用来为旧浏览器提供它没有原生支持的较新的功能。\n\n### 名字的由来 🎨\n\n\"Polyfill\" 这个词来源于一种建筑材料 Polyfilla（一种用于填补墙面裂缝的腻子），形象地表示\"填补浏览器功能的空缺\"。\n\n## 为什么需要 Polyfill？\n\n```javascript\n// 🌰 例子：旧浏览器不支持 Array.includes\nconst fruits = ['apple', 'banana', 'orange'];\n\n// 新浏览器可以直接使用\nconsole.log(fruits.includes('banana')); // true\n\n// 旧浏览器会报错：fruits.includes is not a function\n```\n\n## 常见的 Polyfill 示例\n\n### 1. Array.includes Polyfill\n\n```javascript\n// 检查是否已经存在\nif (!Array.prototype.includes) {\n  Array.prototype.includes = function(searchElement, fromIndex) {\n    // 严格模式\n    'use strict';\n    \n    const O = Object(this);\n    const len = parseInt(O.length) || 0;\n    \n    if (len === 0) return false;\n    \n    const n = parseInt(fromIndex) || 0;\n    let k = Math.max(n >= 0 ? n : len + n, 0);\n    \n    while (k < len) {\n      if (searchElement === O[k]) return true;\n      k++;\n    }\n    \n    return false;\n  };\n}\n```\n\n### 2. Promise Polyfill\n\n```javascript\n// 简化版 Promise polyfill\nif (typeof Promise === 'undefined') {\n  window.Promise = function(executor) {\n    // Promise 实现代码...\n  };\n}\n```\n\n### 3. Object.assign Polyfill\n\n```javascript\nif (!Object.assign) {\n  Object.assign = function(target) {\n    'use strict';\n    \n    if (target == null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n    \n    const output = Object(target);\n    \n    for (let index = 1; index < arguments.length; index++) {\n      const source = arguments[index];\n      if (source != null) {\n        for (const key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            output[key] = source[key];\n          }\n        }\n      }\n    }\n    \n    return output;\n  };\n}\n```\n\n### 4. String.padStart Polyfill\n\n```javascript\nif (!String.prototype.padStart) {\n  String.prototype.padStart = function(targetLength, padString) {\n    targetLength = targetLength >> 0; // 转为整数\n    padString = String(padString || ' ');\n    \n    if (this.length >= targetLength) {\n      return String(this);\n    }\n    \n    targetLength = targetLength - this.length;\n    if (targetLength > padString.length) {\n      padString += padString.repeat(targetLength / padString.length);\n    }\n    \n    return padString.slice(0, targetLength) + String(this);\n  };\n}\n```\n\n## Polyfill vs 其他概念\n\n### 1. Polyfill vs Transpile（转译）\n\n```javascript\n// Polyfill：运行时补充缺失的 API\nArray.prototype.find = Array.prototype.find || function() { /* ... */ };\n\n// Transpile：编译时转换语法（如 Babel）\n// ES6 箭头函数\nconst add = (a, b) => a + b;\n// 转译后\nvar add = function(a, b) { return a + b; };\n```\n\n### 2. Polyfill vs Shim\n\n- **Polyfill**：实现标准 API，行为与规范一致\n- **Shim**：可能有自己的 API，不一定遵循标准\n\n## 如何使用 Polyfill？\n\n### 1. 手动引入\n\n```html\n<!-- 引入特定的 polyfill -->\n<script src=\"https://polyfill.io/v3/polyfill.min.js?features=Promise,Array.from\"></script>\n```\n\n### 2. 使用 core-js\n\n```javascript\n// 安装\nnpm install core-js\n\n// 使用\nimport 'core-js/features/array/includes';\nimport 'core-js/features/promise';\n```\n\n### 3. 使用 @babel/polyfill（已废弃）\n\n```javascript\n// 新的推荐方式\nnpm install core-js regenerator-runtime\n\n// babel.config.js\nmodule.exports = {\n  presets: [\n    ['@babel/preset-env', {\n      useBuiltIns: 'usage',\n      corejs: 3\n    }]\n  ]\n};\n```\n\n## 最佳实践\n\n### 1. 按需加载\n\n```javascript\n// 只在需要时加载 polyfill\nif (!window.Promise) {\n  // 动态加载 Promise polyfill\n  loadScript('promise-polyfill.js');\n}\n```\n\n### 2. 使用 polyfill.io 服务\n\n```html\n<!-- 根据用户浏览器自动返回需要的 polyfill -->\n<script src=\"https://polyfill.io/v3/polyfill.min.js\"></script>\n```\n\n### 3. 特性检测\n\n```javascript\n// 使用特性检测而不是浏览器检测\nfunction loadPolyfills() {\n  const polyfills = [];\n  \n  if (!window.Promise) {\n    polyfills.push(import('promise-polyfill'));\n  }\n  \n  if (!Array.prototype.includes) {\n    polyfills.push(import('array-includes-polyfill'));\n  }\n  \n  return Promise.all(polyfills);\n}\n\n// 加载完 polyfill 后再启动应用\nloadPolyfills().then(() => {\n  // 启动应用\n  startApp();\n});\n```\n\n## 常用的 Polyfill 库\n\n1. **core-js** - 最全面的 polyfill 库\n2. **polyfill.io** - 自动化 polyfill 服务\n3. **es5-shim/es6-shim** - ES5/ES6 polyfill\n4. **fetch-polyfill** - Fetch API polyfill\n5. **intersection-observer** - IntersectionObserver polyfill\n\n## 注意事项 ⚠️\n\n1. **性能影响**：Polyfill 会增加代码体积\n2. **选择性加载**：只加载需要的 polyfill\n3. **版本兼容**：确保 polyfill 支持目标浏览器\n4. **原生优先**：优先使用原生实现\n\n```javascript\n// 好的做法：先检测再添加\nif (!Array.prototype.flat) {\n  // 添加 polyfill\n}\n\n// 避免：直接覆盖\nArray.prototype.flat = function() { /* ... */ };\n```\n\n总之，Polyfill 是前端开发中实现向后兼容的重要手段，让我们能够在旧浏览器中使用新特性！","tags":["前端开发","概念解析"],"categories":["前端知识小册"]},{"title":"【秋招准备】面试手撕大集合","url":"/2025/07/22/【秋招备战】面试手撕大集合/","content":"\n# **所有遍历数组的方法**\n\n\n\n## forEach\n\n```JavaScript\n// 自定义 forEach 函数，添加到 Array 原型链\nArray.prototype.myForEach = function (callback, thisArg) {\n\n    // 类型检查：确保 callback 是一个函数\n    if (typeof callback !== 'function') {\n        throw new TypeError('第一个参数必须是一个函数');\n    }\n\n    // 遍历数组，调用 callback 函数\n    for (let i = 0; i < this.length; i++) {\n        // 如果数组的当前元素是 undefined 或 null, 则跳过\n        if (i in this) {//对于数组而言，in运算符用于检查是否有这个索引值\n            callback.call(thisArg, this[i], i, this);\n        }\n    }\n};\n```\n\n## map\n\n```JavaScript\n// 自定义 Map 函数，添加到 Array 原型链\nArray.prototype.myMap = function (callback) {\n\n    // 类型检查：确保 callback 是一个函数\n    if (typeof callback !== 'function') {\n        throw new TypeError('第一个参数必须是一个函数');\n    }\n    let res = [];\n\n    // 遍历数组，调用 callback 函数\n    for (let i = 0; i < this.length; i++) {\n        // 如果数组的当前元素是 undefined 或 null, 则跳过\n        if (i in this) {\n            res.push(callback(this[i], i, this));\n        }\n    }\n    return res\n};\n```\n\n## Filter\n\n```JavaScript\nArray.prototype.my_filter = function (cb) {\n    let newArr = []\n    for (var i = 0; i < this.length; i++) {\n        if (cb(this[i], i, this)) {\n            newArr.push(this[i])\n        }\n    }\n    return newArr\n}\n```\n\n## every(判断数组中的每一个元素是否都满足某个条件)\n\n```JavaScript\nArray.prototype.my_every = function (cb) {\n    for (let i = 0; i < this.length; i++) {\n        if (!cb(this[i], i, this)) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n## some（判断数组中是否存在一个元素满足某个条件）\n\n```JavaScript\nArray.prototype.my_some = function (cb) {\n    for (let i = 0; i < this.length; i++) {\n        if (cb(this[i], i, this)) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n## reduce\n\n```JavaScript\nArray.prototype.my_reduce = function (cb, ...args) {\n    let start, index = 0\n    if (args.length) {\n        start = args[0]\n    } else {\n        start = this[0];\n        index = 1\n    }\n    for (let i = index; i < this.length; i++) {\n        start = cb(start, this[i], i, this);\n    }\n    return start;\n}\n```\n\n## includes\n\n```JavaScript\nArray.prototype.my_includes = function (item, ...args) {\n    let index\n    if (args.length && !Number.isNaN(Number(args[0])) && Number(args[0])>0) {\n        index = Number(args[0])\n    } else {\n        index = 0;\n    }\n    for (let i = index; i < this.length; i++) {\n        if (this[i] === item) return true;\n    }\n    return false\n}\n```\n\n## splice\n\n```JavaScript\nlet arr = ['a', 'b', 'c', 'd', 'e']\n\nArray.prototype.my_splice = function (start, len, ...args) {\n   // 如果没有任何参数传递，直接返回空数组\n    if (arguments.length === 0) {\n        return [];\n    }\n    \n    // 如果 start 是 undefined，设置为 0\n    if (start === undefined) {\n        start = 0;\n    }else if(start<0){\n        start = this.length+start \n        start = !!start?start:0\n    }\n\n    // 如果 len 是 undefined，设置为 0\n    if (len === undefined) {\n        len = 0;\n    }\n    \n    const res = [], newArr = []\n    for (let i = 0; i < this.length; i++) {\n        if (i < start || i >= start + len) {\n            newArr.push(this[i])\n        } else {\n            res.push(this[i])\n        }\n        //还有要添加的值是存放在args里的，所以我们还要把args中的值添加到原数组中去\n        if (i === start - 1) {\n            newArr.push(...args)\n        }\n    }\n    \n    while (this.length) {\n        this.pop()\n    }\n    this.push(...newArr)\n    return res\n}\n```\n\n# JS内置方法、对象以及运算符\n\n## new运算符\n\n```javascript\nfunction myNew (Func, ...arg){\n        if (fn.prototype === undefined) throw new TypeError('function is not a constructor');\n        let obj = {}  //定义了一个对象。\n        obj.__proto__ = Func.prototype  \n        //将Func.prototype赋值为对象的__proto__属性,即原型链的概念\n        let res = Func.call(obj, ...arg) //更改Func的this指向\n        return res instanceof Object ? res : obj \n}\n```\n\n## 手撕curry\n\n```javascript\nconst my_curry = (fn, ...args) =>\n    args.length >= fn.length\n        ? fn(...args)\n        : (...args1) => my_curry(fn, ...args, ...args1);\n\nfunction adder(x, y, z) {\n    return x + y + z;\n}\nconst add = my_curry(adder);\nconsole.log(add(1, 2, 3));  //6\nconsole.log(add(1)(2)(3));  //6\nconsole.log(add(1, 2)(3));  //6\nconsole.log(add(1)(2, 3));  //6\n```\n\n## 手写compose函数\n\n```JavaScript\nconst compose = (...fns)=>(x)=>fns.reduceRight((v, fn)=>fn(v),x);\nconst doubleAndSuare = compose(double, square);//先翻倍再平方\nconsole.log(doubleAndSuare(3));\n```\n\n## 手撕vue3响应式代理\n\n```javascript\n//测试代码\nclass Depend {\n  constructor() {\n    this.reactiveFns = new Set()//依赖组\n  }\n\n  // 更好的收集依赖\n  depend() {\n    if (activeReactiveFn) this.reactiveFns.add(activeReactiveFn)\n  }\n\n  //对所有依赖进行统一通知处理\n  notify() {\n    console.log(this.reactiveFns)\n    this.reactiveFns.forEach(fn => {\n      //遍历依赖处理\n      if (fn) fn()\n    })\n  }\n}\n\n// 封装响应式函数\nlet activeReactiveFn = null\nfunction watchFn(fn) {\n  activeReactiveFn = fn\n  fn()\n  activeReactiveFn = null\n}\n\n// 封装一个获取depend函数\nconst targetMap = new WeakMap()\nfunction getDepend(target, key) {\n  // 1、根据target对象获取map的过程\n  let map = targetMap.get(target)\n  if (!map) {\n    map = new Map()\n    targetMap.set(target, map)\n  }\n  // 2、根据对象属性获取depend依赖\n  let depend = map.get(key)\n  if (!depend) {\n    depend = new Depend()\n    map.set(key, depend)\n  }\n  return depend\n}\n\n\n//使用Proxy监听对象变化\nfunction reactive(obj) {\n  return new Proxy(obj, {\n    get: function (target, key, receiver) {\n      const depend = getDepend(target, key)\n      depend.depend()\n      return Reflect.get(target, key, receiver)\n    },\n    set: function (target, key, newValue, receiver) {\n      Reflect.set(target, key, newValue, receiver)\n      const depend = getDepend(target, key)\n      depend.notify()\n    }\n  })\n}\n\nconst obj = {\n  name: \"coderwhy\",//depend实例对象\n  age: 18//depend实例对象\n}\n\nconst info = {\n  name:\"小余\",\n  age:18\n}\n//响应式开关媒介\nconst objRef = reactive({\n  name: \"coderwhy\",\n  age: 18\n})\nconst infoRef = reactive({\n  name:\"小余\",\n  age:18\n})\n\nwatchFn(() => {\n  console.log(infoRef.name);  \n})\nwatchFn(() => {\n  console.log(objRef.name);  \n})\n\ninfoRef.name = '响应式-小余'\nobjRef.name = '响应式-coderwhy'\n\n// 小余\n// coderwhy\n// Set(1) { [Function (anonymous)] }\n// 响应式-小余\n// Set(1) { [Function (anonymous)] }\n// 响应式-coderwhy\n```\n\n## 手撕instanceof\n\n```sql\nconst myInstanceOf=(Left,Right)=>{\n  if(!Left){\n    return false\n  }\n  while(Left){\n    if(Left.__proto__===Right.prototype){\n      return true\n    }else{\n      Left=Left.__proto__\n    }\n  }\n  return false\n}\n\n//验证\nconsole.log(myInstanceOf({},Array));  //false\n```\n\n## call，bind，apply\n\n```javascript\nfunction foo(x,y){\n  console.log(this.a,x+y);\n}\n\nconst obj={\n  a:1\n}\n\nFunction.prototype.myCall=function(context,...args){\n  if(typeof this !== 'function')  return new TypeError('is not a function')\n  const fn = Symbol('fn') //使用Symbol尽可能降低myCall对其他的影响\n  context[fn] = this  //this指向foo\n  const res = context[fn](...args)  //解构，调用fn\n  delete context[fn]  //不要忘了删除obj上的工具函数fn\n  return res  //将结果返回\n}\n\n//验证\nfoo.myCall(obj,1,2)   //1,3\n\nfunction foo(x,y){\n  console.log(this.a,x+y);\n}\n\nconst obj={\n  a:1\n}\n\nFunction.prototype.myApply=function(context,args){\n  if(typeof this !== 'function')  return new TypeError('is not a function')\n  const fn = Symbol('fn') //使用Symbol尽可能降低myCall对其他的影响\n  context[fn] = this  //this指向foo\n  const res = context[fn](...args)  //解构，调用fn\n  delete context[fn]  //不要忘了删除obj上的工具函数fn\n  return res  //将结果返回\n}\n\n//验证\nfoo.myApply(obj,1,2)   //1,3\n\nfunction foo(x,y,z){\n  this.name='zt'\n  console.log(this.a,x+y+z);\n}\n\nconst obj={\n  a:1\n}\n\nFunction.prototype.myBind=function(context,...args){\n  if(typeof this !== 'function')  return new TypeError('It is not a function');\n  context = context || window; // 上下文环境\n  const _this = this; // 当前的函数的上下文this\n  return function F(...arg) {\n    //判断返回出去的F有没有被new，有就要把foo给到new出来的对象\n    if (this instanceof F) {\n       return new _this(...args, ...arg);\n    } else {\n       _this.call(this, ...args, ...arg);\n    }\n  }\n}\n\n//验证\nconst bar=foo.myBind(obj,1,2)\nconsole.log(new bar(3));   //undefined 6  foo { name: 'zt' }\n```\n\n## 值相等\n\n```javascript\nfunction compare(data1, data2) {\n  if (typeof data1 != typeof data2) {\n    return false;\n  }\n\n  if (typeof data1 != \"object\" && typeof data1 == typeof data2) {\n    return data1 === data2;\n  }\n\n  if ((!data1 instanceof Array && data2 instanceof Array) || (data1 instanceof Array && !data2 instanceof Array)) {\n    return false;\n  } else if (data1 instanceof Array  && data2 instanceof Array) {\n    if (data1.length == data2.length) {\n      for (let i = 0; i < data1.length; i++) {\n        if (!compare(data1[i], data2[i])) {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n  } else {\n      if (Object.keys(data1).length == Object.keys(data2).length) {\n      for (let key in data1) {\n        if (!data2[key] || !compare(data1[key], data2[key])) {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\n```\n\n## 深拷贝\n\n```javascript\nfunction isObject(value) {\n  const valueType = typeof value\n  return (value !== null) && (valueType === \"object\" || valueType === \"function\")\n}\n\nfunction deepClone(originValue) {\n  // 判断传入的originValue是否是一个对象类型\n  if (!isObject(originValue)) {\n    return originValue\n  }\n\n  const newObject = {}\n  for (const key in originValue) {\n    newObject[key] = deepClone(originValue[key])\n  }\n  //返回通过递归深层遍历赋值后，全新的数据对象\n  return newObject\n}\n```\n\n## 实现Object.create()\n\n创建一个空对象，定义其原型对象并设置其枚举属性\n\n```javascript\n// proto 可以是object 或者function\nObject.myCreate = function (proto, defineProperties){\n    if((typeof proto === 'object' && proto !== null) || typeof proto === 'function'){\n        let obj = {};\n\n        // obj.__proto__ = proto;\n        Object.setPrototypeOf(obj, proto);\n        Object.defineProperty(obj, defineProperties);\n        return obj;\n    }else {\n        throw new TypeError('类型错误');\n    }\n}\n```\n\n## 实现Object.assign（浅拷贝）\n\n```javascript\nfunction myAssign(target,...objs){\n    if(target === null || target === undefined){\n        throw new TypeError(\"can not convert null or undefined to object\")\n    }\n    let res = Object(target)\n    objs.forEach(obj => {\n        'use strict'\n        if(obj != null && obj != undefined){\n            for(let key in obj){\n                //hasOwnProperty用来判断一个属性是定义在对象本身而不是继承自原型链的\n                if(Object.prototype.hasOwnProperty.call(obj,key)){\n                    res[key] = obj[key]\n                }\n            }\n        }\n    })\n    return res\n}\nObject.defineProperty(Object,'myAssign',{\n    value: myAssign,\n    writable: true,\n    configurable: true,\n    enumerable: false\n})\n```\n\n## trim方法\n\n```javascript\nfunction myTrim(str) {\n  const reg = /^\\s+|\\s+$/g;\n  return str.replace(reg, '');\n}\n```\n\n## 模板字符串\n\n```javascript\nconst render = (template, data) => {\n    const reg = /\\$\\{(.*?)\\}/g;\n    template = template.replace(reg, (match, key) => {\n        let keys = key.trim().split('.');\n        return keys.reduce((obj, k) => obj?.[k], data) || '';\n    })\n    return template;\n}\n```\n\n## sleep函数\n\n```javascript\nfunction sleep(ms) {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            console.log('sleep...')\n            resolve()\n        }, ms);\n    })\n}\n\nasync function test(){\n    console.log('1');\n    await sleep(400)\n    console.log('2')\n}\n\ntest();\n```\n\n## 利用setTimeout实现setInterval\n\n```javascript\nfunction coustomSetInterval(callback, time) {\n    let intervalId = null;\n    function loop() {\n        intervalId = setTimeout(() => {\n            callback();\n            loop();\n        }, time)\n    }\n    loop();\n    return () => clearTimeout(intervalId)\n}\nconst interval = coustomSetInterval(() => {\n    console.log('想你了')\n}, 1000)\n\nsetTimeout(() => {\n    interval()\n}, 5000)\n```\n\n# 🚀 Promise 源码实现完全指南 - 从零手写 Promise\n\n> 🎯 **阅读本节你将收获**：\n>\n> - 深入理解 Promise 内部运行机制\n> - 手写一个符合 Promise/A+ 规范的 Promise\n> - 掌握面试中 Promise 相关的核心考点\n> - 理解 async/await 的实现原理\n\n## 📌 开篇：为什么要手写 Promise？\n\n在面试中，Promise 相关的题目可以说是必考题。但很多同学只会用，不知道其内部原理。今天我们就一起来揭开 Promise 的神秘面纱，手写一个完整的 Promise！\n\n## 一、Promise 基础架构 - 搭建地基 🏗️\n\n### 1.1 最简单的 Promise 结构\n\n我们先从最简单的结构开始，就像盖房子要先打地基：\n\n```javascript\nclass MyPromise {\n    constructor(executor) {\n        // executor 是使用者传入的函数，形如 (resolve, reject) => {}\n        \n        // 定义 resolve 函数\n        const resolve = (value) => {\n            console.log('调用了 resolve，值为：', value);\n        }\n        \n        // 定义 reject 函数\n        const reject = (reason) => {\n            console.log('调用了 reject，原因为：', reason);\n        }\n        \n        // 立即执行 executor\n        executor(resolve, reject);\n    }\n}\n\n// 测试一下\nnew MyPromise((resolve, reject) => {\n    resolve('成功啦！');\n});\n```\n\n### 1.2 Promise 的三种状态 - 状态机 🚦\n\nPromise 就像一个有三种状态的交通灯：\n\n- 🟡 **pending**（等待态）：初始状态，既不是成功，也不是失败\n- 🟢 **fulfilled**（成功态）：操作成功完成\n- 🔴 **rejected**（失败态）：操作失败\n\n**重要特性**：\n\n1. 状态只能从 `pending` → `fulfilled` 或 `pending` → `rejected`\n2. 状态一旦改变，就永远不会再变（这就是为什么叫 \"Promise\" - 承诺）\n\n让我们加上状态管理：\n\n```javascript\nclass MyPromise {\n    constructor(executor) {\n        // 初始状态为 pending\n        this.status = 'pending';\n        // 成功的值\n        this.value = undefined;\n        // 失败的原因\n        this.reason = undefined;\n        \n        // resolve 函数：将状态从 pending 改为 fulfilled\n        const resolve = (value) => {\n            // 只有在 pending 状态才能改变状态（保证状态只改变一次）\n            if (this.status === 'pending') {\n                this.status = 'fulfilled';\n                this.value = value;\n            }\n        }\n        \n        // reject 函数：将状态从 pending 改为 rejected\n        const reject = (reason) => {\n            if (this.status === 'pending') {\n                this.status = 'rejected';\n                this.reason = reason;\n            }\n        }\n        \n        // 立即执行 executor，并传入 resolve 和 reject\n        try {\n            executor(resolve, reject);\n        } catch (error) {\n            // 如果执行器抛出异常，Promise 应该被拒绝\n            reject(error);\n        }\n    }\n}\n```\n\n## 二、实现 then 方法 - Promise 的灵魂 ✨\n\n### 2.1 then 方法的基本实现\n\n`then` 方法是 Promise 的核心，它用来注册当 Promise 状态改变时的回调函数。\n\n```javascript\nclass MyPromise {\n    // ... 前面的代码\n\n    then(onFulfilled, onRejected) {\n        // 如果状态是 fulfilled，执行成功回调\n        if (this.status === 'fulfilled') {\n            onFulfilled(this.value);\n        }\n        \n        // 如果状态是 rejected，执行失败回调\n        if (this.status === 'rejected') {\n            onRejected(this.reason);\n        }\n    }\n}\n\n// 测试同步情况\nconst promise = new MyPromise((resolve, reject) => {\n    resolve('成功！');\n});\n\npromise.then(\n    value => console.log('成功:', value),\n    reason => console.log('失败:', reason)\n);\n```\n\n### 2.2 处理异步情况 - 发布订阅模式 📢\n\n上面的代码有个问题：如果 executor 中有异步操作怎么办？\n\n```javascript\nconst promise = new MyPromise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('异步成功！');\n    }, 1000);\n});\n\n// 此时状态还是 pending，then 方法不会执行任何回调！\npromise.then(value => console.log(value));\n```\n\n解决方案：使用**发布订阅模式**，先把回调存起来，等状态改变时再执行：\n\n```javascript\nclass MyPromise {\n    constructor(executor) {\n        this.status = 'pending';\n        this.value = undefined;\n        this.reason = undefined;\n        \n        // 存储成功回调的数组\n        this.onFulfilledCallbacks = [];\n        // 存储失败回调的数组\n        this.onRejectedCallbacks = [];\n        \n        const resolve = (value) => {\n            if (this.status === 'pending') {\n                this.status = 'fulfilled';\n                this.value = value;\n                // 状态改变时，执行所有的成功回调\n                this.onFulfilledCallbacks.forEach(fn => fn());\n            }\n        }\n        \n        const reject = (reason) => {\n            if (this.status === 'pending') {\n                this.status = 'rejected';\n                this.reason = reason;\n                // 状态改变时，执行所有的失败回调\n                this.onRejectedCallbacks.forEach(fn => fn());\n            }\n        }\n        \n        try {\n            executor(resolve, reject);\n        } catch (error) {\n            reject(error);\n        }\n    }\n    \n    then(onFulfilled, onRejected) {\n        if (this.status === 'fulfilled') {\n            onFulfilled(this.value);\n        }\n        \n        if (this.status === 'rejected') {\n            onRejected(this.reason);\n        }\n        \n        // 如果是 pending 状态，将回调存储起来\n        if (this.status === 'pending') {\n            this.onFulfilledCallbacks.push(() => {\n                onFulfilled(this.value);\n            });\n            this.onRejectedCallbacks.push(() => {\n                onRejected(this.reason);\n            });\n        }\n    }\n}\n```\n\n### 2.3 链式调用的实现 - then 返回 Promise 🔗\n\nPromise 最强大的特性之一就是链式调用。要实现链式调用，`then` 方法必须返回一个新的 Promise：\n\n```javascript\nthen(onFulfilled, onRejected) {\n    // then 方法返回一个新的 Promise\n    return new MyPromise((resolve, reject) => {\n        // 封装一个执行函数，统一处理成功和失败的情况\n        const fulfilledMicrotask = () => {\n            // 使用 queueMicrotask 创建微任务，保证异步执行\n            queueMicrotask(() => {\n                try {\n                    const x = onFulfilled(this.value);\n                    // 处理返回值（详见下一节）\n                    resolvePromise(promise2, x, resolve, reject);\n                } catch (error) {\n                    reject(error);\n                }\n            });\n        };\n        \n        const rejectedMicrotask = () => {\n            queueMicrotask(() => {\n                try {\n                    const x = onRejected(this.reason);\n                    resolvePromise(promise2, x, resolve, reject);\n                } catch (error) {\n                    reject(error);\n                }\n            });\n        };\n        \n        if (this.status === 'fulfilled') {\n            fulfilledMicrotask();\n        } else if (this.status === 'rejected') {\n            rejectedMicrotask();\n        } else if (this.status === 'pending') {\n            this.onFulfilledCallbacks.push(fulfilledMicrotask);\n            this.onRejectedCallbacks.push(rejectedMicrotask);\n        }\n    });\n}\n```\n\n### 2.4 处理 then 的返回值 - resolvePromise 🎯\n\n这是实现 Promise 最复杂的部分，需要处理各种情况：\n\n```javascript\nfunction resolvePromise(promise2, x, resolve, reject) {\n    // 如果 x === promise2，会造成循环引用\n    if (x === promise2) {\n        return reject(new TypeError('Chaining cycle detected'));\n    }\n    \n    // 如果 x 是 Promise 实例\n    if (x instanceof MyPromise) {\n        // 等待 x 的状态改变，然后递归处理\n        x.then(\n            value => resolvePromise(promise2, value, resolve, reject),\n            reason => reject(reason)\n        );\n        return;\n    }\n    \n    // 如果 x 是对象或函数（可能是 thenable）\n    if (x !== null && (typeof x === 'object' || typeof x === 'function')) {\n        let then;\n        try {\n            then = x.then;\n        } catch (error) {\n            return reject(error);\n        }\n        \n        // 如果 then 是函数，认为 x 是 thenable\n        if (typeof then === 'function') {\n            let called = false; // 防止多次调用\n            try {\n                then.call(\n                    x,\n                    value => {\n                        if (called) return;\n                        called = true;\n                        resolvePromise(promise2, value, resolve, reject);\n                    },\n                    reason => {\n                        if (called) return;\n                        called = true;\n                        reject(reason);\n                    }\n                );\n            } catch (error) {\n                if (called) return;\n                reject(error);\n            }\n        } else {\n            // 如果 then 不是函数，直接 resolve\n            resolve(x);\n        }\n    } else {\n        // 如果 x 是普通值，直接 resolve\n        resolve(x);\n    }\n}\n```\n\n## 三、实现 Promise 的静态方法 🛠️\n\n### 3.1 Promise.resolve 和 Promise.reject\n\n```javascript\nclass MyPromise {\n    // 快速创建一个成功的 Promise\n    static resolve(value) {\n        // 如果 value 已经是 Promise，直接返回\n        if (value instanceof MyPromise) {\n            return value;\n        }\n        \n        return new MyPromise(resolve => resolve(value));\n    }\n    \n    // 快速创建一个失败的 Promise\n    static reject(reason) {\n        return new MyPromise((resolve, reject) => reject(reason));\n    }\n}\n```\n\n### 3.2 Promise.all - 一个都不能少 🎯\n\n`Promise.all` 接收一个 Promise 数组，只有全部成功才成功，有一个失败就失败：\n\n```javascript\nstatic all(promises) {\n    return new MyPromise((resolve, reject) => {\n        const results = [];\n        let completedCount = 0;\n        \n        // 处理空数组的情况\n        if (promises.length === 0) {\n            resolve(results);\n            return;\n        }\n        \n        promises.forEach((promise, index) => {\n            // 将非 Promise 值转换为 Promise\n            MyPromise.resolve(promise).then(\n                value => {\n                    results[index] = value;\n                    completedCount++;\n                    \n                    // 所有 Promise 都成功了\n                    if (completedCount === promises.length) {\n                        resolve(results);\n                    }\n                },\n                reason => {\n                    // 有一个失败就直接 reject\n                    reject(reason);\n                }\n            );\n        });\n    });\n}\n```\n\n### 3.3 Promise.race - 谁快用谁 🏃\n\n```javascript\nstatic race(promises) {\n    return new MyPromise((resolve, reject) => {\n        // 空数组永远 pending\n        if (promises.length === 0) return;\n        \n        promises.forEach(promise => {\n            // 谁先完成就用谁的结果\n            MyPromise.resolve(promise).then(resolve, reject);\n        });\n    });\n}\n```\n\n### 3.4 Promise.allSettled - 等待所有结果 📊\n\n不管成功还是失败，等所有 Promise 都有结果：\n\n```javascript\nstatic allSettled(promises) {\n    return new MyPromise((resolve) => {\n        const results = [];\n        let settledCount = 0;\n        \n        if (promises.length === 0) {\n            resolve(results);\n            return;\n        }\n        \n        promises.forEach((promise, index) => {\n            MyPromise.resolve(promise).then(\n                value => {\n                    results[index] = { status: 'fulfilled', value };\n                    settledCount++;\n                    if (settledCount === promises.length) {\n                        resolve(results);\n                    }\n                },\n                reason => {\n                    results[index] = { status: 'rejected', reason };\n                    settledCount++;\n                    if (settledCount === promises.length) {\n                        resolve(results);\n                    }\n                }\n            );\n        });\n    });\n}\n```\n\n### 3.5 Promise.any - 一个成功就够了 ✅\n\n```javascript\nstatic any(promises) {\n    return new MyPromise((resolve, reject) => {\n        const errors = [];\n        let rejectedCount = 0;\n        \n        if (promises.length === 0) {\n            reject(new AggregateError([], 'All promises were rejected'));\n            return;\n        }\n        \n        promises.forEach((promise, index) => {\n            MyPromise.resolve(promise).then(\n                value => {\n                    // 有一个成功就 resolve\n                    resolve(value);\n                },\n                reason => {\n                    errors[index] = reason;\n                    rejectedCount++;\n                    \n                    // 全部失败才 reject\n                    if (rejectedCount === promises.length) {\n                        reject(new AggregateError(errors, 'All promises were rejected'));\n                    }\n                }\n            );\n        });\n    });\n}\n```\n\n## 四、实现 catch 和 finally 🎣\n\n### 4.1 catch - 错误处理\n\n```javascript\ncatch(onRejected) {\n    // catch 就是 then 的语法糖\n    return this.then(null, onRejected);\n}\n```\n\n### 4.2 finally - 无论如何都要执行\n\n```javascript\nfinally(callback) {\n    return this.then(\n        // 成功时执行 callback，但传递原来的值\n        value => MyPromise.resolve(callback()).then(() => value),\n        // 失败时执行 callback，但传递原来的错误\n        reason => MyPromise.resolve(callback()).then(() => { throw reason })\n    );\n}\n```\n\n## 五、async/await 的实现原理 🔮\n\n### 5.1 理解 async/await\n\n`async/await` 本质上是 Generator + Promise 的语法糖。让我们看看它是如何工作的：\n\n```javascript\n// async 函数\nasync function fetchData() {\n    const user = await getUser();\n    const posts = await getPosts(user.id);\n    return posts;\n}\n\n// 等价于\nfunction fetchData() {\n    return spawn(function* () {\n        const user = yield getUser();\n        const posts = yield getPosts(user.id);\n        return posts;\n    });\n}\n```\n\n### 5.2 实现自动执行器\n\n```javascript\nfunction spawn(genFunc) {\n    return new Promise((resolve, reject) => {\n        const gen = genFunc();\n        \n        function step(nextFunc) {\n            let next;\n            try {\n                next = nextFunc();\n            } catch (error) {\n                return reject(error);\n            }\n            \n            // Generator 函数执行完毕\n            if (next.done) {\n                return resolve(next.value);\n            }\n            \n            // 将 yield 的值包装成 Promise，然后递归执行\n            Promise.resolve(next.value).then(\n                value => step(() => gen.next(value)),\n                error => step(() => gen.throw(error))\n            );\n        }\n        \n        // 开始执行\n        step(() => gen.next());\n    });\n}\n```\n\n### 5.3 一个更简单的实现\n\n```javascript\nfunction asyncToGenerator(generatorFunc) {\n    return function (...args) {\n        const gen = generatorFunc.apply(this, args);\n        \n        return new Promise((resolve, reject) => {\n            function step(key, arg) {\n                let generatorResult;\n                \n                try {\n                    generatorResult = gen[key](arg);\n                } catch (error) {\n                    return reject(error);\n                }\n                \n                const { value, done } = generatorResult;\n                \n                if (done) {\n                    return resolve(value);\n                } else {\n                    return Promise.resolve(value).then(\n                        val => step('next', val),\n                        err => step('throw', err)\n                    );\n                }\n            }\n            \n            step('next');\n        });\n    };\n}\n\n// 使用示例\nconst getData = asyncToGenerator(function* () {\n    const data1 = yield fetch('/api/1');\n    const data2 = yield fetch('/api/2');\n    return [data1, data2];\n});\n\ngetData().then(result => console.log(result));\n```\n\n## 🎯 面试高频考点总结\n\n1. **Promise 的状态机制**：三种状态，只能单向改变，一旦改变不可逆\n2. **then 的链式调用**：then 返回新的 Promise，根据回调函数的返回值决定新 Promise 的状态\n3. **微任务队列**：Promise 的回调在微任务队列中执行\n4. **错误处理**：catch 能捕获前面所有 then 中的错误\n5. **Promise.all vs Promise.race**：一个要全部成功，一个要最快完成\n6. **async/await 原理**：Generator + 自动执行器 + Promise\n\n# 模板渲染引擎\n\n```xml\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>模板渲染示例</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n\n    <script src=\"script.js\"></script>\n</body>\n</html>\n// 渲染引擎\nfunction renderTemplate(template, data) {\n\n    // 处理条件判断\n    template = template.replace(/{{\\s*#if\\s*(\\w+)\\s*}}([\\s\\S]*?){{\\s*\\/if\\s*}}/g, function (_, condition, content) {\n        return data[condition] ? content : '';\n    });\n\n    // 处理循环\n    template = template.replace(/{{\\s*#each\\s*(\\w+)\\s*}}([\\s\\S]*?){{\\s*\\/each\\s*}}/g, function (_, arrayKey, content) {\n        let result = '';\n        let array = data[arrayKey];\n        if (Array.isArray(array)) {\n            array.forEach((item, index) => {\n                // 创建一个独立作用域，避免冲突\n                let temp = content;\n                // 替换模板内的 {{ this }} 为循环项\n                temp = temp.replace(/{{\\s*this\\s*}}/g, function () {\n                    return item;\n                });\n                // 如果是对象，处理它的属性\n                temp = temp.replace(/{{\\s*this\\.(\\w+)\\s*}}/g, function (_, prop) {\n                    return item[prop] || '';\n                });\n                // 替换循环索引（如果需要）\n                temp = temp.replace(/{{\\s*index\\s*}}/g, index);\n                // 将处理后的结果添加到最终结果中\n                result += temp;\n            });\n        }\n        return result;\n    });\n    // 替换变量，一定要放到最后！！\n    template = template.replace(/\\{\\{(.*?)\\}\\}/g, (match, key) => {\n        let keys = key.trim().split('.');\n        return keys.reduce((obj, k) => obj?.[k], data) || '';\n    })\n\n    return template;\n}\n\n// 定义数据\nconst data = {\n    name: \"张三\",\n    age: 25,\n    isEmployed: true,\n    occupation: \"工程师\",\n    hobbies: [\"阅读\", \"编程\", \"旅游\"],\n    friends: [\n        { name: \"李四\", age: 26 },\n        { name: \"王五\", age: 24 }\n    ]\n};\n\n// 定义模板\nconst template = `\n    <h1>个人信息</h1>\n    <p>姓名: {{ name }}</p>\n    <p>年龄: {{ age }}</p>\n    <p>职业: {{ occupation }}</p>\n\n    {{#if isEmployed}}\n        <p>当前状态: 在职</p>\n    {{/if}}\n\n    <h2>兴趣爱好</h2>\n    <ul>\n        {{#each hobbies}}\n            <li>{{ this }}</li>\n        {{/each}}\n    </ul>\n\n    <h2>朋友列表</h2>\n    <ul>\n        {{#each friends}}\n            <li>{{ this.name }} - {{ this.age }} 岁</li>\n        {{/each}}\n    </ul>\n`;\n\n// 渲染模板并插入 HTML\ndocument.getElementById('app').innerHTML = renderTemplate(template, data);\n```\n\n# 防抖截流\n\n```JavaScript\nconst debounce = (fn, ms, Immediate = false) => {\n    // Immediate选择是否立即执行\n    let timer = null;\n    return function (...thisArgs) {\n        if (timer) {\n            clearTimeout(timer)\n        }\n        if (Immediate) {\n            let flag = !timer\n            flag && fn.apply(this, thisArgs)\n            timer = setTimeout(() => {\n                timer = null\n            }, ms)\n        } else {\n            timer = setTimeout(() => {\n                fn.apply(this, thisArgs)\n                timer = null\n            }, ms)\n        }\n    }\n}\n\nconst throttle = (fn, ms) => {\n    let timer = null;\n    return function (...thisArgs) {\n        if (!timer) {\n            fn.apply(this, thisArgs);\n            timer = setTimeout(() => {\n                timer = null;\n            }, ms);\n        }\n    }\n}\n```\n\n# 技巧\n\n## 数组去重\n\n```javascript\nlet arr = [1, 0, 2, 3, 4, 5, 2, 3, 4];\n//indexOf去重\nfunction removeRepeat(arr) {\n  let res = [];\n  for (let i of arr) {\n    if (res.indexOf(i) == -1) {\n      res.push(i);\n    }\n  }\n  return res;\n}\n// set 去重\nfunction removeRepeat(arr) {\n  let res = new Set(arr);\n  return Array.from(res);\n}\n// for循环去重\nfunction removeRepeat(arr) {\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] == arr[j]) {\n        arr.splice(j, 1);\n        j--;\n      }\n    }\n  }\n  return arr;\n}\n// filter 去重\nfunction removeRepeat(arr) {\n  return arr.filter((item, index) => {\n    return arr.indexOf(item) == index;\n  });\n}\n// includes 去重\nfunction removeRepeat(arr) {\n  let res = [];\n  for (let i of arr) {\n    if (!res.includes(i)) {\n      res.push(i);\n    }\n  }\n  return res;\n}\nlet res = removeRepeat(arr);\nconsole.log(res);\n```\n\n## 快排和归并\n\n```javascript\nArray.prototype.quicksort = function (l, r) {\n    if (l >= r) return this;\n    let key = this[l];\n    let i = l - 1, j = r + 1;\n    while (i < j) {\n        do i++; while (this[i] < key);\n        do j--; while (this[j] > key);\n        if (i < j) [this[i], this[j]] = [this[j], this[i]];\n    }\n    this.quicksort(l, j);\n    this.quicksort(j + 1, r);\n    return this;\n}\nlet arr = [5,8,3,6,4,2];\nconsole.log(arr.quicksort(0, arr.length-1));\n\n\nArray.prototype.mergesort = function (temp, l, r) {\n    if (l >= r) return this;\n    let mid = l + r >> 1;\n    this.mergesort(temp, l, mid);\n    this.mergesort(temp, mid + 1, r);\n\n    let i = l, j = mid + 1, k = 0;\n    while (i <= mid && j <= r) {\n        if (this[i] <= this[j]) temp[k++] = this[i++];\n        else temp[k++] = this[j++];\n    }\n    while (i <= mid) temp[k++] = this[i++];\n    while (j <= r) temp[k++] = this[j++];\n\n    for (let m = 0, n = l; n <= r; m++, n++) {\n        this[n] = temp[m];\n    }\n    return this;\n}\n\nlet arr = [7, 1, 0, 3, 0, 5, 6, 4];\nconsole.log(arr.mergesort(Array(arr.length).fill(0), 0, arr.length - 1));\n```\n\n## 下划线和驼峰相互转换\n\n```javascript\n//方式一：操作字符串数组\nfunction transformStr2Hump1(str) {\n    if(str == null) {\n        return \"\";\n    }\n    var strArr = str.split('-');\n    for(var i = 1; i < strArr.length; i++) {\n        strArr[i] = strArr[i].charAt(0).toUpperCase() + strArr[i].substring(1);\n    }\n    return strArr.join('');\n}\n\n//方式二：操作字符数组\nfunction transformStr2Hump2(str) {\n    if(str == null) {\n        return \"\";\n    }\n    var strArr  =str.split('');\n    for(var i = 0; i < strArr.length; i++) {\n        if(strArr[i] == \"-\"){\n            //删除-\n            strArr.splice(i, 1);\n            //将该处改为大写\n            if(i < strArr.length) {\n                strArr[i] = strArr[i].toUpperCase();\n            }\n        }\n    }\n    return strArr.join(\"\");\n}\n\n//方式三：利用正则\nfunction transformStr2Hump3(str) {\n    if(str == null) {\n        return \"\";\n    }\n    var reg = /-(\\w)/g;//匹配字母或数字或下划线或汉字\n    return str.replace(reg, function($0, $1) {\n        return $1.toUpperCase();\n    })\n}\n```\n\n## 懒加载\n\n- 首先，不要将图片地址放到src属性中，而是放到其它属性(data-original)中。\n- 页面加载完成后，根据scrollTop判断图片是否在用户的视野内，如果在，则将data-original属性中的值取出存放到src属性中。\n- 在滚动事件中重复判断图片是否进入视野，如果进入，则将data-original属性中的值取出存放到src属性中。\n\n>  elementNode.getAttribute(name)：方法通过名称获取属性的值。\n>\n>  elementNode.setAttribute(name, value)：方法创建或改变某个新属性。\n>\n>  elementNode.removeAttribute(name)：方法通过名称删除属性的值。\n\n```javascript\n//懒加载代码实现\nvar viewHeight = document.documentElement.clientHeight;//可视化区域的高度\n\nfunction lazyload () {\n    //获取所有要进行懒加载的图片\n    let eles = document.querySelectorAll('img[data-original][lazyload]');//获取属性名中有data-original的\n    Array.prototype.forEach.call(eles, function(item, index) {\n        let rect;\n        if(item.dataset.original === '') {\n            return;\n        }\n\n        rect = item.getBoundingClientRect();\n\n        //图片一进入可视区，动态加载\n        if(rect.bottom >= 0 && rect.top < viewHeight) {\n            !function () {\n                let img = new Image();\n                img.src = item.dataset.original;\n                img.onload = function () {\n                    item.src = img.src;\n                }\n                item.removeAttribute('data-original');\n                item.removeAttribute('lazyload');\n            }();\n        }\n    })\n}\n\nlazyload();\n\ndocument.addEventListener('scroll', lazyload);\n```\n\n## 数组扁平化\n\n```javascript\n//传入参数 决定扁平化的阶数\nArray.prototype._flat = function (n) {\n    let result = [];\n    let num = n;\n    for (let item of this) {\n        // 如果是数组\n        if (Array.isArray(item)) {\n            n--;\n            //   没有扁平化的空间 直接推入\n            if (n < 0) {\n                result.push(item);\n            }\n            // 继续扁平化 并将n传入 决定item这一个数组中的扁平化\n            else {\n                result.push(...item._flat(n));\n            }\n        }\n        // 不是数组直接推入\n        else {\n            result.push(item);\n        }\n        // 每次循环 重置n 为传入的参数 因为每一项都需要扁平化 需要进行判断\n        n = num;\n    }\n    return result;\n};\nlet arr = [1, 2, [3, 4], [5, 6, [7, 8]]];\nlet res = arr._flat(1);\nconsole.log(res); // [ 1, 2, 3, 4, 5, 6, [ 7, 8 ] ]\n```\n\n## 计算属性\n\n请不要为所有函数添加缓存！\n\n```javascript\nconst computed = (func, content) => {\n    let cache = Object.create(null);\n    content = content || this;\n    return (...key) => {\n        console.log(cache)\n        if (!cache[key]) {\n            cache[key] = func.apply(content, key);\n        }\n        return cache[key];\n    }\n}\n```\n\n## 有并发限制的Promise调度器\n\n```JavaScript\nclass Scheduler{\n    constructor(limit){\n        this.limit = limit;\n        this.running = 0;\n        this.queue = [];\n    }\n    createTask(callback, duration){\n        return ()=>{\n            return new Promise((resolve, reject)=>{\n                setTimeout(()=>{\n                    callback();\n                    resolve();\n                },duration);\n            });\n        };\n    }\n    \n    add(callback, duration){\n        const task = this.createTask(callback, duration);\n        this.queue.push(task);\n    }\n    \n    start(){\n        for(let i=0;i<this.limit;++i){\n            this.schedule();\n        }\n    }\n    schedule(){\n        if(this.queue.length === 0 || this.running >= this.limit)return;\n        this.running++;\n        const task = this.queue.shift();\n        \n        task().then(()=>{\n            this.running--;\n            schedule();\n        });\n    }\n}\n```\n\n# 网络请求和跨域解决方案\n\n## 原生ajax\n\n```javascript\nfunction sendajax() {\n    // 1、 初始化xhr对象\n    const xhr = new XMLHttpRequest();\n    //  2、 建立连接 设置请求方法和url\n    xhr.open(\"get\", \"./data.json\");\n    //   3、发送请求\n    xhr.send();\n    //   4、状态改变时 进行回调\n    xhr.onreadystatechange = function () {\n        // readyState 有0-4 五个值\n        // 0 代表 未初始化 1 代表 初始化成功 2 代表发送请求\n        // 3 代表返回了部分数据 4 代表返回了全部数据\n        if (xhr.readyState == 4) {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                //   进行成功的操作\n                console.log(xhr.responseText);\n            }\n        }\n    };\n}\nsendajax();\n```\n\n## JSONP跨域\n\n首先在客户端注册一个callback，然后把callback的名字传给服务器。此时，服务器先生成json数据，然后以JavaScript的语法方式，生成function，function的名字就是传递上来带参数的jsonp，最后将json数据直接以入参的方式，放置在function中，这样子就生成JavaScript语法文档，返回给客户端。客户端浏览器，通过解析，并执行返回JavaScript文档，此时数据作为参数，传入到客户端预先定义好的callback函数中，简单地说，就是**利用script标签没有跨域限制地漏洞来达到第三方通讯的目的（href、src 都不受同源策略的限制。）**\n\n**优点：**\n\n- 它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制，JSONP可以跨越同源策略；\n- 它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；\n\n**缺点:**\n\n- 它**只支持GET请求**而不支持POST等其它类型的HTTP请求\n- 它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。\n- jsonp在调用失败的时候不会返回各种HTTP状态码。\n- 需要后端配合\n\n```javascript\n        function jsonp({url,params,cb}){\n                return new Promise((resolve, reject)=>{\n                        window[cb] = function(data){\n                                console.log(data)\n                                resolve(data);\n                                document.body.removeChild(script);\n                        }//window对象上设置show方法\n                        params= {...params,cb}\n                        let arrs = [];\n                        for (let key in params){\n                                arrs.push(`${key}=${params[key]}`)\n                        }\n                        let script = document.createElement('script');\n                        script.src = `${url}?${arrs.join('&')}`;\n                        script.onerror = () => reject('加载失败') \n                        document.body.appendChild(script);\n                \n\n                })\n        }\n        jsonp({\n                url:\"http://localhost:3000/users\",\n                params:{name:\"jin\",age:12},\n                cb:'show'\n        }).then(data=>{\n                console.log(data)\n        })\n```\n\n后端：\n\n```javascript\nlet express = require('express');\nlet app = express();\napp.get('/users', function(req, res, next) {\n        // 模拟的数据\n        let {name,age,cb} = req.query\n        let data = `\"${name}现在${age}岁\"`\n        res.send(`${cb}(${data})`);// show(data)\n});\n\napp.listen(3000)\n```\n\n## cors跨域\n\n同源策略是不允许接收响应而不是不允许发送请求，所以可以通过在响应头中设置某些字段来允许满足条件的请求跨域，比如设置 `Access-Control-Allow-Origin` 字段允许来自某个源的请求跨域，比如设置 `Access-Control-Allow-Methods` 字段允许'GET'或者'POST'方式的请求跨域\n\n后端：\n\n```javascript\nlet express = require('express');\nlet app = express();\napp.all('*', function (req, res, next) {\n  let origin = req.headers.origin\n        //设置哪个源可以访问我\n  res.header(\"Access-Control-Allow-Origin\",origin);\n        // 允许携带哪个头访问我\n  res.header(\"Access-Control-Allow-Headers\", \"name\");\n        // 允许哪个方法访问我\n  res.header(\"Access-Control-Allow-Methods\", \"POST\");\n        // 允许携带cookie\n  res.set(\"Access-Control-Allow-Credentials\", true);\n        // 预检的存活时间\n  res.header(\"Access-Control-Max-Age\", 6);\n        // 允许前端获取哪个头\n        res.header(\"Access-Control-Expose-Headers\", \"name\");\n        // 请求头的格式\n  res.header(\"Content-Type\", \"application/json;charset=utf-8\");        \n  next();\n});\napp.post('/getData', function(req, res, next) {\n        console.log(req.headers)\n        res.send(\"你拿不到数据了！\");\n});\n\napp.listen(4000)\n```\n\n![img](https://k0x1mohrv2i.feishu.cn/space/api/box/stream/download/asynccode/?code=NDZkMzY0OGQyNDNmNjUxZDIwMjU1MWNlN2E0Mzg4MWFfa29GVk90bXpPWThOWlE3b2RzVFJJclhjRG45R01BaXFfVG9rZW46TlBKZGJkQlJ4b0F3V3h4NDRxWWNHNmxnbldjXzE3NTMxNjg3NjA6MTc1MzE3MjM2MF9WNA)\n\n非简单请求是那种对服务器有特殊要求的请求，比如请求方法是`PUT`或`DELETE`，或者`Content-Type`字段的类型是`application/json`。\n\n非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为\"预检\"请求（preflight）。\n\n浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。 代码修改一下：\n\n```javascript\n// 在请求头的设置中加上\nif(req.method ==='OPTIONS'){\n    res.end();//OPTIONS请求不做任何处理\n}\n```\n\n![img](https://k0x1mohrv2i.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGZhMjliNjM3ZDgyYTViMWZjYjdkZGJkOGMxZDE4YTBfclJZQzR4MzMwZmRpd3J4MEl3UWlqbVE3NEU2UDZwODFfVG9rZW46Qk53bWJ2T2dSb3BoZU14eXNFRmNZN1M0blNYXzE3NTMxNjg3NjA6MTc1MzE3MjM2MF9WNA)\n\n## postMessage跨域\n\n**「window.postMessage()」** 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 https），端口号（443 为 https 的默认值），以及主机 (两个页面的模数 [`Document.domain`]设置为相同的值) 时，这两个脚本才能相互通信。**「window.postMessage()」** 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。\n\n**用途**\n\n1.页面和其打开的新窗口的数据传递\n\n2.多窗口之间消息传递\n\n3.页面与嵌套的 iframe 消息传递\n\n**实现**\n\na.html\n\n```xml\n<iframe src=\"http://localhost:4000/b.html\" frameborder=\"0\" id=\"frame\" onload=\"load()\"></iframe>\n<script>\n    function load(){\n        let frame = document.getElementById('frame');\n        frame.contentWindow.postMessage('你好','http://localhost:4000/');\n        //接收\n        window.onmessage= function(e){\n            console.log(e.data)\n        }\n    }\n</script>\n```\n\nb.html\n\n```xml\nwindow.onmessage = function(e){\n    console.log(e.data);\n    //发送\n    e.source.postMessage('hello',e.origin)\n}\n```\n\n## 本地代理跨域\n\nproxy其实就是因为浏览器同源协议无法请求非同源的地址，但是服务器直接没有同源协议，利用将本地请求转到本地服务器进行代理转发，从而绕过了同源协议的限制，通过代理的实现可以解决跨域的问题\n\n通过设置一个 node 后端作为中间层，前端发送的请求首先到达这个中间层，然后再由中间层将请求转发到目标服务器。响应过程也是如此，服务器先响应给中间层，中间层再将响应数据发送回前端。\n\n这个中间层就起到了一个代理的作用。这样，浏览器看到的是同源请求，从而绕过了CORS限制。\n\n假设前端现在要将请求发送给 [http://192.168.1.63:3000](https://link.juejin.cn?target=http%3A%2F%2F192.168.1.63%3A3000) 这个后端，就可以先由本机的 3001 端口作一个代理\n\n```xml\n<!-- 前端 -->\n<body>\n    <script>\n        const xhr = new XMLHttpRequest()\n        xhr.open('GET', 'https://localhost:3001')\n        xhr.send()\n        xhr.onreadystatechange = function() {\n            if (xhr.readyState === 4 && xhr.status === 200) {\n                console.log(xhr.responseText)\n            }\n        }\n    </script>\n</body>\n```\n\n本机后端\n\n```javascript\n// 后端\nconst http = require('http')\n\n// 监听本机3001端口，有新请求时调用回调函数\nhttp.createServer((req, res)  => {\n\n    // 设置响应头，以允许前端应用访问响应内容\n    res.writeHead(200, {\n        'Access-Control-Allow-Origin': '*'\n    })\n\n    // 转发请求到目标服务器，并处理响应\n    http.request({\n        host: '192.168.1.63',\n        port: 3000,\n        path: '/',\n        method: 'GET',\n        headers: {}\n    }, proxyRes => {\n        proxyRes.on('data', chunk => {\n            res.end(chunk.toString())\n        })\n    }).end()\n    \n}).listen(3001)\n```\n\n### 各脚手架的proxy配置：\n\n#### Webpack (4.x)\n\n在`webpack`中可以配置`proxy`来快速获得接口代理的能力。\n\n```JavaScript\nconst path = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nmodule.exports = {\n  entry: {\n    index: \"./index.js\"\n  },\n  output: {\n    filename: \"bundle.js\",\n    path: path.resolve(__dirname, \"dist\")\n  },\n  devServer: {\n    port: 8000,\n    proxy: {\n      \"/api\": {\n        target: \"http://localhost:8080\"\n      }\n    }\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: \"index.html\",\n      template: \"webpack.html\"\n    })\n  ]\n};\n```\n\n#### **Vue-cli 2.x**\n\n```JavaScript\n// config/index.js\n\n...\nproxyTable: {\n  '/api': {\n     target: 'http://localhost:8080',\n  }\n},\n...\n```\n\n#### Vue-cli 3.x\n\n```JavaScript\n// vue.config.js 如果没有就新建\nmodule.exports = {\n  devServer: {\n    port: 8000,\n    proxy: {\n      \"/api\": {\n        target: \"http://localhost:8080\"\n      }\n    }\n  }\n};\n```\n\n#### vite\n\n```javascript\nimport { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\nimport styleImport, { VantResolve } from 'vite-plugin-style-import';\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [\n    vue(),\n    styleImport({\n      resolves: [VantResolve()],\n    }),],\n    server: { //主要是加上这段代码\n      host: '127.0.0.1',\n      port: 3000,\n      proxy: {\n        '/api': {\n          target: 'http://127.0.0.1:8888',        //实际请求地址\n          changeOrigin: true,\n          rewrite: (path) => path.replace(/^\\/api/, '')\n        },\n      }\n    }\n})\n```\n\n## nginx反向代理跨域\n\n反向代理与本地代理相反。本地代理是客户端搞定的，反向代理就是服务端搞定的\n\n反向代理的是在服务端内部完成。\n\n是服务端（数据应用）向服务端（网页应用）发送数据， 服务端向客户端发送数据 其本质是在服务端（网页应用）通过配置Access-Control-Allow-Origin * 来解决跨域问题。相当于对后端接口进行了统一的cors配置\n\n`Access-Control-Allow-Origin: *` 值表明，该资源可以被**任意**外源访问。\n\n```bash\n    #通过配置nginx文件既可\n    \n    events{}\n\nhttp{\n    include       mime.types;\n    default_type  application/octet-stream;\n    server{\n        listen 80;\n        server_name 127.0.0.1;\n        root D:/nginx-1.26.1/dist;\n        index index.html;\n        location / {\n   \n               location /api {\n                proxy_pass http://127.0.0.1:8080/;\n                proxy_set_header Host $host;\n                proxy_set_header X-Real-IP $remote_addr;\n                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n                proxy_set_header X-Forwarded-Proto $scheme;\n\n                # 解决跨域问题\n                add_header Access-Control-Allow-Origin *;\n                add_header Access-Control-Allow-Methods \"GET, POST, OPTIONS, HEAD, PUT, DELETE\";\n                add_header Access-Control-Allow-Headers \"Origin, X-Requested-With, Content-Type, Accept, Authorization, User-Agent, DNT\";\n                add_header Access-Control-Max-Age 86400;\n\n                \n            }\n        }\n    }\n}\n```\n\n# 设计模式\n\n## 单例模式\n\n```typescript\n// 单例模式示例代码\nclass Singleton {\n  constructor() {\n    if (!Singleton.instance) {\n      Singleton.instance = this;\n    }\n    return Singleton.instance;\n  }\n\n  createInstance() {\n    const object = { name: \"example\" };\n    return object;\n  }\n\n  getInstance() {\n    if (!Singleton.instance) {\n      Singleton.instance = this.createInstance();\n    }\n    return Singleton.instance;\n  }\n}\n\n// 使用示例\nconst instance1 = new Singleton();\nconst instance2 = new Singleton();\n\nconsole.log(instance1 === instance2); // true\n```\n\n## 工厂模式\n\n```javascript\nclass Product {\n  constructor(name) {\n    this.name = name;\n  }\n\n  getName() {\n    return this.name;\n  }\n}\n\nclass ProductFactory {\n  static createProduct(name) {\n    return new Product(name);\n  }\n}\n\n// 使用示例\nconst product = ProductFactory.createProduct(\"Example Product\");\nconsole.log(product.getName()); // \"Example Product\"\n```\n\n## 观察者模式\n\n```javascript\nclass Subject {\n  constructor() {\n    this.observers = [];\n  }\n\n  addObserver(observer) {\n    this.observers.push(observer);\n  }\n\n  removeObserver(observer) {\n    const index = this.observers.indexOf(observer);\n    if (index !== -1) {\n      this.observers.splice(index, 1);\n    }\n  }\n\n  notify(data) {\n    this.observers.forEach(observer => observer.update(data));\n  }\n}\n\nclass Observer {\n  update(data) {\n    console.log(`Received data: ${data}`);\n  }\n}\n\n// 使用示例\nconst subject = new Subject();\nconst observer1 = new Observer();\nconst observer2 = new Observer();\n\nsubject.addObserver(observer1);\nsubject.addObserver(observer2);\n\nsubject.notify(\"Hello World!\");\n```\n\n## 装饰器模式\n\n```java\ninterface Component {\n  operation(): void;\n}\n\nclass ConcreteComponent implements Component {\n  public operation(): void {\n    console.log(\"ConcreteComponent: operation.\");\n  }\n}\n\nclass Decorator implements Component {\n  protected component: Component;\n\n  constructor(component: Component) {\n    this.component = component;\n  }\n\n  public operation(): void {\n    console.log(\"Decorator: operation.\");\n    this.component.operation();\n  }\n}\n\nclass ConcreteDecoratorA extends Decorator {\n  public operation(): void {\n    super.operation();\n    console.log(\"ConcreteDecoratorA: operation.\");\n  }\n}\n\nclass ConcreteDecoratorB extends Decorator {\n  public operation(): void {\n    super.operation();\n    console.log(\"ConcreteDecoratorB: operation.\");\n  }\n}\n\n// 使用示例\nconst concreteComponent = new ConcreteComponent();\nconst concreteDecoratorA = new ConcreteDecoratorA(concreteComponent);\nconst concreteDecoratorB = new ConcreteDecoratorB(concreteDecoratorA);\n\nconcreteDecoratorB.operation();\n```\n\n## 代理模式\n\n```javascript\nconst target = {\n  method() {\n    console.log(\"Target method.\");\n  }\n};\n\nconst proxy = new Proxy(target, {\n  get(target, prop) {\n    console.log(`Called ${prop} method.`);\n    return target[prop];\n  }\n});\n\n// 使用示例\nproxy.method(); // \"Called method method. Target method.\"\n```\n\n## 适配器模式\n\n```javascript\nclass Adaptee {\n  specificRequest() {\n    return \"适配者中的业务代码被调用\";\n  }\n}\n\nclass Target {\n  constructor() {\n    this.adaptee = new Adaptee();\n  }\n\n  request() {\n    let info = this.adaptee.specificRequest();\n    return `${info} - 转换器 - 适配器代码被调用`;\n  }\n}\n\n// 使用示例\nlet target = new Target();\ntarget.request(); // \"适配者中的业务代码被调用 - 转换器 - 适配器代码被调用\"\n```\n\n## MVC模式\n\n```javascript\nclass Model {\n  constructor() {\n    this.data = {\n      name: \"example\",\n      age: 18,\n      gender: \"male\"\n    };\n  }\n\n  setData(key, value) {\n    this.data[key] = value;\n  }\n\n  getData() {\n    return this.data;\n  }\n}\n\nclass View {\n  constructor() {\n    this.container = document.createElement(\"div\");\n  }\n\n  render(data) {\n    const { name, age, gender } = data;\n    this.container.innerHTML = `\n      <p>Name: ${name}</p>\n      <p>Age: ${age}</p>\n      <p>Gender: ${gender}</p>\n    `;\n    document.body.appendChild(this.container);\n  }\n}\n\nclass Controller {\n  constructor(model, view) {\n    this.model = model;\n    this.view = view;\n    this.view.render(this.model.getData());\n  }\n\n  setData(key, value) {\n    this.model.setData(key, value);\n    this.view.render(this.model.getData());\n  }\n}\n\n// 使用示例\nconst model = new Model();\nconst view = new View();\nconst controller = new Controller(model, view);\n\ncontroller.setData(\"age\", 20);\n```\n\n## 策略模式\n\n表单验证情景：\n\n```ts\n// 验证策略\nconst validationStrategies = {\n  required: {\n    validate: (value) => value !== '',\n    message: '该字段不能为空'\n  },\n  \n  minLength: {\n    validate: (value, length) => value.length >= length,\n    message: (length) => `最少需要${length}个字符`\n  },\n  \n  email: {\n    validate: (value) => /^\\S+@\\S+\\.\\S+$/.test(value),\n    message: '请输入有效的邮箱地址'\n  },\n  \n  phone: {\n    validate: (value) => /^1[3-9]\\d{9}$/.test(value),\n    message: '请输入有效的手机号'\n  },\n  \n  custom: {\n    validate: (value, validator) => validator(value),\n    message: '自定义验证失败'\n  }\n};\n\n// 表单验证器\nclass FormValidator {\n  constructor() {\n    this.rules = [];\n  }\n  \n  // 添加验证规则\n  addRule(field, strategy, ...params) {\n    this.rules.push({\n      field,\n      strategy,\n      params\n    });\n  }\n  \n  // 执行验证\n  validate(formData) {\n    const errors = [];\n    \n    for (const rule of this.rules) {\n      const { field, strategy, params } = rule;\n      const value = formData[field];\n      const validationStrategy = validationStrategies[strategy];\n      \n      if (!validationStrategy.validate(value, ...params)) {\n        errors.push({\n          field,\n          message: typeof validationStrategy.message === 'function' \n            ? validationStrategy.message(...params)\n            : validationStrategy.message\n        });\n      }\n    }\n    \n    return {\n      isValid: errors.length === 0,\n      errors\n    };\n  }\n}\n\n// 使用示例\nconst validator = new FormValidator();\nvalidator.addRule('username', 'required');\nvalidator.addRule('username', 'minLength', 3);\nvalidator.addRule('email', 'required');\nvalidator.addRule('email', 'email');\nvalidator.addRule('phone', 'phone');\n\nconst formData = {\n  username: 'ab',\n  email: 'invalid-email',\n  phone: '12345678901'\n};\n\nconst result = validator.validate(formData);\nconsole.log(result);\n// {\n//   isValid: false,\n//   errors: [\n//     { field: 'username', message: '最少需要3个字符' },\n//     { field: 'email', message: '请输入有效的邮箱地址' },\n//     { field: 'phone', message: '请输入有效的手机号' }\n//   ]\n// }\n```\n\n","tags":["秋招","ES","面试题","前端手撕"],"categories":["秋招准备"]},{"title":"【秋招备战】计算机网络","url":"/2025/07/22/【秋招备战】计算机网络/","content":"\n# 前言\n\n计算机网络作为前端开发中绕不开的基础知识，面试时也特爱问，很多时候都有可能被打一个冷不防。这份文档旨在整理前端面试中高频出现的计算机网络知识点，希望能帮助到正在准备面试的你。\n\n内容基于个人面试经验和学习总结，如有不当之处，欢迎指正交流。  本文不追求面面俱到，而是聚焦于前端面试中的高频考点，力求每个知识点都讲透彻、讲实用。\n\n# 一、HTTP 协议篇\n\n## 1.1 HTTP 基础\n\n- HTTP 是什么？\n- HTTP 请求方法详解\n- HTTP 状态码分类及常见状态码\n- HTTP 报文结构\n  - \n\n## 1.2 HTTP 缓存机制\n\n- 强缓存 vs 协商缓存\n- Cache-Control 详解\n- ETag 和 Last-Modified\n- 缓存位置（Memory Cache、Disk Cache等）\n  - \n\n## 1.3 HTTP 版本演进\n\n- HTTP/1.0 vs HTTP/1.1\n- HTTP/2 的优势（多路复用、服务器推送等）\n- HTTP/3 和 QUIC 协议\n  - \n\n## 1.4 HTTPS 安全通信\n\n- HTTP vs HTTPS\n- HTTPS 加密原理\n- 证书验证过程\n- 中间人攻击\n  - \n\n# 二、TCP/IP 协议篇\n\n## 2.1 TCP 基础\n\n- TCP 三次握手详解\n- TCP 四次挥手详解\n- 为什么需要三次握手？两次行不行？\n- TIME_WAIT 状态的作用\n  - \n\n## 2.2 TCP 可靠传输\n\n- 序列号和确认应答\n- 超时重传机制\n- 流量控制（滑动窗口）\n- 拥塞控制\n  - \n\n## 2.3 TCP vs UDP\n\n- 两者的区别对比\n- 各自的应用场景\n- 为什么视频直播常用 UDP？\n  - \n\n# 三、浏览器网络篇\n\n## 3.1 跨域问题\n\n- 同源策略是什么？\n- 跨域的解决方案汇总\n- CORS 详解\n- JSONP 原理及限制\n- 其他跨域方案\n  - \n\n## 3.2 经典问题：从 URL 到页面展示\n\n- DNS 解析过程\n- 建立 TCP 连接\n- 发送 HTTP 请求\n- 服务器处理请求\n- 浏览器渲染页面\n  - \n\n## 3.3 WebSocket\n\n- WebSocket vs HTTP\n- WebSocket 连接过程\n- 应用场景\n  - \n\n# 四、Web 安全篇\n\n## 4.1 XSS 攻击\n\n- XSS 类型（反射型、存储型、DOM型）\n- XSS 防御策略\n- CSP 内容安全策略\n  - \n\n## 4.2 CSRF 攻击\n\n- CSRF 攻击原理\n- CSRF 防御方法\n- SameSite Cookie\n  - \n\n## 4.3 其他安全问题\n\n- SQL 注入\n- 点击劫持\n- 中间人攻击\n  - \n\n# 五、性能优化篇\n\n## 5.1 网络层优化\n\n- 减少 HTTP 请求数\n- 使用 HTTP/2\n- 启用 Gzip 压缩\n- 使用 CDN\n  - \n\n## 5.2 资源加载优化\n\n- 预加载（preload、prefetch）\n- 懒加载\n- 图片优化策略\n  - \n\n# 六、实战题目篇\n\n（收录各大公司真实面试题及详解）","tags":["计算机网络","秋招","面试八股文"],"categories":["秋招准备"]},{"title":"【建站日志】Simon成功搬家","url":"/2025/06/12/【建站日志】Simon已着陆/","content":"\n之前用Wordpress建的网站突然炸了T_T，只好搬家到Hexo这边来，虽然之前就想换成ssg静态网站就是了。毕竟Wordpress博客系统上传文章太便秘了，完全用不惯他的文本编辑器，还是MD大法好啊！\n","tags":["建站日志","生活记录"]}]