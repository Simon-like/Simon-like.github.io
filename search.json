[{"title":"【秋招备战】React Router 进化史","url":"/2025/08/13/【秋招备战】React Router 进化史/","content":"\n> 兄弟，还在为秋招发愁？今天咱们来聊聊 React Router 这个\"老司机\"。从 v5 的稳重大叔到 v6 的激进青年，再到 v7 的王者归来（直接吞并了 Remix），这个故事比宫斗剧还精彩。系好安全带，咱们发车了！\n\n## 序章：为什么前端需要路由？\n\n还记得上古时代的网页吗？每点一个链接，整个页面\"唰\"地白屏，然后慢慢加载。用户体验？不存在的。\n\n然后 SPA（单页应用）横空出世，页面不刷新了，但新问题来了：\n\n- 浏览器的前进后退按钮废了\n- 刷新页面就 404 了\n- 分享链接？对不起，都是同一个 URL\n\n这时候，前端路由站出来说：\"这活儿我来！\"\n\n## 第一章：React Router v5 —— 稳重的老大哥\n\n### v5 的基本使用\n\nReact Router v5 就像个稳重的老司机，虽然有点啰嗦，但靠谱：\n\n```javascript\nimport { \n  BrowserRouter as Router, \n  Route, \n  Switch, \n  Link,\n  useHistory,\n  useParams \n} from 'react-router-dom';\n\nfunction App() {\n  return (\n    <Router>\n      <nav>\n        <Link to=\"/\">首页</Link>\n        <Link to=\"/about\">关于</Link>\n        <Link to=\"/user/123\">用户详情</Link>\n      </nav>\n      \n      {/* Switch 确保只渲染第一个匹配的路由 */}\n      <Switch>\n        <Route exact path=\"/\">\n          <Home />\n        </Route>\n        <Route path=\"/about\">\n          <About />\n        </Route>\n        <Route path=\"/user/:id\">\n          <UserDetail />\n        </Route>\n        <Route path=\"*\">\n          <NotFound />\n        </Route>\n      </Switch>\n    </Router>\n  );\n}\n\n// 使用 hooks 获取路由信息\nfunction UserDetail() {\n  const { id } = useParams(); // 获取路由参数\n  const history = useHistory(); // 获取 history 对象\n  \n  const handleGoBack = () => {\n    history.push('/'); // 编程式导航\n  };\n  \n  return (\n    <div>\n      <h1>用户 {id} 的详情页</h1>\n      <button onClick={handleGoBack}>返回首页</button>\n    </div>\n  );\n}\n```\n\n### v5 的高级技巧\n\n```javascript\n// 1. 路由配置化（更优雅的写法）\nconst routes = [\n  { path: '/', component: Home, exact: true },\n  { path: '/about', component: About },\n  { path: '/user/:id', component: UserDetail }\n];\n\nfunction App() {\n  return (\n    <Router>\n      <Switch>\n        {routes.map(route => (\n          <Route \n            key={route.path}\n            exact={route.exact}\n            path={route.path}\n            component={route.component}\n          />\n        ))}\n      </Switch>\n    </Router>\n  );\n}\n\n// 2. 路由守卫（类似 Vue Router 的导航守卫）\nfunction PrivateRoute({ children, ...rest }) {\n  const isAuthenticated = useAuth(); // 假设这是你的认证 hook\n  \n  return (\n    <Route {...rest}>\n      {isAuthenticated ? children : <Redirect to=\"/login\" />}\n    </Route>\n  );\n}\n\n// 3. 嵌套路由（v5 的痛点之一）\nfunction Users() {\n  const { path, url } = useRouteMatch();\n  \n  return (\n    <div>\n      <Link to={`${url}/profile`}>个人资料</Link>\n      <Link to={`${url}/settings`}>设置</Link>\n      \n      <Switch>\n        <Route exact path={path}>\n          <h3>请选择一个选项</h3>\n        </Route>\n        <Route path={`${path}/profile`}>\n          <Profile />\n        </Route>\n        <Route path={`${path}/settings`}>\n          <Settings />\n        </Route>\n      </Switch>\n    </div>\n  );\n}\n```\n\n## 第二章：React Router v6 —— 激进的革命者\n\nv6 来了，带着破坏性更新，社区炸锅了：\"你们是要搞事情吗？\"\n\n### v6 的巨变\n\n```javascript\nimport { \n  BrowserRouter,\n  Routes,  // 注意：Switch 改名了\n  Route, \n  Link,\n  useNavigate,  // useHistory 改名了\n  useParams,\n  Outlet  // 新概念：插槽\n} from 'react-router-dom';\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Routes>\n        {/* 不再需要 exact，默认就是精确匹配 */}\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/about\" element={<About />} />\n        \n        {/* 嵌套路由的新写法，超级优雅！ */}\n        <Route path=\"/users\" element={<Users />}>\n          <Route index element={<UserList />} />\n          <Route path=\":id\" element={<UserDetail />} />\n          <Route path=\"settings\" element={<Settings />} />\n        </Route>\n        \n        {/* 404 页面的新写法 */}\n        <Route path=\"*\" element={<NotFound />} />\n      </Routes>\n    </BrowserRouter>\n  );\n}\n\n// 父组件使用 Outlet 渲染子路由\nfunction Users() {\n  return (\n    <div>\n      <h1>用户中心</h1>\n      <nav>\n        <Link to=\"\">用户列表</Link>\n        <Link to=\"settings\">设置</Link>\n      </nav>\n      \n      {/* Outlet 就像 Vue 的 router-view */}\n      <Outlet />\n    </div>\n  );\n}\n\n// 编程式导航的新写法\nfunction SomeComponent() {\n  const navigate = useNavigate(); // 不再是 history.push\n  \n  const handleClick = () => {\n    navigate('/about'); // 更直观\n    navigate(-1); // 后退\n    navigate('/user/123', { replace: true }); // 替换当前记录\n  };\n  \n  return <button onClick={handleClick}>走你！</button>;\n}\n```\n\n### v6 的杀手锏功能\n\n```javascript\n// 1. 相对路由（终于不用拼接路径了！）\nfunction UserProfile() {\n  return (\n    <div>\n      {/* 相对于当前路由 */}\n      <Link to=\"..\">返回上级</Link>\n      <Link to=\"../settings\">设置</Link>\n      <Link to=\"edit\">编辑</Link>\n    </div>\n  );\n}\n\n// 2. 路由配置对象（更接近 Vue Router）\nconst routes = [\n  {\n    path: '/',\n    element: <Layout />,\n    children: [\n      { index: true, element: <Home /> },\n      { path: 'about', element: <About /> },\n      {\n        path: 'users',\n        element: <Users />,\n        children: [\n          { index: true, element: <UserList /> },\n          { path: ':id', element: <UserDetail /> }\n        ]\n      }\n    ]\n  }\n];\n\n// 使用 useRoutes hook\nfunction App() {\n  const element = useRoutes(routes);\n  return element;\n}\n\n// 3. 懒加载（Suspense 集成）\nconst LazyAbout = React.lazy(() => import('./About'));\n\n<Route \n  path=\"/about\" \n  element={\n    <React.Suspense fallback={<Loading />}>\n      <LazyAbout />\n    </React.Suspense>\n  } \n/>\n```\n\n## 第三章：底层原理 —— 路由的魔法是怎么实现的？\n\n来，让我们扒开 React Router 的外衣，看看它的真面目！\n\n### History API：一切的基础\n\n```javascript\n// 浏览器提供的 History API\nwindow.history.pushState(state, title, url); // 添加历史记录\nwindow.history.replaceState(state, title, url); // 替换当前记录\nwindow.history.back(); // 后退\nwindow.history.forward(); // 前进\n\n// 监听路由变化\nwindow.addEventListener('popstate', (event) => {\n  console.log('路由变化了！', location.pathname);\n});\n```\n\n### 简化版 React Router 实现\n\n让我们自己造个轮子，你就明白了：\n\n```javascript\n// 1. 创建 Router Context\nconst RouterContext = React.createContext();\n\n// 2. BrowserRouter 实现\nfunction BrowserRouter({ children }) {\n  const [location, setLocation] = useState(window.location.pathname);\n  \n  useEffect(() => {\n    // 监听浏览器前进后退\n    const handlePopState = () => {\n      setLocation(window.location.pathname);\n    };\n    \n    window.addEventListener('popstate', handlePopState);\n    return () => window.removeEventListener('popstate', handlePopState);\n  }, []);\n  \n  const navigate = (to, options = {}) => {\n    if (options.replace) {\n      window.history.replaceState(null, '', to);\n    } else {\n      window.history.pushState(null, '', to);\n    }\n    setLocation(to);\n  };\n  \n  return (\n    <RouterContext.Provider value={{ location, navigate }}>\n      {children}\n    </RouterContext.Provider>\n  );\n}\n\n// 3. Route 组件实现\nfunction Route({ path, element }) {\n  const { location } = useContext(RouterContext);\n  \n  // 简化版路径匹配（真实的要复杂得多）\n  const match = matchPath(path, location);\n  \n  return match ? element : null;\n}\n\n// 4. Link 组件实现\nfunction Link({ to, children }) {\n  const { navigate } = useContext(RouterContext);\n  \n  const handleClick = (e) => {\n    e.preventDefault(); // 阻止默认跳转\n    navigate(to);\n  };\n  \n  return <a href={to} onClick={handleClick}>{children}</a>;\n}\n\n// 5. 路径匹配算法（简化版）\nfunction matchPath(pattern, pathname) {\n  // 处理动态路由参数\n  // /user/:id => /user/123\n  const regexPattern = pattern\n    .replace(/:[^/]+/g, '([^/]+)') // 替换 :id 为正则\n    .replace(/\\*/g, '.*'); // 处理通配符\n    \n  const regex = new RegExp(`^${regexPattern}$`);\n  return regex.test(pathname);\n}\n```\n\n### Hash Router vs Browser Router\n\n```javascript\n// Hash Router：使用 URL 的 hash 部分\n// http://example.com/#/about\nclass HashRouter {\n  constructor() {\n    window.addEventListener('hashchange', this.handleHashChange);\n  }\n  \n  handleHashChange = () => {\n    const path = window.location.hash.slice(1); // 去掉 #\n    this.updateView(path);\n  }\n  \n  push(path) {\n    window.location.hash = path;\n  }\n}\n\n// Browser Router：使用 HTML5 History API\n// http://example.com/about\nclass BrowserRouter {\n  constructor() {\n    window.addEventListener('popstate', this.handlePopState);\n  }\n  \n  handlePopState = () => {\n    this.updateView(window.location.pathname);\n  }\n  \n  push(path) {\n    window.history.pushState(null, '', path);\n    this.updateView(path);\n  }\n}\n```\n\n**面试加分点**：\n\n- Hash Router 兼容性好，但 URL 有个丑陋的 #\n- Browser Router 需要服务器配置支持（所有路由都返回 index.html）\n- Hash Router 不会发送到服务器，Browser Router 会\n\n## 第四章：React Router v7 —— 王者归来（融合 Remix）\n\n2024 年底，React Router v7 震撼发布，直接把 Remix 给\"吞并\"了！\n\n### v7 的重磅特性：SSR 支持\n\n```javascript\n// v7 最大的变化：原生支持 SSR！\n// 这不是简单的路由了，这是全栈框架！\n\n// 1. 数据加载（类似 Next.js 的 getServerSideProps）\nexport async function loader({ params }) {\n  const user = await fetchUser(params.id);\n  return { user };\n}\n\nexport default function UserProfile() {\n  const { user } = useLoaderData();\n  \n  return <h1>欢迎，{user.name}！</h1>;\n}\n\n// 2. Action 处理表单提交\nexport async function action({ request }) {\n  const formData = await request.formData();\n  const email = formData.get('email');\n  \n  await updateEmail(email);\n  return redirect('/profile');\n}\n\nexport default function Settings() {\n  return (\n    <Form method=\"post\">\n      <input name=\"email\" type=\"email\" />\n      <button type=\"submit\">更新邮箱</button>\n    </Form>\n  );\n}\n\n// 3. 错误边界\nexport function ErrorBoundary() {\n  const error = useRouteError();\n  \n  return (\n    <div>\n      <h1>哎呀，出错了！</h1>\n      <p>{error.message}</p>\n    </div>\n  );\n}\n```\n\n### v7 的完整 SSR 示例\n\n```javascript\n// app/routes/blog.$slug.jsx\nimport { useLoaderData } from 'react-router-dom';\n\n// 服务器端数据获取\nexport async function loader({ params }) {\n  // 这段代码只在服务器运行！\n  const post = await db.post.findUnique({\n    where: { slug: params.slug }\n  });\n  \n  if (!post) {\n    throw new Response('Not Found', { status: 404 });\n  }\n  \n  return { post };\n}\n\n// Meta 标签（SEO 优化）\nexport function meta({ data }) {\n  return [\n    { title: data.post.title },\n    { name: 'description', content: data.post.excerpt },\n    { property: 'og:title', content: data.post.title }\n  ];\n}\n\n// 组件\nexport default function BlogPost() {\n  const { post } = useLoaderData();\n  \n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <time>{post.publishedAt}</time>\n      <div dangerouslySetInnerHTML={{ __html: post.content }} />\n    </article>\n  );\n}\n\n// 流式 SSR（React 18 特性）\nexport async function loader() {\n  return defer({\n    critical: await getCriticalData(), // 立即加载\n    comments: getComments() // 延迟加载，流式传输\n  });\n}\n\nexport default function Post() {\n  const { critical, comments } = useLoaderData();\n  \n  return (\n    <div>\n      <h1>{critical.title}</h1>\n      <Suspense fallback={<LoadingComments />}>\n        <Await resolve={comments}>\n          {(comments) => <Comments data={comments} />}\n        </Await>\n      </Suspense>\n    </div>\n  );\n}\n```\n\n## 第五章：版本迁移指南 —— 从 v5 到 v6/v7\n\n### 主要变化对照表\n\n| 特性      | v5                      | v6/v7                     |\n| --------- | ----------------------- | ------------------------- |\n| 路由容器  | `<Switch>`              | `<Routes>`                |\n| 路由组件  | `component={Component}` | `element={<Component />}` |\n| 嵌套路由  | 手动拼接路径            | 自动处理，使用 `<Outlet>` |\n| 导航 Hook | `useHistory`            | `useNavigate`             |\n| 路由匹配  | 需要 `exact`            | 默认精确匹配              |\n| 相对链接  | 不支持                  | 完全支持                  |\n\n### 迁移示例\n\n```javascript\n// v5 老代码\nfunction OldApp() {\n  const history = useHistory();\n  \n  return (\n    <Switch>\n      <Route exact path=\"/\" component={Home} />\n      <Route path=\"/users/:id\" component={UserDetail} />\n    </Switch>\n  );\n}\n\n// v6/v7 新代码\nfunction NewApp() {\n  const navigate = useNavigate();\n  \n  return (\n    <Routes>\n      <Route path=\"/\" element={<Home />} />\n      <Route path=\"/users/:id\" element={<UserDetail />} />\n    </Routes>\n  );\n}\n\n// 复杂嵌套路由迁移\n// v5：需要在每个组件里处理\nfunction Users() {\n  const { path, url } = useRouteMatch();\n  return (\n    <Switch>\n      <Route exact path={path} component={UserList} />\n      <Route path={`${path}/:id`} component={UserDetail} />\n    </Switch>\n  );\n}\n\n// v6/v7：集中配置\n<Route path=\"/users\" element={<Users />}>\n  <Route index element={<UserList />} />\n  <Route path=\":id\" element={<UserDetail />} />\n</Route>\n```\n\n## 第六章：实战技巧与性能优化\n\n### 1. 路由懒加载\n\n```javascript\n// 配合 React.lazy 和 Suspense\nconst LazyDashboard = lazy(() => \n  import(/* webpackChunkName: \"dashboard\" */ './Dashboard')\n);\n\nfunction App() {\n  return (\n    <Routes>\n      <Route \n        path=\"/dashboard/*\" \n        element={\n          <Suspense fallback={<Loading />}>\n            <LazyDashboard />\n          </Suspense>\n        } \n      />\n    </Routes>\n  );\n}\n```\n\n### 2. 路由预加载\n\n```javascript\n// 鼠标悬停时预加载\nfunction PreloadableLink({ to, children }) {\n  const handleMouseEnter = () => {\n    // 预加载组件\n    import(`./pages${to}`);\n  };\n  \n  return (\n    <Link to={to} onMouseEnter={handleMouseEnter}>\n      {children}\n    </Link>\n  );\n}\n```\n\n### 3. 路由过渡动画\n\n```javascript\nimport { CSSTransition, TransitionGroup } from 'react-transition-group';\n\nfunction AnimatedRoutes() {\n  const location = useLocation();\n  \n  return (\n    <TransitionGroup>\n      <CSSTransition\n        key={location.pathname}\n        timeout={300}\n        classNames=\"fade\"\n      >\n        <Routes location={location}>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/about\" element={<About />} />\n        </Routes>\n      </CSSTransition>\n    </TransitionGroup>\n  );\n}\n\n/* CSS */\n.fade-enter {\n  opacity: 0;\n}\n.fade-enter-active {\n  opacity: 1;\n  transition: opacity 300ms;\n}\n.fade-exit {\n  opacity: 1;\n}\n.fade-exit-active {\n  opacity: 0;\n  transition: opacity 300ms;\n}\n```\n\n### 4. 路由级别的状态管理\n\n```javascript\n// 使用 location.state 传递临时数据\nfunction ProductList() {\n  const navigate = useNavigate();\n  \n  const handleEdit = (product) => {\n    navigate('/edit', { \n      state: { product, from: '/products' } \n    });\n  };\n}\n\nfunction EditProduct() {\n  const location = useLocation();\n  const navigate = useNavigate();\n  const product = location.state?.product;\n  \n  const handleSave = async (data) => {\n    await saveProduct(data);\n    // 返回来源页面\n    navigate(location.state?.from || '/');\n  };\n}\n```\n\n## 第七章：面试必考题\n\n### 面试官：React Router 的原理是什么？\n\n**标准答案**： React Router 基于浏览器的 History API，通过监听 URL 变化来渲染对应的组件。核心原理：\n\n1. 使用 Context 在组件树中传递路由状态\n2. Route 组件根据当前 URL 匹配 path 来决定是否渲染\n3. Link 组件阻止默认行为，调用 history.pushState 更新 URL\n4. 监听 popstate 事件处理浏览器前进后退\n\n### 面试官：如何实现路由守卫？\n\n```javascript\n// v6/v7 的实现方式\nfunction RequireAuth({ children }) {\n  const auth = useAuth();\n  const location = useLocation();\n  \n  if (!auth.user) {\n    // 记录用户想去的页面，登录后跳转\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n  \n  return children;\n}\n\n// 使用\n<Route \n  path=\"/protected\" \n  element={\n    <RequireAuth>\n      <ProtectedPage />\n    </RequireAuth>\n  } \n/>\n```\n\n### 面试官：Hash Router 和 Browser Router 的区别？\n\n**加分回答**：\n\n- **Hash Router**：URL 带 #，不需要服务器配置，不支持 SSR\n- **Browser Router**：更美观的 URL，需要服务器配置，支持 SSR\n- **Memory Router**：URL 不变化，用于 React Native 或测试\n- **Static Router**：用于 SSR，不会改变 URL\n\n### 面试官：React Router v6 为什么要做 Breaking Changes？\n\n**高情商回答**： v6 的改动虽然很大，但带来了：\n\n1. **更小的包体积**（减少约 50%）\n2. **更好的 TypeScript 支持**\n3. **更直观的嵌套路由**\n4. **相对路径支持**\n5. **为 SSR 做准备**（v7 实现了）\n\n## 结语：路由的未来\n\n从 v5 的稳重，到 v6 的激进，再到 v7 的全栈化，React Router 的进化史就是前端发展的缩影。记住：\n\n1. **v5 还在广泛使用**，很多老项目没有升级\n2. **v6 是过渡**，新项目建议直接上\n3. **v7 是未来**，SSR 成为标配\n\n最后给秋招的你一些建议：\n\n- 面试时能讲清楚版本差异会很加分\n- 理解原理比记 API 重要 100 倍\n- 如果面试官问到 v7，说明这是家技术很新的公司\n- 准备一个路由相关的项目亮点，比如\"我用路由懒加载优化了 70% 的首屏加载时间\"\n\n**记住**：技术是在不断进化的，保持学习的心态比掌握某个版本的 API 更重要。今天的 v7，可能就是明天的 \"legacy code\"。\n\n------\n\n*P.S. 如果这篇文章帮到了你，记得收藏起来。毕竟，面试前临时抱佛脚的时候，你会感谢现在认真看完的自己的！*\n\n*P.P.S. React Router 团队：求求你们，别再搞破坏性更新了，我们学不动了... 😭*\n","tags":["React","秋招","ReactRouter"],"categories":["秋招准备"]},{"title":"【秋招备战】React状态管理方案：Redux vs MobX","url":"/2025/08/13/【秋招备战】React路由管理方案：Redux vs MobX/","content":"\n> 朋友，听说你在准备秋招？那今天咱们来聊聊前端江湖里的两大门派——Redux 和 MobX。这两位可都是状态管理界的大佬，一个像少林寺的易筋经，招式规矩森严；一个像逍遥派的北冥神功，灵活自在。让我们一起揭开它们的神秘面纱。\n\n## 第一章：初入江湖——为什么需要状态管理？\n\n想象一下，你在开发一个电商网站。用户的购物车数据需要在导航栏、购物车页面、结账页面共享，如果没有状态管理，你就得像传话游戏一样，一层层把数据传下去：\n\n```javascript\n// 没有状态管理的痛苦传话游戏\n<App cartItems={cartItems}>\n  <Header cartItems={cartItems}>\n    <CartIcon cartItems={cartItems}>\n      <CartCount count={cartItems.length} /> // 终于到了！累死了...\n    </CartIcon>\n  </Header>\n</App>\n```\n\n这就是传说中的\"prop drilling\"（属性钻孔），钻着钻着，你就想掀桌子了。\n\n## 第二章：Redux——规矩森严的少林派\n\n### Redux 的基本招式\n\nRedux 就像一个超级严格的图书管理员，它有三大金科玉律：\n\n1. **单一数据源（Single Source of Truth）**：整个应用只有一个 store，就像图书馆只有一个总目录\n2. **State 是只读的**：你不能直接改书，只能提交申请\n3. **使用纯函数修改**：修改必须按规矩来，不能搞特殊\n\n来看看 Redux 的基本套路：\n\n```javascript\n// 1. 定义 Action（你的申请单）\nconst ADD_TO_CART = 'ADD_TO_CART';\nconst addToCart = (product) => ({\n  type: ADD_TO_CART,\n  payload: product\n});\n\n// 2. 创建 Reducer（图书管理员的处理规则）\nconst cartReducer = (state = [], action) => {\n  switch (action.type) {\n    case ADD_TO_CART:\n      // 注意！必须返回新对象，不能直接修改\n      return [...state, action.payload];\n    default:\n      return state;\n  }\n};\n\n// 3. 创建 Store（图书馆）\nimport { createStore } from 'redux';\nconst store = createStore(cartReducer);\n\n// 4. 使用 Store\nstore.dispatch(addToCart({ id: 1, name: '秋招面试宝典', price: 99 }));\nconsole.log(store.getState()); // [{ id: 1, name: '秋招面试宝典', price: 99 }]\n```\n\n### Redux 的内功心法——实现原理\n\nRedux 的核心其实就是一个发布-订阅模式，我来给你\"解剖\"一下它的内部构造：\n\n```javascript\n// 简化版 Redux 实现（去掉了中间件等复杂功能）\nfunction createStore(reducer, initialState) {\n  let state = initialState;\n  let listeners = []; // 订阅者名单\n  \n  // 获取当前状态\n  const getState = () => state;\n  \n  // 订阅变化\n  const subscribe = (listener) => {\n    listeners.push(listener);\n    // 返回取消订阅的函数（贴心不？）\n    return () => {\n      listeners = listeners.filter(l => l !== listener);\n    };\n  };\n  \n  // 派发 action\n  const dispatch = (action) => {\n    // 通过 reducer 计算新状态\n    state = reducer(state, action);\n    // 通知所有订阅者：\"兄弟们，数据更新了！\"\n    listeners.forEach(listener => listener());\n    return action;\n  };\n  \n  // 初始化 state\n  dispatch({ type: '@@INIT' });\n  \n  return { getState, subscribe, dispatch };\n}\n```\n\n看到了吗？Redux 就像一个严格的广播电台：\n\n1. dispatch 一个 action = 发送广播信号\n2. reducer 处理 = 电台处理信号\n3. 通知所有 listeners = 广播给所有收音机\n\n### Redux 在 React 中的实战\n\n在 React 中使用 Redux，需要 react-redux 这个\"翻译官\"：\n\n```javascript\n// 1. 使用 Provider 包裹应用\nimport { Provider } from 'react-redux';\n\nfunction App() {\n  return (\n    <Provider store={store}>\n      <YourAppComponents />\n    </Provider>\n  );\n}\n\n// 2. 使用 hooks 连接组件\nimport { useSelector, useDispatch } from 'react-redux';\n\nfunction ShoppingCart() {\n  // useSelector 就像一个监视器，盯着 state 的变化\n  const cartItems = useSelector(state => state.cart);\n  const dispatch = useDispatch();\n  \n  const handleAddItem = (product) => {\n    dispatch(addToCart(product));\n  };\n  \n  return (\n    <div>\n      <h2>购物车（{cartItems.length}件商品）</h2>\n      {/* ... */}\n    </div>\n  );\n}\n```\n\n## 第三章：MobX——自由奔放的逍遥派\n\n如果说 Redux 是个严格的图书管理员，那 MobX 就是个贴心的私人助理。它会自动追踪你需要什么，然后在数据变化时自动更新。\n\n### MobX 的基本招式\n\n```javascript\nimport { makeObservable, observable, action, computed } from 'mobx';\n\nclass ShoppingCart {\n  items = [];\n  \n  constructor() {\n    // 告诉 MobX：\"帮我盯着这些东西\"\n    makeObservable(this, {\n      items: observable,\n      addItem: action,\n      removeItem: action,\n      totalPrice: computed\n    });\n  }\n  \n  // 直接修改，没有那么多规矩\n  addItem(product) {\n    this.items.push(product);\n  }\n  \n  removeItem(id) {\n    const index = this.items.findIndex(item => item.id === id);\n    if (index > -1) {\n      this.items.splice(index, 1);\n    }\n  }\n  \n  // 计算属性，自动缓存\n  get totalPrice() {\n    return this.items.reduce((sum, item) => sum + item.price, 0);\n  }\n}\n\nconst cart = new ShoppingCart();\n```\n\n看到了吗？MobX 就像你的贴心小棉袄，你直接改数据就行，它会自动通知该通知的人。\n\n### MobX 的内功心法——响应式原理\n\nMobX 的魔法主要来自于 ES6 的 Proxy（或者在老版本中用 Object.defineProperty）。让我来揭秘一下：\n\n```javascript\n// 简化版 MobX 原理\nfunction makeObservable(target) {\n  const observers = new Set(); // 观察者集合\n  \n  // 使用 Proxy 拦截对象操作\n  return new Proxy(target, {\n    get(obj, prop) {\n      // 收集依赖：\"哦，有人在读取这个属性\"\n      if (currentObserver) {\n        observers.add(currentObserver);\n      }\n      return obj[prop];\n    },\n    \n    set(obj, prop, value) {\n      obj[prop] = value;\n      // 通知观察者：\"兄弟们，数据变了！\"\n      observers.forEach(observer => observer());\n      return true;\n    }\n  });\n}\n\n// 追踪函数执行时访问了哪些属性\nlet currentObserver = null;\n\nfunction autorun(fn) {\n  currentObserver = fn;\n  fn(); // 执行一次，收集依赖\n  currentObserver = null;\n}\n\n// 使用示例\nconst person = makeObservable({ name: '小明', age: 25 });\n\nautorun(() => {\n  console.log(`${person.name} 今年 ${person.age} 岁`);\n});\n\nperson.age = 26; // 自动触发 console.log\n```\n\nMobX 的精髓就是：\n\n1. **依赖收集**：当你读取数据时，MobX 偷偷记下\"谁在用这个数据\"\n2. **自动更新**：当数据变化时，MobX 通知所有用到这个数据的地方\n\n这就像你在淘宝收藏了一个商品，降价时自动给你发通知一样贴心！\n\n### MobX 在 React 中的实战\n\n```javascript\nimport { observer } from 'mobx-react-lite';\n\n// observer 是个高阶组件，让组件\"有眼力见\"\nconst ShoppingCart = observer(() => {\n  // 直接使用，没有 hook，没有 dispatch\n  const cart = useCart(); // 假设这是你的 cart store\n  \n  return (\n    <div>\n      <h2>购物车（{cart.items.length}件商品）</h2>\n      <p>总价：{cart.totalPrice}元</p>\n      <button onClick={() => cart.addItem(newProduct)}>\n        添加商品\n      </button>\n    </div>\n  );\n});\n```\n\n## 第四章：江湖对决——Redux vs MobX\n\n好了，两位大侠的绝学都展示完了，让我们来个正面对决：\n\n### 学习曲线\n\n**Redux**：就像学开手动挡汽车，一开始各种熄火，但学会了你就是老司机。\n\n- Action、Reducer、Store、Middleware... 概念一大堆\n- 必须理解函数式编程思想\n- 代码量多（这也叫 boilerplate）\n\n**MobX**：像自动挡，上手就能开，但你可能不知道变速箱怎么工作的。\n\n- 面向对象，符合直觉\n- 装饰器语法很优雅\n- 代码量少\n\n### 可预测性\n\n**Redux**：\n\n```javascript\n// Redux 的每一步都有迹可循\ndispatch(action) → reducer → new state → UI update\n// 时间旅行调试，可以回放每个 action\n```\n\n**MobX**：\n\n```javascript\n// MobX 的更新是自动的，有时候像黑魔法\nobservable.value = newValue → ??? → UI update\n// 调试时可能会想：\"咦，这咋就更新了？\"\n```\n\n### 性能优化\n\n**Redux**：\n\n- 需要手动优化（useSelector、reselect 等）\n- 容易产生不必要的渲染\n- 但优化后性能很好\n\n**MobX**：\n\n- 自动优化，只更新真正需要更新的组件\n- 细粒度的响应式更新\n- 开箱即用的好性能\n\n### 使用场景\n\n**选 Redux 的场景**：\n\n- 大型应用，需要严格的数据流\n- 团队协作，需要统一的规范\n- 需要时间旅行调试\n- 需要持久化、同步等高级功能\n\n**选 MobX 的场景**：\n\n- 中小型应用，追求开发效率\n- 有很多派生状态（computed）\n- 团队熟悉面向对象编程\n- 不想写太多样板代码\n\n## 第五章：实战技巧与注意事项\n\n### Redux 的坑与技巧\n\n1. **不可变更新的坑**：\n\n```javascript\n// ❌ 错误：直接修改\nstate.items.push(newItem);\n\n// ✅ 正确：返回新对象\nreturn {\n  ...state,\n  items: [...state.items, newItem]\n};\n\n// 💡 技巧：使用 Immer 简化不可变更新\nimport produce from 'immer';\n\nconst reducer = produce((draft, action) => {\n  // 现在可以直接修改 draft\n  draft.items.push(action.payload);\n});\n```\n\n1. **异步处理**：\n\n```javascript\n// 使用 Redux Thunk 处理异步\nconst fetchUserData = (userId) => async (dispatch) => {\n  dispatch({ type: 'FETCH_START' });\n  try {\n    const data = await api.getUser(userId);\n    dispatch({ type: 'FETCH_SUCCESS', payload: data });\n  } catch (error) {\n    dispatch({ type: 'FETCH_ERROR', payload: error });\n  }\n};\n```\n\n### MobX 的坑与技巧\n\n1. **观察数组和对象**：\n\n```javascript\n// ⚠️ 注意：MobX 4/5 需要使用 observable 数组的方法\nclass Store {\n  @observable items = [];\n  \n  @action addItem(item) {\n    // ✅ 这样会触发更新\n    this.items.push(item);\n    \n    // ❌ 这样不会触发更新（MobX 4/5）\n    // this.items[this.items.length] = item;\n  }\n}\n```\n\n1. **避免过度使用 computed**：\n\n```javascript\nclass Store {\n  @observable users = [];\n  \n  // ✅ 好的 computed：有复杂计算\n  @computed get activeUsers() {\n    return this.users.filter(u => u.isActive && u.lastLogin > someDate);\n  }\n  \n  // ❌ 不必要的 computed：太简单了\n  @computed get userCount() {\n    return this.users.length; // 直接用 users.length 就行\n  }\n}\n```\n\n## 第六章：2024 年的新趋势\n\n### Redux Toolkit —— Redux 的现代化改造\n\nRedux 听到了大家的抱怨，推出了 Redux Toolkit (RTK)：\n\n```javascript\nimport { createSlice } from '@reduxjs/toolkit';\n\n// 一个 slice 搞定 actions + reducer\nconst cartSlice = createSlice({\n  name: 'cart',\n  initialState: [],\n  reducers: {\n    addItem: (state, action) => {\n      // 可以直接修改！RTK 内置了 Immer\n      state.push(action.payload);\n    },\n    removeItem: (state, action) => {\n      return state.filter(item => item.id !== action.payload);\n    }\n  }\n});\n\nexport const { addItem, removeItem } = cartSlice.actions;\nexport default cartSlice.reducer;\n```\n\n### MobX 6 的新特性\n\nMobX 6 带来了更简洁的 API：\n\n```javascript\nimport { makeAutoObservable } from 'mobx';\n\nclass Store {\n  items = [];\n  \n  constructor() {\n    // 自动将所有属性和方法变成 observable/action\n    makeAutoObservable(this);\n  }\n  \n  addItem(item) {\n    this.items.push(item);\n  }\n}\n```\n\n## 第七章：面试高频问题\n\n### 面试官：Redux 的中间件原理是什么？\n\n**你的回答**：中间件就像快递的中转站，action 在到达 reducer 之前会经过中间件处理：\n\n```javascript\n// 中间件的本质是函数组合\nconst middleware = store => next => action => {\n  console.log('dispatching', action);\n  const result = next(action); // 调用下一个中间件\n  console.log('next state', store.getState());\n  return result;\n};\n```\n\n### 面试官：MobX 和 Vue 的响应式有什么区别？\n\n**你的回答**：\n\n- Vue 2：使用 Object.defineProperty，需要预定义属性\n- Vue 3 和 MobX：都使用 Proxy，可以动态添加属性\n- MobX 是显式声明（makeObservable），Vue 是自动的（data 函数）\n\n## 结语：没有银弹，只有权衡\n\n记住，Redux 和 MobX 都是工具，没有绝对的好坏。就像金庸小说里，降龙十八掌刚猛无比，凌波微步飘逸灵动，关键看你要打什么怪。\n\n**给秋招的你一些建议**：\n\n1. 两个都要了解，但精通一个就够了\n2. 理解原理比会用 API 更重要\n3. 项目中遇到状态管理的痛点，才能真正理解这些工具的价值\n4. 面试时能讲清楚权衡（trade-off）比死记硬背更加分\n\n最后，祝你秋招顺利，offer 拿到手软！记住，技术只是工具，解决问题的思维才是核心竞争力。\n\n------\n\n*P.S. 如果这篇文章对你有帮助，记得给未来的同事们也分享一下。毕竟，独乐乐不如众乐乐，一起进步才是真的进步！*\n","tags":["React","秋招","Redux","Mobx"],"categories":["秋招准备"]},{"title":"【从项目到技术】SPA vs MPA 深度分析","url":"/2025/08/13/【从项目到技术】SPA vs MPA 深度分析/","content":"\n2024-2025年前端架构正经历重要转型，开发者正从传统的\"JavaScript优先\"模式转向更平衡的性能导向解决方案。本报告基于最新行业数据和技术发展，为React开发者提供架构选择的全面指导。\n\n## SPA疲劳与架构文艺复兴\n\n当前前端社区正经历所谓的\"SPA疲劳\"现象。虽然单页应用仍占据90%的使用率，但开发者越来越意识到其性能和复杂性成本。行业整体趋势是\"**更多依赖服务器，向浏览器发送更少JavaScript，减少UI渲染请求，更快地打包代码**\"，这代表了从客户端重型向服务器重型架构的根本性转变。\n\n关键的变化是混合方法的兴起，而非简单的SPA或MPA二选一。开发者采用岛屿架构（Islands Architecture）进行选择性水合、服务器端渲染配合客户端增强、以及静态站点生成与动态元素的结合。\n\n## 电商平台中的SPA vs MPA架构对比\n\n### 架构优势分析\n\n**SPA在电商中的优势：**\n\n- **流畅的用户体验**：无刷新页面转换，类似原生应用的交互\n- **卓越的移动端性能**：对于移动电商至关重要\n- **动态筛选搜索**：即时产品筛选、排序和搜索功能\n- **实时功能支持**：购物车更新、库存状态、价格变化\n- **减少服务器负载**：初始加载后仅需获取数据(JSON)\n\n**MPA在电商中的优势：**\n\n- **卓越的SEO表现**：每个页面都有独特URL、元数据和内容，易于搜索引擎索引\n- **更快的初始加载**：仅加载当前页面所需资源\n- **更好的浏览器兼容性**：适用于所有设备，包括旧版浏览器\n- **独立页面优化**：每个产品/类目页面可单独优化\n- **成熟的安全模型**：服务器端渲染提供传统、易理解的安全模式\n\n### 不同页面类型的架构选择建议\n\n**商品列表/类目页面** **推荐：混合MPA + SPA组件**\n\n- 基础结构使用MPA以获得SEO优势和易于索引\n- 筛选、排序、分页功能采用SPA组件\n- 搜索引擎可以爬取类目结构，用户获得流畅的筛选体验\n\n**商品详情页(PDP)** **推荐：MPA + 交互式组件**\n\n- 服务器渲染页面确保SEO和快速加载\n- 图片画廊、评论、加购功能使用JavaScript增强\n- 每个产品需要独立URL、元数据和结构化数据\n\n**购物车功能** **推荐：MPA框架内的SPA组件**\n\n- 购物车更新需要无刷新实时更新以确保用户体验\n- 实施策略：乐观更新配合服务器验证的混合方法\n\n**结账支付流程** **强烈推荐：MPA架构**\n\n- 分步导航的传统多页面结账可减少放弃率\n- 服务器端渲染对支付处理至关重要\n- 基于页面的方法更适合处理支付失败\n- 客户期望传统结账流程以建立信任感\n\n**用户账户页面** **推荐：SPA架构**\n\n- 用户期望账户管理具有类似应用的界面\n- 订单状态、偏好设置、愿望清单变化受益于SPA模式\n- 账户页面通常不被搜索引擎索引，SEO优先级较低\n\n## React开发者的MPA架构选择时机\n\n### 选择MPA的关键场景\n\n**应选择MPA架构当：**\n\n- **SEO至关重要**：内容为主的网站、博客、营销站点\n- **首屏加载速度优先**：MPA的首字节时间(TTFB)和首次内容绘制(FCP)更快\n- **JavaScript需求有限**：交互性不强的网站无需复杂客户端状态管理\n- **渐进增强方法**：核心功能需要在无JavaScript环境下工作\n- **大规模产品目录**：需要优秀SEO表现的电商平台\n\n**仍选择SPA架构当：**\n\n- **高交互性需求**：仪表板、管理面板、实时应用\n- **类应用体验**：流畅导航、跨视图共享状态\n- **复杂客户端逻辑**：繁重状态管理、实时更新\n\n### 性能指标对比\n\n基于2024年基准测试数据：\n\n- **服务器端渲染性能**：Svelte(1,641 req/s) > Vue(1,139 req/s) > React(572 req/s)\n- **MPA优势**：更好的SEO索引、更快的初始页面加载、更小的JavaScript包大小\n- **SPA优势**：更流畅的导航、初始加载后更好的感知性能、共享状态管理\n\n## 适合React开发者的MPA框架工具对比\n\n### Next.js：市场领导者\n\n**技术规格：**\n\n- **渲染方式**：SSR、SSG、ISR、客户端渲染支持\n- **路由系统**：基于文件的路由（Pages Router vs App Router）\n- **性能特性**：React Server Components、Turbopack打包\n- **市场采用率**：在State of JS 2024中保持52.9%的采用率\n\n**App Router vs Pages Router：**\n\n- **App Router（推荐）**：默认使用React Server Components，基于文件夹的路由，更好的性能但学习曲线更陡\n- **Pages Router（遗留）**：基于文件的路由，更简单的迁移路径但不再推荐\n\n### SvelteKit：性能冠军\n\n**技术规格：**\n\n- **性能优势**：编译时优化，无虚拟DOM开销，更小的JavaScript包\n- **开发体验**：基于文件的路由，内置TypeScript支持\n- **兴趣度**：43.6%的开发者有兴趣学习SvelteKit\n- **核心Web生命力指标**表现优秀\n\n### Astro：内容优先架构\n\n**关键特性：**\n\n- **哲学**：内容优先，默认零JavaScript\n- **岛屿架构**：选择性水合交互式组件\n- **框架无关**：支持React、Vue、Svelte组件\n- **增长数据**：尽管是新框架，但已获得25%的采用率\n\n**代码示例：**\n\n```javascript\n// Astro组件与岛屿水合\n---\nimport { getCollection } from 'astro:content';\nimport BlogPost from '../components/BlogPost.astro';\n\nconst posts = await getCollection('blog');\n---\n\n<html>\n  <body>\n    {posts.map(post => \n      <BlogPost \n        post={post} \n        client:visible \n      />\n    )}\n  </body>\n</html>\n```\n\n### Fresh (Deno)：边缘原生框架\n\n**技术规格：**\n\n- **运行时**：Deno原生，内置TypeScript支持\n- **架构**：基于岛屿的Preact组件\n- **边缘计算**：专为边缘部署构建\n- **即时渲染**：零配置，实时编译\n\n## Remix框架深度分析\n\n### 重大更新：Remix转化为React Router v7\n\n**2024年12月重大变更**：Remix已演进为React Router v7。Remix团队将Remix功能合并到React Router中，使React Router v7成为Remix v2的继任者。这代表了React生态系统的重要整合。\n\n### 核心架构与哲学\n\n**四大支柱**：\n\n1. **拥抱服务器/客户端模型**：源代码与内容/数据分离\n2. **使用Web标准**：利用浏览器、HTTP和HTML基础\n3. **用JavaScript增强**：模拟而非替代浏览器行为\n4. **渐进增强**：应用在无JavaScript情况下工作，有JavaScript时增强\n\n**设计原则：**\n\n- **UI为中心的路由**：专注于UI组件和布局而非模型\n- **Web标准优先**：基于Web Fetch API，支持HTTP缓存\n- **\"中心栈\"方法**：融合传统(Web标准)和现代(React)开发模式\n\n### 与Next.js的详细对比\n\n| 方面         | Remix/React Router v7        | Next.js                            |\n| ------------ | ---------------------------- | ---------------------------------- |\n| **架构**     | 服务器优先，Web标准          | 混合(SSG/SSR/CSR)                  |\n| **渲染**     | SSR + 渐进增强               | SSG、SSR、ISR、CSR                 |\n| **数据获取** | Loaders(服务器) + 客户端水合 | getStaticProps、getServerSideProps |\n| **路由**     | 嵌套的，基于URL段            | 基于文件的pages目录                |\n| **表单处理** | 原生HTML表单增强             | 需要JavaScript的方法               |\n| **标准聚焦** | Web Fetch API、HTTP标准      | Node.js生态集成                    |\n\n**性能特征：**\n\n- **Remix优势**：通过SSR更快的动态内容传递，减少客户端JavaScript包大小，并行数据加载，慢网络下更好的性能\n- **Next.js优势**：SSG的卓越静态站点性能，开箱即用的图像优化，增量静态再生成(ISR)\n\n### 适用场景\n\n**选择Remix/React Router v7当：**\n\n- 动态数据密集型应用\n- 需要强SEO的电商网站\n- 仪表板和管理应用\n- 重视渐进增强的应用\n\n**选择Next.js当：**\n\n- 静态或大部分静态的网站\n- 内容密集型网站和博客\n- 需要广泛静态优化的应用\n- 需要成熟生态支持的团队\n\n## 首屏加载性能优化策略\n\n### SPA优化策略\n\n**服务器端渲染(SSR)实现：**\n\n- 传递初始HTML以启用浏览器资源加载优化\n- 防止在客户端渲染应用中出现的后期资产发现\n- 使用React 18的流式SSR与Suspense边界\n\n**渐进式水合策略：**\n\n```javascript\n// 空闲直到紧急模式实现\nconst EnhancedComponent = withIdleRender(MyComponent);\n// 在浏览器空闲时间或用户交互时水合组件\n```\n\n**性能影响：**\n\n- Cdiscount通过渐进式水合实现45%的初始水合成本降低(128ms降至70ms)\n- 首次输入延迟降低50%+\n- 关键首屏内容更早实现交互性\n\n**捆绑包大小优化：**\n\n- 基于路由的代码分割(最有效的第一步)\n- 基于组件的分割(适用于很少使用的功能，>100KB阈值)\n- 弹窗/模态框分割(按需加载)\n- 基于特性的分割(不同功能的独立块)\n\n### MPA优化策略\n\n**缓存策略：**\n\n- 带内容哈希的静态资源长期缓存(推荐1年)\n- HTML页面短TTL(推荐60秒)\n- 利用浏览器缓存进行后续页面加载\n\n**CDN实现：**\n\n- 静态资源的边缘缓存\n- 地理分布减少延迟\n- Gzip/Brotli压缩(可实现70%+文件大小缩减)\n\n**资源优化：**\n\n- 最小化阻塞CSS和JavaScript\n- 实现关键CSS内联\n- 使用现代图像格式和响应式图片\n- 使用WOFF2和font-display: swap优化字体加载\n\n### 混合架构优化\n\n**PESPA(渐进增强SPA)方法：**\n\n- Next.js应用与SSG/SSR\n- 带选择性交互的Astro\n- 岛屿架构(Qwik、Fresh)\n- 带客户端水合的服务器组件\n\n## 2024-2025前端架构趋势\n\n### 岛屿架构的崛起\n\n**定义与概念**：岛屿架构旨在通过在静态HTML之上独立交付的\"交互岛屿\"来减少发送的JavaScript量。\n\n**关键优势：**\n\n- **性能**：相比传统框架JavaScript代码减少83%\n- **SEO友好**：服务器渲染的静态内容\n- **渐进增强**：关键内容立即加载，交互性逐步加载\n- **独立性**：每个岛屿独立水合，防止级联故障\n\n### 开发者情绪与采用趋势\n\n**State of JavaScript 2024结果：**\n\n- **React**：保持69.9%使用率但增长放缓\n- **Next.js**：在元框架中52.9%采用率\n- **SvelteKit**：兴趣上升(43.6%想学习)\n- **Astro**：新框架取得25%采用率令人印象深刻\n\n### 企业采用模式\n\n**大规模架构决策：**\n\n- 企业越来越多采用微前端架构实现独立团队开发、技术多样性、可扩展性\n- Backend-for-Frontend(BFF)模式为公司级推荐，以赋能前端团队、降低API复杂性\n\n**技术偏好：**\n\n- 成熟生态系统(React、Angular)\n- 长期支持保证\n- 广泛工具和文档\n- 强大社区支持\n\n### 未来预测(2025-2027)\n\n**短期趋势：**\n\n- **岛屿架构主流采用**：预计成为内容密集型网站的标准模式\n- **AI增强开发**：76%开发者计划使用AI工具进行代码生成、性能优化、自动测试\n- **WebAssembly集成**：用于高性能计算、遗留系统集成\n\n**中期演进：**\n\n- **边缘计算集成**：前端架构将更多利用边缘计算实现减少延迟、边缘服务器端渲染\n- **组件流式传输**：从服务器到客户端的细粒度组件流式传输演进\n\n## 实施建议与最佳实践\n\n### 架构选择决策框架\n\n| 使用场景       | 推荐框架        | 备选方案     |\n| -------------- | --------------- | ------------ |\n| 内容密集型网站 | Astro           | Next.js SSG  |\n| 电商平台       | Next.js         | SvelteKit    |\n| 营销网站       | Astro           | SvelteKit    |\n| 文档站点       | Astro           | Next.js      |\n| 管理面板       | Next.js SPA模式 | Remix        |\n| 博客           | Astro           | Next.js      |\n| 企业应用       | Next.js         | Remix        |\n| 性能关键应用   | SvelteKit       | Astro        |\n| 边缘计算       | Fresh           | Next.js Edge |\n\n### 迁移策略\n\n**SPA到MPA迁移方法：**\n\n1. **评估阶段**：分析当前SPA结构，识别静态页面、动态页面、交互部分\n2. **增量迁移**：从静态页面开始，迁移内容密集型部分，保持高交互部分为SPA岛屿\n3. **优化阶段**：实现渐进式水合、优化关键渲染路径、添加性能监控\n\n### 性能优化最佳实践\n\n**Core Web Vitals优化：**\n\n- **最大内容绘制(LCP)**：使用适当渲染策略(SSG > SSR > CSR)、优化图片、实现资源优先级\n- **首次输入延迟(FID)**：渐进式水合策略、代码分割和懒加载\n- **累积布局偏移(CLS)**：为动态内容预留空间、使用骨架屏\n\n### 框架特定优化\n\n**Next.js优化：**\n\n```javascript\n// 图片优化\nimport Image from 'next/image';\n\n// 路由预取\nimport Link from 'next/link';\n<Link href=\"/blog\" prefetch={true}>\n\n// 动态导入\nconst DynamicComponent = dynamic(() => import('../components/Heavy'));\n```\n\n**Astro优化：**\n\n```javascript\n// 选择性水合的组件岛屿\n<Counter client:visible />\n<SearchBox client:media=\"(max-width: 800px)\" />\n<Chart client:idle />\n```\n\n## 结论与展望\n\n2024-2025年的前端架构格局以成熟和实用主义为特征，而非革命性变化。行业正在从\"JavaScript优先\"方法转向平衡解决方案，优先考虑性能、开发体验和用户需求。岛屿架构代表了最重要的新模式，为传统SPA/MPA二分法提供了引人注目的替代方案。\n\n**关键建议：**\n\n1. **对于企业团队**：评估岛屿架构用于内容密集型应用，投资元框架减少复杂性，优先考虑性能监控和优化\n2. **对于个人开发者**：学习岛屿概念和渐进增强，掌握现代构建工具如Vite，保持框架无关的思维\n3. **技术选择准则**：不要选择单一方法，而是为每个特定用例选择正确的架构模式\n\n前端架构的未来不在于选择单一方法，而在于为每个特定用例选择合适的架构模式，岛屿架构为开发者工具包提供了强大的新选择。这种架构演进为组织提供了采用经过验证的全栈模式、降低依赖复杂性、改善应用性能、投资长期Web标准知识的机会。\n","tags":["React","前端开发","SSR","MPA"],"categories":["从项目到技术"]},{"title":"【秋招备战】 Object.defineProperty vs Proxy","url":"/2025/08/07/【秋招备战】属性劫持/","content":"\n>  如果你曾经好奇 Vue2 和 Vue3 的响应式原理有什么区别，或者在面试中被问到\"如何实现数据劫持\"时一脸懵逼，那么恭喜你，这篇文章就是你的救星！\n\n## 📖 开篇：一个对象的自我修养\n\n在 JavaScript 的世界里，对象就像是一个个小盒子，我们可以往里面放东西（属性），也可以取东西。但是有一天，产品经理突然说：\"我想知道用户什么时候打开盒子，什么时候往里面放东西！\"\n\n这时候，`Object.defineProperty` 和 `Proxy` 就闪亮登场了——它们就是对象世界的\"监控摄像头\"。\n\n## 🎭 第一幕：Object.defineProperty - 老牌特工\n\n### 基本概念\n\n`Object.defineProperty()` 是 ES5 引入的方法，它可以精确地定义或修改对象的属性，并且可以控制属性的行为。就像给对象的某个属性装上了一个\"智能锁\"。\n\n### 基础语法\n\n```javascript\nObject.defineProperty(obj, prop, descriptor)\n```\n\n- `obj`：要定义属性的对象\n- `prop`：要定义或修改的属性名\n- `descriptor`：属性描述符对象\n\n### 属性描述符的两种形态\n\n属性描述符分为两种：**数据描述符**和**存取描述符**（不能同时使用）。\n\n#### 1. 数据描述符\n\n```javascript\nconst person = {};\n\nObject.defineProperty(person, 'name', {\n  value: '张三',           // 属性值\n  writable: true,         // 是否可写（默认 false）\n  enumerable: true,       // 是否可枚举（默认 false）\n  configurable: true      // 是否可配置（默认 false）\n});\n\nconsole.log(person.name); // 张三\nperson.name = '李四';      // 因为 writable: true，所以可以修改\nconsole.log(person.name); // 李四\n```\n\n#### 2. 存取描述符（重点！）\n\n这就是实现\"数据劫持\"的核心：\n\n```javascript\nlet internalValue = '我是内部值';\nconst obj = {};\n\nObject.defineProperty(obj, 'magicProp', {\n  enumerable: true,\n  configurable: true,\n  get() {\n    console.log('🔍 有人在读取 magicProp！');\n    return internalValue;\n  },\n  set(newValue) {\n    console.log(`✏️ 有人在设置 magicProp 为: ${newValue}`);\n    internalValue = newValue;\n  }\n});\n\nobj.magicProp;           // 🔍 有人在读取 magicProp！\nobj.magicProp = '新值';   // ✏️ 有人在设置 magicProp 为: 新值\n```\n\n### 实战案例：简易版 Vue2 响应式\n\n```javascript\n// 模拟 Vue2 的响应式原理\nfunction observe(obj) {\n  Object.keys(obj).forEach(key => {\n    let internalValue = obj[key];\n    \n    Object.defineProperty(obj, key, {\n      get() {\n        console.log(`📊 收集依赖: ${key}`);\n        return internalValue;\n      },\n      set(newValue) {\n        console.log(`🔄 触发更新: ${key} = ${newValue}`);\n        internalValue = newValue;\n        // 这里可以触发视图更新\n      }\n    });\n  });\n}\n\nconst data = { count: 0, message: 'Hello' };\nobserve(data);\n\ndata.count;        // 📊 收集依赖: count\ndata.count = 1;    // 🔄 触发更新: count = 1\n```\n\n### Object.defineProperty 的局限性\n\n1. **无法监听数组索引的变化**\n\n```javascript\nconst arr = [1, 2, 3];\nobserve(arr);\narr[0] = 999;  // 无法触发 setter\narr.push(4);   // 无法监听\n```\n\n1. **必须遍历对象的每个属性**\n\n```javascript\n// 如果有嵌套对象，需要递归处理\nconst complexObj = {\n  user: {\n    name: '张三',\n    address: {\n      city: '北京'\n    }\n  }\n};\n// 需要递归遍历所有层级\n```\n\n1. **无法监听新增属性**\n\n```javascript\nconst obj = { a: 1 };\nobserve(obj);\nobj.b = 2;  // 新增属性 b 不会被监听\n```\n\n## 🦸 第二幕：Proxy - 新时代的全能管家\n\n### 基本概念\n\n`Proxy` 是 ES6 引入的新特性，它可以创建一个对象的代理，从而实现对这个对象的基本操作的拦截和自定义。如果说 `Object.defineProperty` 是给属性装监控，那 `Proxy` 就是给整个对象配了一个全能管家。\n\n### 基础语法\n\n```javascript\nconst proxy = new Proxy(target, handler)\n```\n\n- `target`：要代理的目标对象\n- `handler`：一个对象，定义了各种拦截行为\n\n### 13 种拦截方法\n\nProxy 支持拦截 13 种操作，常用的有：\n\n```javascript\nconst handler = {\n  get(target, property, receiver) {},      // 读取属性\n  set(target, property, value, receiver) {}, // 设置属性\n  has(target, property) {},                // in 操作符\n  deleteProperty(target, property) {},     // delete 操作\n  ownKeys(target) {},                      // Object.keys()\n  // ... 还有其他拦截方法\n};\n```\n\n### 基础示例\n\n```javascript\nconst person = {\n  name: '张三',\n  age: 25\n};\n\nconst personProxy = new Proxy(person, {\n  get(target, property) {\n    console.log(`🔍 正在访问属性: ${property}`);\n    return target[property];\n  },\n  set(target, property, value) {\n    console.log(`✏️ 正在设置属性: ${property} = ${value}`);\n    target[property] = value;\n    return true;  // 表示设置成功\n  }\n});\n\npersonProxy.name;           // 🔍 正在访问属性: name\npersonProxy.age = 26;       // ✏️ 正在设置属性: age = 26\npersonProxy.hobby = '编程';  // ✏️ 正在设置属性: hobby = 编程（新属性也能监听！）\n```\n\n### 高级应用：数组的完美监听\n\n```javascript\nconst arr = [1, 2, 3];\nconst arrProxy = new Proxy(arr, {\n  get(target, property) {\n    console.log(`访问数组: arr[${property}]`);\n    return target[property];\n  },\n  set(target, property, value) {\n    console.log(`修改数组: arr[${property}] = ${value}`);\n    target[property] = value;\n    return true;\n  }\n});\n\narrProxy[0] = 999;    // 修改数组: arr[0] = 999\narrProxy.push(4);     // 访问数组: arr[push]\n                      // 访问数组: arr[length]\n                      // 修改数组: arr[3] = 4\n                      // 修改数组: arr[length] = 4\n```\n\n### 实战案例：实现一个智能对象\n\n```javascript\n// 创建一个\"智能\"对象，自动验证和转换数据\nconst smartObj = new Proxy({}, {\n  set(target, property, value) {\n    // 自动类型转换\n    if (property === 'age') {\n      value = Number(value);\n      if (isNaN(value) || value < 0 || value > 150) {\n        throw new Error('年龄必须是 0-150 之间的数字');\n      }\n    }\n    \n    // 自动格式化\n    if (property === 'phone') {\n      value = value.replace(/[^0-9]/g, '');\n      if (value.length !== 11) {\n        throw new Error('手机号必须是 11 位');\n      }\n    }\n    \n    console.log(`✅ 设置 ${property} = ${value}`);\n    target[property] = value;\n    return true;\n  }\n});\n\nsmartObj.age = '25';        // ✅ 设置 age = 25（自动转数字）\nsmartObj.phone = '138-0000-0000'; // ✅ 设置 phone = 13800000000（自动格式化）\n// smartObj.age = '一百岁';  // 抛出错误！\n```\n\n## ⚔️ 终极对决：Object.defineProperty vs Proxy\n\n| 特性         | Object.defineProperty  | Proxy                  |\n| ------------ | ---------------------- | ---------------------- |\n| 兼容性       | ES5，兼容 IE9+         | ES6，不支持 IE         |\n| 监听范围     | 单个属性               | 整个对象               |\n| 监听数组索引 | ❌ 不支持               | ✅ 支持                 |\n| 监听新增属性 | ❌ 需要额外处理         | ✅ 自动支持             |\n| 监听删除属性 | ❌ 不支持               | ✅ 支持                 |\n| 性能         | 需要递归遍历，初始化慢 | 懒处理，按需拦截       |\n| 操作原对象   | 直接修改原对象         | 不修改原对象，返回代理 |\n\n## 🎯 面试高频考点\n\n### 1. Vue2 vs Vue3 响应式原理\n\n```javascript\n// Vue2 风格（简化版）\nfunction reactive2(obj) {\n  Object.keys(obj).forEach(key => {\n    let value = obj[key];\n    Object.defineProperty(obj, key, {\n      get() {\n        // 依赖收集\n        return value;\n      },\n      set(newValue) {\n        value = newValue;\n        // 触发更新\n      }\n    });\n  });\n  return obj;\n}\n\n// Vue3 风格（简化版）\nfunction reactive3(obj) {\n  return new Proxy(obj, {\n    get(target, key) {\n      // 依赖收集\n      return target[key];\n    },\n    set(target, key, value) {\n      target[key] = value;\n      // 触发更新\n      return true;\n    }\n  });\n}\n```\n\n### 2. 如何实现一个简单的观察者模式？\n\n```javascript\nclass Observer {\n  constructor(data) {\n    this.data = data;\n    this.callbacks = {};\n    this.observe();\n  }\n  \n  observe() {\n    const that = this;\n    this.proxy = new Proxy(this.data, {\n      set(target, property, value) {\n        target[property] = value;\n        // 触发回调\n        if (that.callbacks[property]) {\n          that.callbacks[property].forEach(cb => cb(value));\n        }\n        return true;\n      }\n    });\n    return this.proxy;\n  }\n  \n  subscribe(property, callback) {\n    if (!this.callbacks[property]) {\n      this.callbacks[property] = [];\n    }\n    this.callbacks[property].push(callback);\n  }\n}\n\n// 使用\nconst obs = new Observer({ count: 0 });\nconst data = obs.observe();\n\nobs.subscribe('count', (value) => {\n  console.log(`count 变化了: ${value}`);\n});\n\ndata.count = 1;  // count 变化了: 1\n```\n\n## 🚀 总结：选择的智慧\n\n- **使用 Object.defineProperty 的场景**：\n  - 需要兼容旧浏览器（IE9+）\n  - 只需要监听已知的、固定的属性\n  - 项目已经大量使用且稳定运行\n- **使用 Proxy 的场景**：\n  - 不需要考虑 IE 兼容性\n  - 需要监听数组变化\n  - 需要监听动态新增的属性\n  - 需要实现更复杂的拦截逻辑\n  - 新项目优先选择\n\n## 💡 最后的小贴士\n\n记住这个口诀：\n\n- **defineProperty 是保安**：只能看着指定的几个门（属性）\n- **Proxy 是管家**：整个房子（对象）的事都管\n\n面试时如果被问到，记得提到：\n\n1. 两者的本质区别（属性级 vs 对象级）\n2. Vue2 到 Vue3 的升级原因\n3. 各自的优缺点和适用场景\n\n现在，你已经掌握了 JavaScript 中两个最强大的\"对象监控\"技术。下次面试官问你\"如何实现数据双向绑定\"时，你可以自信地说：\"这题我会，而且我还能告诉你两种方法的优缺点！\"\n\n------\n\n*Happy Coding! 愿你的秋招之路一帆风顺！* 🎉\n","tags":["秋招","ES","八股"],"categories":["秋招准备"]},{"title":"【秋招备战】JavaScript 集合类型深度解析","url":"/2025/08/05/【秋招备战】JavaScript 集合类型深度解析/","content":"\n在 JavaScript 的世界里，除了我们熟悉的对象（Object）和数组（Array），ES6 还引入了四种新的集合类型：Map、Set、WeakMap 和 WeakSet。这些数据结构不仅丰富了我们的工具箱，更是在现代前端框架的底层实现中扮演着重要角色。今天，让我们深入探讨这些集合类型的特性、使用场景，以及它们在 React 和 Vue 源码中的精妙应用。\n\n## 一、Map：更强大的键值对集合\n\n### 基本概念\n\nMap 是一个键值对的集合，与普通对象最大的区别在于：**Map 的键可以是任意类型**，而不仅仅是字符串或 Symbol。\n\n```javascript\nconst map = new Map();\n\n// 基本用法\nmap.set('name', 'JavaScript');\nmap.set(42, 'The Answer');\nmap.set(true, 'Boolean key');\n\n// 对象作为键\nconst objKey = { id: 1 };\nmap.set(objKey, 'Object as key');\n\n// 函数作为键\nconst funcKey = () => {};\nmap.set(funcKey, 'Function as key');\n\nconsole.log(map.get(objKey)); // 'Object as key'\nconsole.log(map.size); // 5\n```\n\n### Map 的核心特性\n\n1. **键的唯一性**：Map 中的键是唯一的，重复设置会覆盖之前的值\n2. **保持插入顺序**：Map 会记住键值对的插入顺序\n3. **可迭代**：Map 实现了迭代器协议\n\n```javascript\nconst map = new Map([\n  ['first', 1],\n  ['second', 2],\n  ['third', 3]\n]);\n\n// 遍历方法\nfor (const [key, value] of map) {\n  console.log(`${key}: ${value}`);\n}\n\n// 获取所有键\nconsole.log([...map.keys()]); // ['first', 'second', 'third']\n\n// 获取所有值\nconsole.log([...map.values()]); // [1, 2, 3]\n\n// 获取所有键值对\nconsole.log([...map.entries()]); // [['first', 1], ['second', 2], ['third', 3]]\n```\n\n### Map vs Object 的性能对比\n\n```javascript\n// 性能测试：频繁增删操作\nconst testSize = 100000;\n\n// Object 测试\nconsole.time('Object');\nconst obj = {};\nfor (let i = 0; i < testSize; i++) {\n  obj[`key${i}`] = i;\n  delete obj[`key${i}`];\n}\nconsole.timeEnd('Object');\n\n// Map 测试\nconsole.time('Map');\nconst map = new Map();\nfor (let i = 0; i < testSize; i++) {\n  map.set(`key${i}`, i);\n  map.delete(`key${i}`);\n}\nconsole.timeEnd('Map');\n\n\n// Object: 40.439ms\n// Map: 15.457ms\n// Map 在频繁增删操作时性能更优\n```\n\n### 实际应用场景\n\n```javascript\n// 缓存管理\nclass LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();\n  }\n\n  get(key) {\n    if (!this.cache.has(key)) return -1;\n    \n    // 将访问的元素移到最后（最新）\n    const value = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, value);\n    return value;\n  }\n\n  put(key, value) {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    }\n    \n    this.cache.set(key, value);\n    \n    // 超出容量，删除最旧的（第一个）\n    if (this.cache.size > this.capacity) {\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n  }\n}\n```\n\n## 二、Set：独特值的集合\n\n### 基本概念\n\nSet 是一个值的集合，其中每个值都是唯一的，不会重复。\n\n```javascript\nconst set = new Set();\n\n// 添加值\nset.add(1);\nset.add(2);\nset.add(2); // 重复值不会被添加\nset.add('2'); // 字符串'2'和数字2是不同的\n\nconsole.log(set.size); // 3\nconsole.log(set.has(2)); // true\n\n// 数组去重\nconst numbers = [1, 2, 2, 3, 4, 4, 5];\nconst uniqueNumbers = [...new Set(numbers)];\nconsole.log(uniqueNumbers); // [1, 2, 3, 4, 5]\n```\n\n### Set 的高级应用\n\n```javascript\n// 1. 数组操作\nconst setA = new Set([1, 2, 3, 4]);\nconst setB = new Set([3, 4, 5, 6]);\n\n// 并集\nconst union = new Set([...setA, ...setB]);\nconsole.log([...union]); // [1, 2, 3, 4, 5, 6]\n\n// 交集\nconst intersection = new Set([...setA].filter(x => setB.has(x)));\nconsole.log([...intersection]); // [3, 4]\n\n// 差集\nconst difference = new Set([...setA].filter(x => !setB.has(x)));\nconsole.log([...difference]); // [1, 2]\n\n// 2. 对象去重\nconst users = [\n  { id: 1, name: 'Alice' },\n  { id: 2, name: 'Bob' },\n  { id: 1, name: 'Alice' },\n  { id: 3, name: 'Charlie' }\n];\n\nconst uniqueUsers = Array.from(\n  new Map(users.map(user => [user.id, user])).values()\n);\nconsole.log(uniqueUsers); // 去重后的用户数组\n```\n\n### 性能优势\n\n```javascript\n// Set 的 has 方法性能测试\nconst arr = Array.from({ length: 10000 }, (_, i) => i);\nconst set = new Set(arr);\n\nconsole.time('Array includes');\nfor (let i = 0; i < 1000; i++) {\n  arr.includes(9999);\n}\nconsole.timeEnd('Array includes');\n\nconsole.time('Set has');\nfor (let i = 0; i < 1000; i++) {\n  set.has(9999);\n}\nconsole.timeEnd('Set has');\n\n// Set.has() 的时间复杂度是 O(1)，而 Array.includes() 是 O(n)\n```\n\n## 三、WeakMap：弱引用的键值对集合\n\n### 核心特性\n\nWeakMap 与 Map 类似，但有几个关键区别：\n\n1. **键必须是对象**（不能是原始值）\n2. **键是弱引用的**，不会阻止垃圾回收\n3. **不可迭代**，没有 size 属性\n\n```javascript\nconst wm = new WeakMap();\n\n// 只能使用对象作为键\nconst obj1 = { name: 'object1' };\nconst obj2 = { name: 'object2' };\n\nwm.set(obj1, 'value1');\nwm.set(obj2, 'value2');\n\nconsole.log(wm.get(obj1)); // 'value1'\n\n// 不能使用原始值作为键\n// wm.set('string', 'value'); // TypeError\n\n// 弱引用特性\nlet obj3 = { name: 'object3' };\nwm.set(obj3, 'value3');\nobj3 = null; // obj3 可以被垃圾回收，对应的 WeakMap 条目也会被清除\n```\n\n### WeakMap 的实际应用\n\n```javascript\n// 1. 私有属性实现\nconst privateData = new WeakMap();\n\nclass Person {\n  constructor(name, age) {\n    privateData.set(this, { name, age });\n  }\n\n  getName() {\n    return privateData.get(this).name;\n  }\n\n  getAge() {\n    return privateData.get(this).age;\n  }\n}\n\nconst person = new Person('Alice', 30);\nconsole.log(person.getName()); // 'Alice'\nconsole.log(person.name); // undefined\n\n// 2. DOM 元素关联数据\nconst elementData = new WeakMap();\n\nfunction attachData(element, data) {\n  elementData.set(element, data);\n}\n\nfunction getData(element) {\n  return elementData.get(element);\n}\n\n// 使用\nconst button = document.querySelector('#myButton');\nattachData(button, { clickCount: 0 });\n\nbutton.addEventListener('click', () => {\n  const data = getData(button);\n  data.clickCount++;\n  console.log(`Clicked ${data.clickCount} times`);\n});\n```\n\n### 内存管理优势\n\n```javascript\n// 使用 Map 可能造成内存泄漏\nconst cache = new Map();\n\nfunction processData(obj) {\n  if (cache.has(obj)) {\n    return cache.get(obj);\n  }\n  \n  const result = expensiveOperation(obj);\n  cache.set(obj, result); // obj 被 Map 引用，无法被垃圾回收\n  return result;\n}\n\n// 使用 WeakMap 避免内存泄漏\nconst weakCache = new WeakMap();\n\nfunction processDataSafe(obj) {\n  if (weakCache.has(obj)) {\n    return weakCache.get(obj);\n  }\n  \n  const result = expensiveOperation(obj);\n  weakCache.set(obj, result); // obj 可以被正常垃圾回收\n  return result;\n}\n```\n\n## 四、WeakSet：弱引用的值集合\n\n### 基本特性\n\nWeakSet 与 Set 类似，但具有以下特点：\n\n1. **只能存储对象**\n2. **对象是弱引用的**\n3. **不可迭代**\n\n```javascript\nconst ws = new WeakSet();\n\nconst obj1 = { id: 1 };\nconst obj2 = { id: 2 };\n\nws.add(obj1);\nws.add(obj2);\n\nconsole.log(ws.has(obj1)); // true\n\n// 不能添加原始值\n// ws.add(1); // TypeError\n\n// 防止重复添加\nws.add(obj1); // 不会报错，但也不会重复添加\n```\n\n### 实际应用场景\n\n```javascript\n// 1. 标记对象状态\nconst disabledElements = new WeakSet();\n\nfunction disableElement(element) {\n  disabledElements.add(element);\n  element.classList.add('disabled');\n}\n\nfunction enableElement(element) {\n  disabledElements.delete(element);\n  element.classList.remove('disabled');\n}\n\nfunction isDisabled(element) {\n  return disabledElements.has(element);\n}\n\n// 2. 防止递归调用\nconst processing = new WeakSet();\n\nfunction processObject(obj) {\n  if (processing.has(obj)) {\n    console.log('Already processing this object');\n    return;\n  }\n  \n  processing.add(obj);\n  \n  try {\n    // 处理对象\n    console.log('Processing:', obj);\n    \n    // 如果对象有子对象，递归处理\n    if (obj.children) {\n      obj.children.forEach(child => processObject(child));\n    }\n  } finally {\n    processing.delete(obj);\n  }\n}\n```\n\n## 五、在 React 中的应用\n\n### React Fiber 中的 WeakMap 使用\n\nReact 的 Fiber 架构中使用 WeakMap 来存储组件相关的信息：\n\n```javascript\n// React 源码简化示例\nconst fiberNodeMap = new WeakMap();\n\nfunction createFiberNode(element) {\n  const fiber = {\n    type: element.type,\n    props: element.props,\n    // ... 其他 fiber 属性\n  };\n  \n  // 将 DOM 元素与 Fiber 节点关联\n  if (element.dom) {\n    fiberNodeMap.set(element.dom, fiber);\n  }\n  \n  return fiber;\n}\n\nfunction getFiberFromDOM(domElement) {\n  return fiberNodeMap.get(domElement);\n}\n```\n\n### React Hooks 中的 Map 应用\n\n```javascript\n// React Hooks 实现原理简化\nlet currentComponent = null;\nconst hooksMap = new Map();\n\nfunction useState(initialState) {\n  const component = currentComponent;\n  \n  if (!hooksMap.has(component)) {\n    hooksMap.set(component, []);\n  }\n  \n  const hooks = hooksMap.get(component);\n  const hookIndex = hooks.length;\n  \n  if (hooks[hookIndex] === undefined) {\n    hooks[hookIndex] = {\n      state: initialState,\n      setState: (newState) => {\n        hooks[hookIndex].state = newState;\n        reRender(component);\n      }\n    };\n  }\n  \n  return [hooks[hookIndex].state, hooks[hookIndex].setState];\n}\n```\n\n## 六、在 Vue 中的应用\n\n### Vue 3 响应式系统中的 WeakMap\n\nVue 3 的响应式系统大量使用了 WeakMap 来存储依赖关系：\n\n```javascript\n// Vue 3 响应式原理简化\nconst targetMap = new WeakMap();\n\nfunction track(target, key) {\n  let depsMap = targetMap.get(target);\n  if (!depsMap) {\n    targetMap.set(target, (depsMap = new Map()));\n  }\n  \n  let dep = depsMap.get(key);\n  if (!dep) {\n    depsMap.set(key, (dep = new Set()));\n  }\n  \n  dep.add(activeEffect);\n}\n\nfunction trigger(target, key) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) return;\n  \n  const dep = depsMap.get(key);\n  if (!dep) return;\n  \n  dep.forEach(effect => effect());\n}\n\n// 创建响应式对象\nfunction reactive(target) {\n  return new Proxy(target, {\n    get(target, key, receiver) {\n      track(target, key);\n      return Reflect.get(target, key, receiver);\n    },\n    set(target, key, value, receiver) {\n      const result = Reflect.set(target, key, value, receiver);\n      trigger(target, key);\n      return result;\n    }\n  });\n}\n```\n\n### Vue 组件实例管理\n\n```javascript\n// Vue 组件实例缓存\nconst instanceMap = new WeakMap();\n\nclass VueComponent {\n  constructor(options) {\n    this.options = options;\n    \n    // 将组件实例与其 DOM 元素关联\n    if (options.el) {\n      instanceMap.set(options.el, this);\n    }\n  }\n  \n  static getInstance(element) {\n    return instanceMap.get(element);\n  }\n}\n\n// KeepAlive 组件的缓存实现\nconst cache = new Map();\nconst keys = new Set();\n\nfunction pruneCache(keepAliveInstance, filter) {\n  cache.forEach((entry, key) => {\n    const name = getComponentName(entry.componentInstance);\n    if (name && !filter(name)) {\n      pruneCacheEntry(key);\n    }\n  });\n}\n\nfunction pruneCacheEntry(key) {\n  const cached = cache.get(key);\n  if (cached) {\n    cached.componentInstance.$destroy();\n  }\n  cache.delete(key);\n  keys.delete(key);\n}\n```\n\n## 七、性能优化最佳实践\n\n### 选择合适的数据结构\n\n```javascript\n// 场景1：需要频繁检查元素是否存在\n// ❌ 不推荐：使用数组\nconst permissions = ['read', 'write', 'delete'];\nif (permissions.includes('write')) { } // O(n)\n\n// ✅ 推荐：使用 Set\nconst permissionSet = new Set(['read', 'write', 'delete']);\nif (permissionSet.has('write')) { } // O(1)\n\n// 场景2：需要关联 DOM 元素和数据\n// ❌ 不推荐：使用 Map（可能造成内存泄漏）\nconst elementDataMap = new Map();\n\n// ✅ 推荐：使用 WeakMap\nconst elementDataWeakMap = new WeakMap();\n\n// 场景3：需要有序的键值对\n// ✅ Map 保持插入顺序\nconst orderedMap = new Map([\n  ['first', 1],\n  ['second', 2],\n  ['third', 3]\n]);\n```\n\n### 内存管理注意事项\n\n```javascript\n// 避免内存泄漏的模式\nclass EventManager {\n  constructor() {\n    // 使用 WeakMap 存储事件监听器\n    this.listeners = new WeakMap();\n  }\n  \n  addEventListener(element, event, handler) {\n    if (!this.listeners.has(element)) {\n      this.listeners.set(element, new Map());\n    }\n    \n    const elementListeners = this.listeners.get(element);\n    if (!elementListeners.has(event)) {\n      elementListeners.set(event, new Set());\n    }\n    \n    elementListeners.get(event).add(handler);\n    element.addEventListener(event, handler);\n  }\n  \n  removeEventListener(element, event, handler) {\n    const elementListeners = this.listeners.get(element);\n    if (!elementListeners) return;\n    \n    const eventHandlers = elementListeners.get(event);\n    if (!eventHandlers) return;\n    \n    eventHandlers.delete(handler);\n    element.removeEventListener(event, handler);\n    \n    // 清理空的集合\n    if (eventHandlers.size === 0) {\n      elementListeners.delete(event);\n    }\n    if (elementListeners.size === 0) {\n      this.listeners.delete(element);\n    }\n  }\n}\n```\n\n## 八、总结与建议\n\n### 何时使用 Map/Set\n\n- **Map**：当你需要键值对集合，且键可能是对象或需要保持插入顺序时\n- **Set**：当你需要存储唯一值，或进行集合运算（并集、交集、差集）时\n\n### 何时使用 WeakMap/WeakSet\n\n- **WeakMap**：当你需要将数据与对象关联，且不想阻止对象被垃圾回收时\n- **WeakSet**：当你需要标记对象，或创建对象的弱引用集合时\n\n### 性能考虑\n\n1. **查找性能**：Map/Set 的查找是 O(1)，而数组是 O(n)\n2. **内存管理**：WeakMap/WeakSet 有助于防止内存泄漏\n3. **迭代性能**：Map/Set 可以直接迭代，性能优于对象的 Object.keys()\n\n这四种集合类型极大地丰富了 JavaScript 的数据结构选择，合理使用它们不仅能让代码更简洁、更具表现力，还能在性能和内存管理方面带来显著的提升。在现代前端框架的开发中，它们更是不可或缺的基础设施。\n","tags":["秋招","ES"],"categories":["秋招准备"]},{"title":"React渲染时机完全指南：从一个电商组件的优化说起","url":"/2025/07/24/【从项目到技术】React渲染时机指南/","content":"\n## 前言\n\n作为前端开发者，我们每天都在和 React 打交道，但你真的了解 React 的渲染时机吗？\n\n- 为什么有时候获取 DOM 元素的高度是 0？\n- 为什么设置的动画效果没有生效？\n- 为什么页面会出现闪烁？\n- useEffect 和 useLayoutEffect 到底该用哪个？\n- requestAnimationFrame 在 React 中有什么用？\n\n在这篇文章中，我将通过一个真实的电商项目案例去搞懂 React 的渲染时机。\n\n## 一、从一个真实的电商场景说起\n\n### 1.1 业务背景\n\n在电商项目中，商品分类筛选是一个非常常见的功能。想象一下淘宝或京东的商品列表页，顶部通常会有这样的筛选器：\n\n```\n手机通讯 > 手机 > 华为 | 小米 | OPPO | vivo | 苹果 | 三星 | 荣耀 | realme | 一加 | 魅族...\n```\n\n当分类项特别多时，我们需要：\n\n- 默认只显示 2 行，多余的折叠起来\n- 提供展开/收起按钮\n- 支持平滑的展开/收起动画\n- 切换一级分类时，二级分类需要重置\n\n### 1.2 组件效果演示\n\n![类目筛选框](/Applications/PersonalWork/website/Blog_simonicle/source/postImage/【从项目到技术】React渲染时机指南/category.png)\n\n![类目筛选区-展开](/Applications/PersonalWork/website/Blog_simonicle/source/postImage/【从项目到技术】React渲染时机指南/category_expanded.png)\n\n(gif效果太差了。。。。)\n\n### 1.3 核心技术挑战\n\n看似简单的需求，实现起来却遇到了不少挑战：\n\n1. **高度计算问题**：如何准确获取内容的完整高度？\n2. **动画流畅性**：如何实现平滑的高度过渡动画？\n3. **状态切换问题**：切换分类时如何避免不必要的动画？\n4. **响应式适配**：如何在不同屏幕尺寸下保持良好体验？\n\n这些问题的核心都指向一个关键点：**我们需要在正确的时机执行正确的操作**。\n\n## 二、React 渲染机制深度解析\n\n### 2.1 React 的工作流程\n\n在深入代码之前，我们先来理解 React 的完整工作流程：\n\n```mermaid\ngraph TB\n    A[用户交互/Props变化] --> B[触发状态更新]\n    B --> C[React 调度更新]\n    C --> D[Render Phase<br/>渲染阶段]\n    D --> E[Reconciliation<br/>协调过程]\n    E --> F[生成 Fiber 树]\n    F --> G[Commit Phase<br/>提交阶段]\n    G --> H[更新 DOM]\n    H --> I[执行 useLayoutEffect]\n    I --> J[浏览器绘制]\n    J --> K[执行 useEffect]\n    K --> L[用户看到更新]\n    \n    style D fill:#f9f,stroke:#333,stroke-width:2px\n    style G fill:#9ff,stroke:#333,stroke-width:2px\n    style J fill:#ff9,stroke:#333,stroke-width:2px\n```\n\n### 2.2 三个关键阶段\n\n#### 阶段一：Render Phase（渲染阶段）\n\n- **特点**：可中断、可恢复、可并发\n- **任务**：调用组件函数，生成新的虚拟 DOM 树\n- **限制**：不能执行副作用（side effects）\n\n```javascript\n// 这个阶段执行的代码\nfunction MyComponent({ data }) {\n  // ✅ 纯计算\n  const processedData = useMemo(() => processData(data), [data]);\n  \n  // ❌ 不要在这里执行副作用\n  // document.title = 'New Title'; // 错误！\n  \n  return <div>{processedData}</div>;\n}\n```\n\n#### 阶段二：Commit Phase（提交阶段）\n\n- **特点**：同步执行，不可中断\n- **任务**：将变更应用到真实 DOM\n- **时机**：useLayoutEffect 在此阶段执行\n\n```javascript\nfunction MyComponent() {\n  useLayoutEffect(() => {\n    // 这里 DOM 已更新，但浏览器还未绘制\n    // 适合进行 DOM 测量或紧急的样式调整\n    const height = ref.current.scrollHeight;\n    console.log('真实高度:', height);\n  });\n}\n```\n\n#### 阶段三：Browser Paint（浏览器绘制）\n\n- **特点**：浏览器的工作，React 不参与\n- **任务**：计算布局、绘制像素\n- **时机**：useEffect 在此之后执行\n\n### 2.3 时序对比图\n\n让我们通过一个详细的时序图来对比不同 Hook 的执行时机：\n\n```mermaid\nsequenceDiagram\n    participant User as 用户\n    participant React as React\n    participant DOM as DOM\n    participant Browser as 浏览器\n    participant Effect as useEffect\n    participant LayoutEffect as useLayoutEffect\n    \n    User->>React: 点击按钮\n    React->>React: setState 更新状态\n    \n    rect rgb(255, 230, 230)\n        Note over React: Render Phase 开始\n        React->>React: 调用组件函数\n        React->>React: 生成虚拟 DOM\n        React->>React: Diff 算法对比\n        Note over React: Render Phase 结束\n    end\n    \n    rect rgb(230, 255, 230)\n        Note over React,DOM: Commit Phase 开始\n        React->>DOM: 更新真实 DOM\n        DOM-->>React: DOM 更新完成\n        React->>LayoutEffect: 同步执行 useLayoutEffect\n        LayoutEffect-->>React: 执行完成\n        Note over React,DOM: Commit Phase 结束\n    end\n    \n    rect rgb(230, 230, 255)\n        Note over Browser: Paint Phase 开始\n        DOM->>Browser: 触发重排/重绘\n        Browser->>Browser: 计算布局\n        Browser->>Browser: 绘制像素\n        Browser->>User: 显示更新后的界面\n        Note over Browser: Paint Phase 结束\n    end\n    \n    Browser->>Effect: 异步执行 useEffect\n    Effect-->>React: 执行完成\n```\n\n## 三、代码实战：剖析折叠组件的实现\n\n现在让我们来看看实际的代码实现，我会逐步解析每个关键部分。\n\n### 3.1 组件整体结构\n\n首先，让我们了解组件的整体结构：\n\n```javascript\n// 主组件：SecondCategoryBox\nconst SecondCategoryBox = ({\n  categoryList,        // 分类数据\n  defaultCategoryIds,  // 默认选中项\n  maxVisibleRows,      // 最大可见行数\n  onCategoryChange     // 选中项变化回调\n}) => {\n  // 状态管理\n  const [activeIDList, setActiveIDList] = useState([]);\n  \n  // 使用自定义 Hook 管理折叠逻辑\n  const { containerRef, isExpanded, showToggleButton, setIsExpanded } = useCollapse({\n    maxVisibleRows,\n    dependencies: [categoryList]\n  });\n  \n  // 渲染逻辑...\n};\n```\n\n### 3.2 核心难点一：精确的高度计算\n\n这是整个组件最核心的部分。我们需要：\n\n1. 获取内容的完整高度（展开时的高度）\n2. 计算折叠时应该显示的高度\n3. 决定是否需要显示展开/收起按钮\n\n```javascript\nconst calculateHeightsWithScale = useCallback(() => {\n  if (!containerRef.current) return;\n  \n  const container = containerRef.current;\n  \n  // 步骤1：临时解除高度限制\n  const originalHeight = container.style.height;\n  const originalOverflow = container.style.overflow;\n  \n  container.style.height = 'auto';\n  container.style.overflow = 'visible';\n  \n  // 步骤2：测量真实高度\n  // 注意：这里必须等待浏览器完成布局计算\n  const fullHeight = container.scrollHeight;\n  \n  // 步骤3：计算折叠高度\n  const visibleHeight = rowHeight * maxVisibleRows + gap * (maxVisibleRows - 1);\n  \n  // 步骤4：恢复原始样式\n  container.style.height = originalHeight;\n  container.style.overflow = originalOverflow;\n  \n  // 步骤5：更新状态\n  setHeights({ full: fullHeight, visible: visibleHeight });\n  setShowToggleButton(fullHeight > visibleHeight);\n}, [maxVisibleRows, rowHeight, gap]);\n```\n\n**关键问题：什么时候调用这个函数？**\n\n### 3.3 核心难点二：选择正确的执行时机\n\n这就涉及到我们要深入讨论的 React 渲染时机问题。让我们看看不同方案的对比：\n\n#### 方案一：使用 useEffect（❌ 会闪烁）\n\n```javascript\nuseEffect(() => {\n  calculateHeightsWithScale();\n}, [categoryList]);\n```\n\n**问题分析**：\n\n```mermaid\ngraph LR\n    A[分类数据变化] --> B[组件重新渲染]\n    B --> C[DOM 更新]\n    C --> D[浏览器绘制]\n    D --> E[用户看到错误高度]\n    E --> F[useEffect 执行]\n    F --> G[计算并设置正确高度]\n    G --> H[再次渲染]\n    H --> I[用户看到正确高度]\n    \n    style E fill:#ffcccc\n    style I fill:#ccffcc\n```\n\n用户会先看到错误的高度，然后突然跳到正确高度——这就是\"闪烁\"！\n\n#### 方案二：使用 useLayoutEffect（⚠️ 可能阻塞渲染）\n\n```javascript\nuseLayoutEffect(() => {\n  calculateHeightsWithScale();\n}, [categoryList]);\n```\n\n**优点**：在浏览器绘制前执行，避免闪烁 **缺点**：同步执行，可能阻塞渲染，影响性能\n\n#### 方案三：使用 requestAnimationFrame（✅ 最佳方案）\n\n```javascript\nuseEffect(() => {\n  requestAnimationFrame(() => {\n    calculateHeightsWithScale();\n  });\n}, [categoryList]);\n```\n\n**为什么这是最佳方案？**\n\n```mermaid\ngraph TB\n    A[useEffect 执行] --> B[注册 RAF 回调]\n    B --> C[浏览器完成当前帧绘制]\n    C --> D[布局信息已确定]\n    D --> E[RAF 回调执行]\n    E --> F[准确获取高度]\n    F --> G[更新组件状态]\n    \n    style D fill:#ccffcc\n    style F fill:#ccffcc\n```\n\nrequestAnimationFrame 确保：\n\n1. 不阻塞当前的渲染\n2. 在下一帧开始前执行\n3. 此时布局计算已完成，可以准确获取尺寸\n\n### 3.4 核心难点三：优雅地处理动画\n\n当用户切换一级分类时，我们需要重置二级分类，但不希望用户看到收起动画：\n\n```javascript\nuseEffect(() => {\n  if (firstUpdate) {\n    // 首次加载，使用默认选中项\n    setActiveIDList(defaultCategoryIds);\n    setFirstUpdate(false);\n  } else {\n    // 切换分类时的处理\n    \n    // 步骤1：立即禁用 CSS 过渡\n    setEnableTransition(false);\n    \n    // 步骤2：重置所有状态\n    setIsExpanded(false);\n    setActiveIDList([]);\n    \n    // 步骤3：在下一帧恢复过渡效果\n    requestAnimationFrame(() => {\n      setEnableTransition(true);\n    });\n  }\n}, [categoryList]);\n```\n\n**时序分析**：\n\n```mermaid\nsequenceDiagram\n    participant User as 用户\n    participant Component as 组件\n    participant CSS as CSS动画\n    participant Browser as 浏览器\n    \n    User->>Component: 切换一级分类\n    Component->>Component: categoryList 变化\n    Component->>CSS: 禁用 transition\n    Component->>Component: 重置状态（高度变为折叠状态）\n    Note over CSS: 无动画，瞬间变化\n    Component->>Browser: 请求下一帧\n    Browser-->>Component: 下一帧开始\n    Component->>CSS: 启用 transition\n    Note over CSS: 后续交互有动画\n```\n\n### 3.5 性能优化：响应式设计\n\n组件还实现了一个巧妙的响应式系统：\n\n```javascript\nconst calculateScale = useCallback(() => {\n  const currentWidth = window.innerWidth;\n  const scale = currentWidth / baseWidth;\n  \n  // 限制缩放范围，避免极端情况\n  const clampedScale = Math.max(0.8, Math.min(1.5, scale));\n  \n  return {\n    scale: clampedScale,\n    rowHeight: Math.round(baseRowHeight * clampedScale),\n    gap: Math.round(baseGap * clampedScale)\n  };\n}, [baseWidth, baseRowHeight, baseGap]);\n```\n\n这确保了组件在不同设备上都有合适的显示效果。\n\n## 四、深入理解 useEffect 和 useLayoutEffect\n\n### 4.1 本质区别\n\n```javascript\n// useEffect：在浏览器完成绘制后异步执行\nuseEffect(() => {\n  console.log('1. DOM 已更新');\n  console.log('2. 浏览器已绘制');\n  console.log('3. 用户已看到变化');\n  console.log('4. 现在执行不会阻塞渲染');\n});\n\n// useLayoutEffect：在浏览器绘制前同步执行\nuseLayoutEffect(() => {\n  console.log('1. DOM 已更新');\n  console.log('2. 浏览器还未绘制');\n  console.log('3. 用户还看不到变化');\n  console.log('4. 可以在这里调整样式避免闪烁');\n});\n```\n\n### 4.2 使用场景对比\n\n```mermaid\ngraph TB\n    A[需要执行副作用] --> B{是否影响视觉呈现?}\n    \n    B -->|是| C{是否需要 DOM 测量?}\n    B -->|否| D[使用 useEffect]\n    \n    C -->|是| E{测量是否紧急?}\n    C -->|否| F[使用 useLayoutEffect]\n    \n    E -->|是| G[useLayoutEffect]\n    E -->|否| H[useEffect + RAF]\n    \n    D --> I[数据获取<br/>事件订阅<br/>日志上报]\n    F --> J[阻止闪烁<br/>同步滚动<br/>焦点管理]\n    G --> K[关键布局计算<br/>动画初始状态]\n    H --> L[非关键测量<br/>性能优化]\n    \n    style B fill:#ffffcc\n    style C fill:#ffffcc\n    style E fill:#ffffcc\n```\n\n### 4.3 实际案例对比\n\n让我们通过几个实际例子来加深理解：\n\n#### 案例1：工具提示定位\n\n```javascript\nfunction Tooltip({ children, content }) {\n  const [position, setPosition] = useState({ top: 0, left: 0 });\n  const triggerRef = useRef();\n  const tooltipRef = useRef();\n  \n  // ✅ 使用 useLayoutEffect 避免工具提示闪烁\n  useLayoutEffect(() => {\n    if (triggerRef.current && tooltipRef.current) {\n      const triggerRect = triggerRef.current.getBoundingClientRect();\n      const tooltipRect = tooltipRef.current.getBoundingClientRect();\n      \n      setPosition({\n        top: triggerRect.top - tooltipRect.height - 8,\n        left: triggerRect.left + (triggerRect.width - tooltipRect.width) / 2\n      });\n    }\n  }, []);\n  \n  return (\n    <>\n      <span ref={triggerRef}>{children}</span>\n      <div \n        ref={tooltipRef}\n        className=\"tooltip\"\n        style={{ position: 'fixed', ...position }}\n      >\n        {content}\n      </div>\n    </>\n  );\n}\n```\n\n#### 案例2：滚动位置恢复\n\n```javascript\nfunction ScrollRestore({ location }) {\n  // ✅ 使用 useLayoutEffect 立即恢复滚动位置\n  useLayoutEffect(() => {\n    const savedPosition = sessionStorage.getItem(`scroll-${location}`);\n    if (savedPosition) {\n      window.scrollTo(0, parseInt(savedPosition));\n    }\n  }, [location]);\n  \n  // ✅ 使用 useEffect 保存滚动位置（非紧急）\n  useEffect(() => {\n    const handleScroll = () => {\n      sessionStorage.setItem(`scroll-${location}`, window.scrollY);\n    };\n    \n    window.addEventListener('scroll', handleScroll);\n    return () => window.removeEventListener('scroll', handleScroll);\n  }, [location]);\n}\n```\n\n#### 案例3：动画序列\n\n```javascript\nfunction AnimatedList({ items }) {\n  const [visibleItems, setVisibleItems] = useState([]);\n  \n  // ❌ 错误：在 useLayoutEffect 中做复杂计算\n  // useLayoutEffect(() => {\n  //   items.forEach((item, index) => {\n  //     setTimeout(() => {\n  //       setVisibleItems(prev => [...prev, item]);\n  //     }, index * 100);\n  //   });\n  // }, [items]);\n  \n  // ✅ 正确：使用 useEffect + RAF\n  useEffect(() => {\n    let frameId;\n    let index = 0;\n    \n    const animate = () => {\n      if (index < items.length) {\n        setVisibleItems(prev => [...prev, items[index]]);\n        index++;\n        frameId = requestAnimationFrame(animate);\n      }\n    };\n    \n    frameId = requestAnimationFrame(animate);\n    \n    return () => {\n      if (frameId) {\n        cancelAnimationFrame(frameId);\n      }\n    };\n  }, [items]);\n}\n```\n\n## 五、requestAnimationFrame 的高级应用\n\n### 5.1 什么是 requestAnimationFrame？\n\nrequestAnimationFrame（简称 RAF）是浏览器提供的一个 API，用于在下一次重绘之前执行动画。它的执行时机非常特殊：\n\n```mermaid\ngraph LR\n    A[帧开始] --> B[处理用户输入]\n    B --> C[JS 执行]\n    C --> D[RAF 回调]\n    D --> E[样式计算]\n    E --> F[布局]\n    F --> G[绘制]\n    G --> H[合成]\n    H --> I[帧结束]\n    \n    style D fill:#ffcccc\n```\n\n### 5.2 在 React 中的应用场景\n\n#### 场景1：确保布局完成后测量\n\n```javascript\nfunction useMeasure() {\n  const ref = useRef();\n  const [bounds, setBounds] = useState({});\n  \n  useEffect(() => {\n    if (!ref.current) return;\n    \n    // 确保在布局稳定后测量\n    const measure = () => {\n      requestAnimationFrame(() => {\n        if (ref.current) {\n          setBounds(ref.current.getBoundingClientRect());\n        }\n      });\n    };\n    \n    measure();\n    window.addEventListener('resize', measure);\n    \n    return () => window.removeEventListener('resize', measure);\n  }, []);\n  \n  return [ref, bounds];\n}\n```\n\n#### 场景2：批量 DOM 操作\n\n```javascript\nfunction batchDOMUpdates(updates) {\n  requestAnimationFrame(() => {\n    // 在一个帧内完成所有 DOM 操作\n    updates.forEach(update => update());\n    \n    // 强制浏览器立即计算样式（如果需要读取）\n    // 注意：这会触发强制同步布局，谨慎使用\n    if (needsRead) {\n      document.body.offsetHeight; // 强制重排\n    }\n  });\n}\n```\n\n#### 场景3：平滑动画\n\n```javascript\nfunction useAnimation(duration = 300) {\n  const [progress, setProgress] = useState(0);\n  const frameRef = useRef();\n  const startTimeRef = useRef();\n  \n  const start = useCallback(() => {\n    startTimeRef.current = performance.now();\n    \n    const animate = (currentTime) => {\n      const elapsed = currentTime - startTimeRef.current;\n      const progress = Math.min(elapsed / duration, 1);\n      \n      setProgress(progress);\n      \n      if (progress < 1) {\n        frameRef.current = requestAnimationFrame(animate);\n      }\n    };\n    \n    frameRef.current = requestAnimationFrame(animate);\n  }, [duration]);\n  \n  useEffect(() => {\n    return () => {\n      if (frameRef.current) {\n        cancelAnimationFrame(frameRef.current);\n      }\n    };\n  }, []);\n  \n  return [progress, start];\n}\n```\n\n### 5.3 RAF vs setTimeout/setInterval\n\n```javascript\n// ❌ 不推荐：可能导致掉帧或不流畅\nuseEffect(() => {\n  const timer = setInterval(() => {\n    setPosition(prev => prev + 1);\n  }, 16); // 约 60fps\n  \n  return () => clearInterval(timer);\n}, []);\n\n// ✅ 推荐：与浏览器刷新率同步\nuseEffect(() => {\n  let frameId;\n  \n  const animate = () => {\n    setPosition(prev => prev + 1);\n    frameId = requestAnimationFrame(animate);\n  };\n  \n  frameId = requestAnimationFrame(animate);\n  \n  return () => cancelAnimationFrame(frameId);\n}, []);\n```\n\n## 六、常见问题与最佳实践\n\n### 6.1 常见错误及解决方案\n\n#### 错误1：在渲染阶段读取 DOM\n\n```javascript\n// ❌ 错误\nfunction BadComponent() {\n  const ref = useRef();\n  // 这里 ref.current 可能是 null\n  const height = ref.current?.offsetHeight || 0;\n  \n  return <div ref={ref}>Content</div>;\n}\n\n// ✅ 正确\nfunction GoodComponent() {\n  const ref = useRef();\n  const [height, setHeight] = useState(0);\n  \n  useEffect(() => {\n    if (ref.current) {\n      setHeight(ref.current.offsetHeight);\n    }\n  }, []);\n  \n  return <div ref={ref}>Content</div>;\n}\n```\n\n#### 错误2：过度使用 useLayoutEffect\n\n```javascript\n// ❌ 错误：非视觉相关操作\nuseLayoutEffect(() => {\n  // 数据获取不应该阻塞渲染\n  fetch('/api/data').then(setData);\n}, []);\n\n// ✅ 正确\nuseEffect(() => {\n  fetch('/api/data').then(setData);\n}, []);\n```\n\n#### 错误3：忽视清理函数\n\n```javascript\n// ❌ 错误：内存泄漏\nuseEffect(() => {\n  const timer = setInterval(() => {\n    console.log('tick');\n  }, 1000);\n  // 忘记清理！\n}, []);\n\n// ✅ 正确\nuseEffect(() => {\n  const timer = setInterval(() => {\n    console.log('tick');\n  }, 1000);\n  \n  return () => clearInterval(timer);\n}, []);\n```\n\n### 6.2 性能优化建议\n\n#### 1. 避免不必要的布局计算\n\n```javascript\n// ❌ 性能差：每次渲染都计算\nfunction BadComponent({ items }) {\n  const heights = items.map(item => {\n    const element = document.getElementById(item.id);\n    return element?.offsetHeight || 0;\n  });\n}\n\n// ✅ 性能好：只在必要时计算\nfunction GoodComponent({ items }) {\n  const [heights, setHeights] = useState([]);\n  \n  useEffect(() => {\n    requestAnimationFrame(() => {\n      const newHeights = items.map(item => {\n        const element = document.getElementById(item.id);\n        return element?.offsetHeight || 0;\n      });\n      setHeights(newHeights);\n    });\n  }, [items]);\n}\n```\n\n#### 2. 批量更新 DOM\n\n```javascript\n// ✅ 批量读取和写入\nfunction BatchUpdate({ items }) {\n  useLayoutEffect(() => {\n    // 第一阶段：批量读取\n    const measurements = items.map(item => ({\n      id: item.id,\n      height: document.getElementById(item.id)?.offsetHeight || 0\n    }));\n    \n    // 第二阶段：批量写入\n    measurements.forEach(({ id, height }) => {\n      const element = document.getElementById(id);\n      if (element) {\n        element.style.transform = `translateY(${height}px)`;\n      }\n    });\n  }, [items]);\n}\n```\n\n#### 3. 使用 CSS 代替 JS 动画\n\n```javascript\n// ❌ JS 动画（性能较差）\nconst [height, setHeight] = useState(0);\nuseEffect(() => {\n  let current = 0;\n  const timer = setInterval(() => {\n    current += 5;\n    setHeight(current);\n    if (current >= 100) clearInterval(timer);\n  }, 16);\n}, []);\n\n// ✅ CSS 动画（性能更好）\nconst [expanded, setExpanded] = useState(false);\nreturn (\n  <div \n    className={`container ${expanded ? 'expanded' : ''}`}\n    style={{\n      transition: 'height 0.3s ease-out',\n      height: expanded ? '100px' : '0px'\n    }}\n  />\n);\n```\n\n### 6.3 调试技巧\n\n#### 1. 可视化渲染时机\n\n```javascript\nfunction useRenderLog(name) {\n  console.log(`${name} rendering`);\n  \n  useLayoutEffect(() => {\n    console.log(`${name} layout effect`);\n  });\n  \n  useEffect(() => {\n    console.log(`${name} effect`);\n    \n    requestAnimationFrame(() => {\n      console.log(`${name} next frame`);\n    });\n  });\n}\n```\n\n#### 2. 性能监控\n\n```javascript\nfunction usePerformanceMonitor(name) {\n  const renderStart = performance.now();\n  \n  useLayoutEffect(() => {\n    const layoutEffectTime = performance.now();\n    console.log(`${name} to layout effect: ${layoutEffectTime - renderStart}ms`);\n  });\n  \n  useEffect(() => {\n    const effectTime = performance.now();\n    console.log(`${name} to effect: ${effectTime - renderStart}ms`);\n    \n    requestAnimationFrame(() => {\n      const frameTime = performance.now();\n      console.log(`${name} to next frame: ${frameTime - renderStart}ms`);\n    });\n  });\n}\n```\n\n## 七、React 18 并发特性与渲染时机\n\n### 7.1 并发渲染的影响\n\nReact 18 引入的并发特性改变了一些渲染行为：\n\n```javascript\nimport { startTransition, useDeferredValue, useId } from 'react';\n\nfunction ConcurrentComponent({ searchTerm, items }) {\n  // 延迟非紧急更新\n  const deferredSearchTerm = useDeferredValue(searchTerm);\n  \n  // 标记低优先级更新\n  const handleExpensiveUpdate = () => {\n    startTransition(() => {\n      // 这个更新可以被中断\n      setExpensiveState(calculateExpensiveValue());\n    });\n  };\n  \n  // 紧急更新仍然同步处理\n  const handleUrgentUpdate = () => {\n    setUrgentState(value); // 立即响应\n  };\n}\n```\n\n### 7.2 并发渲染下的 useEffect\n\n在并发模式下，组件可能会多次渲染但只提交一次：\n\n```mermaid\ngraph TB\n    A[开始渲染] --> B{高优先级更新?}\n    B -->|是| C[中断当前渲染]\n    B -->|否| D[继续渲染]\n    C --> E[处理高优先级]\n    E --> F[重新开始低优先级]\n    D --> G[提交到 DOM]\n    F --> D\n    G --> H[执行 Effects]\n    \n    style C fill:#ffcccc\n    style E fill:#ffcccc\n```\n\n### 7.3 实践建议\n\n```javascript\nfunction SearchResults({ query }) {\n  const [results, setResults] = useState([]);\n  const [isSearching, setIsSearching] = useState(false);\n  \n  // 使用 useDeferredValue 优化搜索体验\n  const deferredQuery = useDeferredValue(query);\n  \n  // 紧急：显示加载状态\n  useEffect(() => {\n    setIsSearching(query !== deferredQuery);\n  }, [query, deferredQuery]);\n  \n  // 非紧急：执行搜索\n  useEffect(() => {\n    let cancelled = false;\n    \n    async function doSearch() {\n      const data = await searchAPI(deferredQuery);\n      if (!cancelled) {\n        startTransition(() => {\n          setResults(data);\n        });\n      }\n    }\n    \n    doSearch();\n    \n    return () => {\n      cancelled = true;\n    };\n  }, [deferredQuery]);\n  \n  return (\n    <div>\n      {isSearching && <Spinner />}\n      <ResultsList results={results} />\n    </div>\n  );\n}\n```\n\n## 八、实战总结：回到我们的折叠组件\n\n现在，让我们用学到的知识重新审视最初的折叠组件，看看它是如何解决各种渲染时机问题的：\n\n### 8.1 问题与解决方案对照\n\n| 问题                 | 解决方案             | 原理                  |\n| -------------------- | -------------------- | --------------------- |\n| 获取准确的内容高度   | useEffect + RAF      | 确保布局计算完成      |\n| 切换分类时的动画闪烁 | 禁用/启用 transition | 精确控制 CSS 动画时机 |\n| 响应式适配           | 动态计算缩放比例     | 避免频繁的 DOM 操作   |\n| 首次加载的默认状态   | firstUpdate 标记     | 区分初始化和更新      |\n\n### 8.2 完整的渲染流程\n\n```mermaid\nsequenceDiagram\n    participant U as 用户\n    participant C as 组件\n    participant D as DOM\n    participant B as 浏览器\n    \n    Note over U,B: 场景1：组件首次加载\n    U->>C: 页面加载\n    C->>C: 初始化状态\n    C->>D: 渲染 DOM\n    C->>C: useEffect 执行\n    C->>B: RAF 注册回调\n    B->>C: 下一帧执行测量\n    C->>C: 设置正确高度\n    C->>D: 更新 DOM\n    B->>U: 显示完整内容\n    \n    Note over U,B: 场景2：用户点击展开\n    U->>C: 点击展开按钮\n    C->>C: setIsExpanded(true)\n    C->>D: 更新高度样式\n    Note over D,B: CSS transition 生效\n    B->>U: 平滑展开动画\n    \n    Note over U,B: 场景3：切换分类\n    U->>C: 选择新分类\n    C->>C: 禁用 transition\n    C->>C: 重置状态\n    C->>D: 立即更新（无动画）\n    C->>B: RAF 注册回调\n    B->>C: 下一帧恢复 transition\n    Note over C,B: 后续交互恢复动画\n```\n\n### 8.3 关键代码片段回顾\n\n```javascript\n// 1. 自定义 Hook 封装复杂逻辑\nexport const useCollapse = (options) => {\n  const { maxVisibleRows = 2, dependencies = [] } = options;\n  const containerRef = useRef();\n  const [isExpanded, setIsExpanded] = useState(false);\n  const [showToggleButton, setShowToggleButton] = useState(false);\n  \n  // 2. 使用 RAF 确保准确测量\n  useEffect(() => {\n    requestAnimationFrame(() => calculateHeightsWithScale());\n  }, dependencies);\n  \n  // 3. 返回必要的状态和引用\n  return {\n    containerRef,\n    isExpanded,\n    showToggleButton,\n    setIsExpanded,\n    containerStyle: {\n      height: !showToggleButton ? 'auto' : \n              isExpanded ? heights.full : heights.visible,\n      overflow: 'hidden',\n      transition: 'height 0.3s ease-in-out'\n    }\n  };\n};\n```\n\n## 九、写在最后\n\n通过这个真实的电商项目案例，我们深入探讨了 React 的渲染时机问题。让我们再次总结一下核心要点：\n\n### 9.1 核心原则\n\n1. **理解时机**：知道代码在 React 生命周期的哪个阶段执行\n2. **选对工具**：useEffect、useLayoutEffect、RAF 各有适用场景\n3. **避免闪烁**：需要立即生效的视觉变化用 useLayoutEffect\n4. **性能优先**：非紧急操作放在 useEffect 中异步执行\n5. **精确控制**：使用 RAF 在正确的时机进行 DOM 测量\n\n### 9.2 决策流程图\n\n```mermaid\ngraph TD\n    A[需要副作用?] -->|是| B[影响视觉?]\n    A -->|否| Z[纯组件逻辑]\n    \n    B -->|是| C[需要 DOM 测量?]\n    B -->|否| D[useEffect]\n    \n    C -->|是| E[测量紧急?]\n    C -->|否| F[useLayoutEffect]\n    \n    E -->|是| G[useLayoutEffect]\n    E -->|否| H[useEffect + RAF]\n    \n    D --> I[异步操作<br/>数据获取<br/>事件订阅]\n    F --> J[防止闪烁<br/>滚动恢复]\n    G --> K[关键测量<br/>初始定位]\n    H --> L[性能优化<br/>非关键测量]\n    \n    style A fill:#f9f,stroke:#333,stroke-width:4px\n    style B fill:#bbf,stroke:#333,stroke-width:2px\n    style C fill:#bbf,stroke:#333,stroke-width:2px\n    style E fill:#bbf,stroke:#333,stroke-width:2px\n```\n\n### 9.3 从理论到实践\n\n理解 React 的渲染时机不仅仅是理论知识，更是解决实际问题的关键。当你遇到以下问题时，请想起这篇文章：\n\n- 页面闪烁 → 检查是否应该使用 useLayoutEffect\n- 获取的尺寸为 0 → 使用 RAF 确保布局完成\n- 动画卡顿 → 考虑使用 CSS 动画或 RAF\n- 性能问题 → 将非紧急操作移到 useEffect\n\n## 十、参考资料\n\n1. [React 官方文档 - Hooks Reference](https://react.dev/reference/react)\n2. [React 源码解析 - Fiber 架构](https://github.com/facebook/react)\n3. [Web 性能优化 - requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)\n4. [React 18 Working Group](https://github.com/reactwg/react-18)\n5. [浏览器渲染原理](https://developers.google.com/web/fundamentals/performance/rendering)\n\n------\n\n*如果这篇文章对你有帮助，欢迎点赞、收藏和分享。有任何问题或不同见解，也欢迎在评论区讨论！*\n","tags":["React","项目案例","性能优化","前端开发"],"categories":["从项目到技术"]},{"title":"【概念解析】前端开发中的polypill","url":"/2025/07/22/【概念解析】前端开发中的Polyfill/","content":"\n\n\n## 什么是 Polyfill？\n\n**Polyfill** 是一段代码（通常是 JavaScript），用来为旧浏览器提供它没有原生支持的较新的功能。\n\n### 名字的由来 🎨\n\n\"Polyfill\" 这个词来源于一种建筑材料 Polyfilla（一种用于填补墙面裂缝的腻子），形象地表示\"填补浏览器功能的空缺\"。\n\n## 为什么需要 Polyfill？\n\n```javascript\n// 🌰 例子：旧浏览器不支持 Array.includes\nconst fruits = ['apple', 'banana', 'orange'];\n\n// 新浏览器可以直接使用\nconsole.log(fruits.includes('banana')); // true\n\n// 旧浏览器会报错：fruits.includes is not a function\n```\n\n## 常见的 Polyfill 示例\n\n### 1. Array.includes Polyfill\n\n```javascript\n// 检查是否已经存在\nif (!Array.prototype.includes) {\n  Array.prototype.includes = function(searchElement, fromIndex) {\n    // 严格模式\n    'use strict';\n    \n    const O = Object(this);\n    const len = parseInt(O.length) || 0;\n    \n    if (len === 0) return false;\n    \n    const n = parseInt(fromIndex) || 0;\n    let k = Math.max(n >= 0 ? n : len + n, 0);\n    \n    while (k < len) {\n      if (searchElement === O[k]) return true;\n      k++;\n    }\n    \n    return false;\n  };\n}\n```\n\n### 2. Promise Polyfill\n\n```javascript\n// 简化版 Promise polyfill\nif (typeof Promise === 'undefined') {\n  window.Promise = function(executor) {\n    // Promise 实现代码...\n  };\n}\n```\n\n### 3. Object.assign Polyfill\n\n```javascript\nif (!Object.assign) {\n  Object.assign = function(target) {\n    'use strict';\n    \n    if (target == null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n    \n    const output = Object(target);\n    \n    for (let index = 1; index < arguments.length; index++) {\n      const source = arguments[index];\n      if (source != null) {\n        for (const key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            output[key] = source[key];\n          }\n        }\n      }\n    }\n    \n    return output;\n  };\n}\n```\n\n### 4. String.padStart Polyfill\n\n```javascript\nif (!String.prototype.padStart) {\n  String.prototype.padStart = function(targetLength, padString) {\n    targetLength = targetLength >> 0; // 转为整数\n    padString = String(padString || ' ');\n    \n    if (this.length >= targetLength) {\n      return String(this);\n    }\n    \n    targetLength = targetLength - this.length;\n    if (targetLength > padString.length) {\n      padString += padString.repeat(targetLength / padString.length);\n    }\n    \n    return padString.slice(0, targetLength) + String(this);\n  };\n}\n```\n\n## Polyfill vs 其他概念\n\n### 1. Polyfill vs Transpile（转译）\n\n```javascript\n// Polyfill：运行时补充缺失的 API\nArray.prototype.find = Array.prototype.find || function() { /* ... */ };\n\n// Transpile：编译时转换语法（如 Babel）\n// ES6 箭头函数\nconst add = (a, b) => a + b;\n// 转译后\nvar add = function(a, b) { return a + b; };\n```\n\n### 2. Polyfill vs Shim\n\n- **Polyfill**：实现标准 API，行为与规范一致\n- **Shim**：可能有自己的 API，不一定遵循标准\n\n## 如何使用 Polyfill？\n\n### 1. 手动引入\n\n```html\n<!-- 引入特定的 polyfill -->\n<script src=\"https://polyfill.io/v3/polyfill.min.js?features=Promise,Array.from\"></script>\n```\n\n### 2. 使用 core-js\n\n```javascript\n// 安装\nnpm install core-js\n\n// 使用\nimport 'core-js/features/array/includes';\nimport 'core-js/features/promise';\n```\n\n### 3. 使用 @babel/polyfill（已废弃）\n\n```javascript\n// 新的推荐方式\nnpm install core-js regenerator-runtime\n\n// babel.config.js\nmodule.exports = {\n  presets: [\n    ['@babel/preset-env', {\n      useBuiltIns: 'usage',\n      corejs: 3\n    }]\n  ]\n};\n```\n\n## 最佳实践\n\n### 1. 按需加载\n\n```javascript\n// 只在需要时加载 polyfill\nif (!window.Promise) {\n  // 动态加载 Promise polyfill\n  loadScript('promise-polyfill.js');\n}\n```\n\n### 2. 使用 polyfill.io 服务\n\n```html\n<!-- 根据用户浏览器自动返回需要的 polyfill -->\n<script src=\"https://polyfill.io/v3/polyfill.min.js\"></script>\n```\n\n### 3. 特性检测\n\n```javascript\n// 使用特性检测而不是浏览器检测\nfunction loadPolyfills() {\n  const polyfills = [];\n  \n  if (!window.Promise) {\n    polyfills.push(import('promise-polyfill'));\n  }\n  \n  if (!Array.prototype.includes) {\n    polyfills.push(import('array-includes-polyfill'));\n  }\n  \n  return Promise.all(polyfills);\n}\n\n// 加载完 polyfill 后再启动应用\nloadPolyfills().then(() => {\n  // 启动应用\n  startApp();\n});\n```\n\n## 常用的 Polyfill 库\n\n1. **core-js** - 最全面的 polyfill 库\n2. **polyfill.io** - 自动化 polyfill 服务\n3. **es5-shim/es6-shim** - ES5/ES6 polyfill\n4. **fetch-polyfill** - Fetch API polyfill\n5. **intersection-observer** - IntersectionObserver polyfill\n\n## 注意事项 ⚠️\n\n1. **性能影响**：Polyfill 会增加代码体积\n2. **选择性加载**：只加载需要的 polyfill\n3. **版本兼容**：确保 polyfill 支持目标浏览器\n4. **原生优先**：优先使用原生实现\n\n```javascript\n// 好的做法：先检测再添加\nif (!Array.prototype.flat) {\n  // 添加 polyfill\n}\n\n// 避免：直接覆盖\nArray.prototype.flat = function() { /* ... */ };\n```\n\n总之，Polyfill 是前端开发中实现向后兼容的重要手段，让我们能够在旧浏览器中使用新特性！","tags":["前端开发","概念解析"],"categories":["前端知识小册"]},{"title":"【秋招准备】面试手撕大集合","url":"/2025/07/22/【秋招备战】面试手撕大集合/","content":"\n# **所有遍历数组的方法**\n\n\n\n## forEach\n\n```JavaScript\n// 自定义 forEach 函数，添加到 Array 原型链\nArray.prototype.myForEach = function (callback, thisArg) {\n\n    // 类型检查：确保 callback 是一个函数\n    if (typeof callback !== 'function') {\n        throw new TypeError('第一个参数必须是一个函数');\n    }\n\n    // 遍历数组，调用 callback 函数\n    for (let i = 0; i < this.length; i++) {\n        // 如果数组的当前元素是 undefined 或 null, 则跳过\n        if (i in this) {//对于数组而言，in运算符用于检查是否有这个索引值\n            callback.call(thisArg, this[i], i, this);\n        }\n    }\n};\n```\n\n## map\n\n```JavaScript\n// 自定义 Map 函数，添加到 Array 原型链\nArray.prototype.myMap = function (callback) {\n\n    // 类型检查：确保 callback 是一个函数\n    if (typeof callback !== 'function') {\n        throw new TypeError('第一个参数必须是一个函数');\n    }\n    let res = [];\n\n    // 遍历数组，调用 callback 函数\n    for (let i = 0; i < this.length; i++) {\n        // 如果数组的当前元素是 undefined 或 null, 则跳过\n        if (i in this) {\n            res.push(callback(this[i], i, this));\n        }\n    }\n    return res\n};\n```\n\n## Filter\n\n```JavaScript\nArray.prototype.my_filter = function (cb) {\n    let newArr = []\n    for (var i = 0; i < this.length; i++) {\n        if (cb(this[i], i, this)) {\n            newArr.push(this[i])\n        }\n    }\n    return newArr\n}\n```\n\n## every(判断数组中的每一个元素是否都满足某个条件)\n\n```JavaScript\nArray.prototype.my_every = function (cb) {\n    for (let i = 0; i < this.length; i++) {\n        if (!cb(this[i], i, this)) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n## some（判断数组中是否存在一个元素满足某个条件）\n\n```JavaScript\nArray.prototype.my_some = function (cb) {\n    for (let i = 0; i < this.length; i++) {\n        if (cb(this[i], i, this)) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n## reduce\n\n```JavaScript\nArray.prototype.my_reduce = function (cb, ...args) {\n    let start, index = 0\n    if (args.length) {\n        start = args[0]\n    } else {\n        start = this[0];\n        index = 1\n    }\n    for (let i = index; i < this.length; i++) {\n        start = cb(start, this[i], i, this);\n    }\n    return start;\n}\n```\n\n## includes\n\n```JavaScript\nArray.prototype.my_includes = function (item, ...args) {\n    let index\n    if (args.length && !Number.isNaN(Number(args[0])) && Number(args[0])>0) {\n        index = Number(args[0])\n    } else {\n        index = 0;\n    }\n    for (let i = index; i < this.length; i++) {\n        if (this[i] === item) return true;\n    }\n    return false\n}\n```\n\n## splice\n\n```JavaScript\nArray.prototype.mySplice = function (start, len, ...args) {\n    let newArr = [], resArr = [];\n    if (arguments.length === 0) return resArr;\n\n    if (typeof len === 'undefined') {\n        len = 0;\n    }\n    if (typeof start === 'undefined') {\n        start = 0;\n    } else if (start < 0) {\n        start = start + this.length;\n        start = start < 0 ? 0 : start;\n    } else if (start >= this.length) {\n        start = this.length;\n    }\n\n    for (let i = 0; i < this.length; ++i) {\n        if (i < start || i >= start + len) {\n            newArr.push(this[i]);\n        } else {\n            resArr.push(this[i]);\n        }\n        if (i === start || start + i === this.length * 2 - 1) {\n            newArr.push(...args);\n        }\n    }\n    while (this.length) {\n        this.pop();\n    }\n    this.push(...newArr);\n    return resArr;\n}\n```\n\n# JS内置方法、对象以及运算符\n\n## new运算符\n\n```javascript\nfunction myNew (Func, ...arg){\n        if (fn.prototype === undefined) throw new TypeError('function is not a constructor');\n        let obj = {}  //定义了一个对象。\n        obj.__proto__ = Func.prototype  \n        //将Func.prototype赋值为对象的__proto__属性,即原型链的概念\n        let res = Func.call(obj, ...arg) //更改Func的this指向\n        return res instanceof Object ? res : obj \n}\n```\n\n## 手撕curry\n\n```javascript\nconst my_curry = (fn, ...args) =>\n    args.length >= fn.length\n        ? fn(...args)\n        : (...args1) => my_curry(fn, ...args, ...args1);\n\nfunction adder(x, y, z) {\n    return x + y + z;\n}\nconst add = my_curry(adder);\nconsole.log(add(1, 2, 3));  //6\nconsole.log(add(1)(2)(3));  //6\nconsole.log(add(1, 2)(3));  //6\nconsole.log(add(1)(2, 3));  //6\n```\n\n## 手写compose函数\n\n```JavaScript\nconst compose = (...fns)=>(x)=>fns.reduceRight((v, fn)=>fn(v),x);\nconst doubleAndSuare = compose(double, square);//先翻倍再平方\nconsole.log(doubleAndSuare(3));\n```\n\n## 手撕vue3响应式代理\n\n```javascript\n//测试代码\nclass Depend {\n  constructor() {\n    this.reactiveFns = new Set()//依赖组\n  }\n\n  // 更好的收集依赖\n  depend() {\n    if (activeReactiveFn) this.reactiveFns.add(activeReactiveFn)\n  }\n\n  //对所有依赖进行统一通知处理\n  notify() {\n    console.log(this.reactiveFns)\n    this.reactiveFns.forEach(fn => {\n      //遍历依赖处理\n      if (fn) fn()\n    })\n  }\n}\n\n// 封装响应式函数\nlet activeReactiveFn = null\nfunction watchFn(fn) {\n  activeReactiveFn = fn\n  fn()\n  activeReactiveFn = null\n}\n\n// 封装一个获取depend函数\nconst targetMap = new WeakMap()\nfunction getDepend(target, key) {\n  // 1、根据target对象获取map的过程\n  let map = targetMap.get(target)\n  if (!map) {\n    map = new Map()\n    targetMap.set(target, map)\n  }\n  // 2、根据对象属性获取depend依赖\n  let depend = map.get(key)\n  if (!depend) {\n    depend = new Depend()\n    map.set(key, depend)\n  }\n  return depend\n}\n\n\n//使用Proxy监听对象变化\nfunction reactive(obj) {\n  return new Proxy(obj, {\n    get: function (target, key, receiver) {\n      const depend = getDepend(target, key)\n      depend.depend()\n      return Reflect.get(target, key, receiver)\n    },\n    set: function (target, key, newValue, receiver) {\n      Reflect.set(target, key, newValue, receiver)\n      const depend = getDepend(target, key)\n      depend.notify()\n    }\n  })\n}\n\nconst obj = {\n  name: \"coderwhy\",//depend实例对象\n  age: 18//depend实例对象\n}\n\nconst info = {\n  name:\"小余\",\n  age:18\n}\n//响应式开关媒介\nconst objRef = reactive({\n  name: \"coderwhy\",\n  age: 18\n})\nconst infoRef = reactive({\n  name:\"小余\",\n  age:18\n})\n\nwatchFn(() => {\n  console.log(infoRef.name);  \n})\nwatchFn(() => {\n  console.log(objRef.name);  \n})\n\ninfoRef.name = '响应式-小余'\nobjRef.name = '响应式-coderwhy'\n\n// 小余\n// coderwhy\n// Set(1) { [Function (anonymous)] }\n// 响应式-小余\n// Set(1) { [Function (anonymous)] }\n// 响应式-coderwhy\n```\n\n## 手撕instanceof\n\n```sql\nconst myInstanceOf=(Left,Right)=>{\n  if(!Left){\n    return false\n  }\n  while(Left){\n    if(Left.__proto__===Right.prototype){\n      return true\n    }else{\n      Left=Left.__proto__\n    }\n  }\n  return false\n}\n\n//验证\nconsole.log(myInstanceOf({},Array));  //false\n```\n\n## call，bind，apply\n\n```javascript\nfunction foo(x,y){\n  console.log(this.a,x+y);\n}\n\nconst obj={\n  a:1\n}\n\nFunction.prototype.myCall=function(context,...args){\n  if(typeof this !== 'function')  return new TypeError('is not a function')\n  const fn = Symbol('fn') //使用Symbol尽可能降低myCall对其他的影响\n  context[fn] = this  //this指向foo\n  const res = context[fn](...args)  //解构，调用fn\n  delete context[fn]  //不要忘了删除obj上的工具函数fn\n  return res  //将结果返回\n}\n\n//验证\nfoo.myCall(obj,1,2)   //1,3\n\nfunction foo(x,y){\n  console.log(this.a,x+y);\n}\n\nconst obj={\n  a:1\n}\n\nFunction.prototype.myApply=function(context,args){\n  if(typeof this !== 'function')  return new TypeError('is not a function')\n  const fn = Symbol('fn') //使用Symbol尽可能降低myCall对其他的影响\n  context[fn] = this  //this指向foo\n  const res = context[fn](...args)  //解构，调用fn\n  delete context[fn]  //不要忘了删除obj上的工具函数fn\n  return res  //将结果返回\n}\n\n//验证\nfoo.myApply(obj,1,2)   //1,3\n\nfunction foo(x,y,z){\n  this.name='zt'\n  console.log(this.a,x+y+z);\n}\n\nconst obj={\n  a:1\n}\n\nFunction.prototype.myBind=function(context,...args){\n  if(typeof this !== 'function')  return new TypeError('It is not a function');\n  context = context || window; // 上下文环境\n  const _this = this; // 当前的函数的上下文this\n  return function F(...arg) {\n    //判断返回出去的F有没有被new，有就要把foo给到new出来的对象\n    if (this instanceof F) {\n       return new _this(...args, ...arg);\n    } else {\n       _this.call(this, ...args, ...arg);\n    }\n  }\n}\n\n//验证\nconst bar=foo.myBind(obj,1,2)\nconsole.log(new bar(3));   //undefined 6  foo { name: 'zt' }\n```\n\n## 值相等\n\n```javascript\nfunction compare(data1, data2) {\n  if (typeof data1 != typeof data2) {\n    return false;\n  }\n\n  if (typeof data1 != \"object\" && typeof data1 == typeof data2) {\n    return data1 === data2;\n  }\n\n  if ((!data1 instanceof Array && data2 instanceof Array) || (data1 instanceof Array && !data2 instanceof Array)) {\n    return false;\n  } else if (data1 instanceof Array  && data2 instanceof Array) {\n    if (data1.length == data2.length) {\n      for (let i = 0; i < data1.length; i++) {\n        if (!compare(data1[i], data2[i])) {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n  } else {\n      if (Object.keys(data1).length == Object.keys(data2).length) {\n      for (let key in data1) {\n        if (!data2[key] || !compare(data1[key], data2[key])) {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\n```\n\n## 深拷贝\n\n```javascript\nfunction isObject(value) {\n  const valueType = typeof value\n  return (value !== null) && (valueType === \"object\" || valueType === \"function\")\n}\n\nfunction deepClone(originValue) {\n  // 判断传入的originValue是否是一个对象类型\n  if (!isObject(originValue)) {\n    return originValue\n  }\n\n  const newObject = {}\n  for (const key in originValue) {\n    newObject[key] = deepClone(originValue[key])\n  }\n  //返回通过递归深层遍历赋值后，全新的数据对象\n  return newObject\n}\n```\n\n## 实现Object.create()\n\n创建一个空对象，定义其原型对象并设置其枚举属性\n\n```javascript\n// proto 可以是object 或者function\nObject.myCreate = function (proto, defineProperties){\n    if((typeof proto === 'object' && proto !== null) || typeof proto === 'function'){\n        let obj = {};\n\n        // obj.__proto__ = proto;\n        Object.setPrototypeOf(obj, proto);\n        Object.defineProperty(obj, defineProperties);\n        return obj;\n    }else {\n        throw new TypeError('类型错误');\n    }\n}\n```\n\n## 实现Object.assign（浅拷贝）\n\n```javascript\nfunction myAssign(target,...objs){\n    if(target === null || target === undefined){\n        throw new TypeError(\"can not convert null or undefined to object\")\n    }\n    let res = Object(target)\n    objs.forEach(obj => {\n        'use strict'\n        if(obj != null && obj != undefined){\n            for(let key in obj){\n                //hasOwnProperty用来判断一个属性是定义在对象本身而不是继承自原型链的\n                if(Object.prototype.hasOwnProperty.call(obj,key)){\n                    res[key] = obj[key]\n                }\n            }\n        }\n    })\n    return res\n}\nObject.defineProperty(Object,'myAssign',{\n    value: myAssign,\n    writable: true,\n    configurable: true,\n    enumerable: false\n})\n```\n\n## trim方法\n\n```javascript\nfunction myTrim(str) {\n  const reg = /^\\s+|\\s+$/g;\n  return str.replace(reg, '');\n}\n```\n\n## 模板字符串\n\n```javascript\nconst render = (template, data) => {\n    const reg = /\\$\\{(.*?)\\}/g;\n    template = template.replace(reg, (match, key) => {\n        let keys = key.trim().split('.');\n        return keys.reduce((obj, k) => obj?.[k], data) || '';\n    })\n    return template;\n}\n```\n\n## sleep函数\n\n```javascript\nfunction sleep(ms) {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            console.log('sleep...')\n            resolve()\n        }, ms);\n    })\n}\n\nasync function test(){\n    console.log('1');\n    await sleep(400)\n    console.log('2')\n}\n\ntest();\n```\n\n## 利用setTimeout实现setInterval\n\n```javascript\nfunction coustomSetInterval(callback, time) {\n    let intervalId = null;\n    function loop() {\n        intervalId = setTimeout(() => {\n            callback();\n            loop();\n        }, time)\n    }\n    loop();\n    return () => clearTimeout(intervalId)\n}\nconst interval = coustomSetInterval(() => {\n    console.log('想你了')\n}, 1000)\n\nsetTimeout(() => {\n    interval()\n}, 5000)\n```\n\n# 🚀 Promise 源码实现完全指南 - 从零手写 Promise\n\n> 🎯 **阅读本节你将收获**：\n>\n> - 深入理解 Promise 内部运行机制\n> - 手写一个符合 Promise/A+ 规范的 Promise\n> - 掌握面试中 Promise 相关的核心考点\n> - 理解 async/await 的实现原理\n\n## 📌 开篇：为什么要手写 Promise？\n\n在面试中，Promise 相关的题目可以说是必考题。但很多同学只会用，不知道其内部原理。今天我们就一起来揭开 Promise 的神秘面纱，手写一个完整的 Promise！\n\n## 一、Promise 基础架构 - 搭建地基 🏗️\n\n### 1.1 最简单的 Promise 结构\n\n我们先从最简单的结构开始，就像盖房子要先打地基：\n\n```javascript\nclass MyPromise {\n    constructor(executor) {\n        // executor 是使用者传入的函数，形如 (resolve, reject) => {}\n        \n        // 定义 resolve 函数\n        const resolve = (value) => {\n            console.log('调用了 resolve，值为：', value);\n        }\n        \n        // 定义 reject 函数\n        const reject = (reason) => {\n            console.log('调用了 reject，原因为：', reason);\n        }\n        \n        // 立即执行 executor\n        executor(resolve, reject);\n    }\n}\n\n// 测试一下\nnew MyPromise((resolve, reject) => {\n    resolve('成功啦！');\n});\n```\n\n### 1.2 Promise 的三种状态 - 状态机 🚦\n\nPromise 就像一个有三种状态的交通灯：\n\n- 🟡 **pending**（等待态）：初始状态，既不是成功，也不是失败\n- 🟢 **fulfilled**（成功态）：操作成功完成\n- 🔴 **rejected**（失败态）：操作失败\n\n**重要特性**：\n\n1. 状态只能从 `pending` → `fulfilled` 或 `pending` → `rejected`\n2. 状态一旦改变，就永远不会再变（这就是为什么叫 \"Promise\" - 承诺）\n\n让我们加上状态管理：\n\n```javascript\nclass MyPromise {\n    constructor(executor) {\n        // 初始状态为 pending\n        this.status = 'pending';\n        // 成功的值\n        this.value = undefined;\n        // 失败的原因\n        this.reason = undefined;\n        \n        // resolve 函数：将状态从 pending 改为 fulfilled\n        const resolve = (value) => {\n            // 只有在 pending 状态才能改变状态（保证状态只改变一次）\n            if (this.status === 'pending') {\n                this.status = 'fulfilled';\n                this.value = value;\n            }\n        }\n        \n        // reject 函数：将状态从 pending 改为 rejected\n        const reject = (reason) => {\n            if (this.status === 'pending') {\n                this.status = 'rejected';\n                this.reason = reason;\n            }\n        }\n        \n        // 立即执行 executor，并传入 resolve 和 reject\n        try {\n            executor(resolve, reject);\n        } catch (error) {\n            // 如果执行器抛出异常，Promise 应该被拒绝\n            reject(error);\n        }\n    }\n}\n```\n\n## 二、实现 then 方法 - Promise 的灵魂 ✨\n\n### 2.1 then 方法的基本实现\n\n`then` 方法是 Promise 的核心，它用来注册当 Promise 状态改变时的回调函数。\n\n```javascript\nclass MyPromise {\n    // ... 前面的代码\n\n    then(onFulfilled, onRejected) {\n        // 如果状态是 fulfilled，执行成功回调\n        if (this.status === 'fulfilled') {\n            onFulfilled(this.value);\n        }\n        \n        // 如果状态是 rejected，执行失败回调\n        if (this.status === 'rejected') {\n            onRejected(this.reason);\n        }\n    }\n}\n\n// 测试同步情况\nconst promise = new MyPromise((resolve, reject) => {\n    resolve('成功！');\n});\n\npromise.then(\n    value => console.log('成功:', value),\n    reason => console.log('失败:', reason)\n);\n```\n\n### 2.2 处理异步情况 - 发布订阅模式 📢\n\n上面的代码有个问题：如果 executor 中有异步操作怎么办？\n\n```javascript\nconst promise = new MyPromise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('异步成功！');\n    }, 1000);\n});\n\n// 此时状态还是 pending，then 方法不会执行任何回调！\npromise.then(value => console.log(value));\n```\n\n解决方案：使用**发布订阅模式**，先把回调存起来，等状态改变时再执行：\n\n```javascript\nclass MyPromise {\n    constructor(executor) {\n        this.status = 'pending';\n        this.value = undefined;\n        this.reason = undefined;\n        \n        // 存储成功回调的数组\n        this.onFulfilledCallbacks = [];\n        // 存储失败回调的数组\n        this.onRejectedCallbacks = [];\n        \n        const resolve = (value) => {\n            if (this.status === 'pending') {\n                this.status = 'fulfilled';\n                this.value = value;\n                // 状态改变时，执行所有的成功回调\n                this.onFulfilledCallbacks.forEach(fn => fn());\n            }\n        }\n        \n        const reject = (reason) => {\n            if (this.status === 'pending') {\n                this.status = 'rejected';\n                this.reason = reason;\n                // 状态改变时，执行所有的失败回调\n                this.onRejectedCallbacks.forEach(fn => fn());\n            }\n        }\n        \n        try {\n            executor(resolve, reject);\n        } catch (error) {\n            reject(error);\n        }\n    }\n    \n    then(onFulfilled, onRejected) {\n        if (this.status === 'fulfilled') {\n            onFulfilled(this.value);\n        }\n        \n        if (this.status === 'rejected') {\n            onRejected(this.reason);\n        }\n        \n        // 如果是 pending 状态，将回调存储起来\n        if (this.status === 'pending') {\n            this.onFulfilledCallbacks.push(() => {\n                onFulfilled(this.value);\n            });\n            this.onRejectedCallbacks.push(() => {\n                onRejected(this.reason);\n            });\n        }\n    }\n}\n```\n\n### 2.3 链式调用的实现 - then 返回 Promise 🔗\n\nPromise 最强大的特性之一就是链式调用。要实现链式调用，`then` 方法必须返回一个新的 Promise：\n\n```javascript\nthen(onFulfilled, onRejected) {\n    // then 方法返回一个新的 Promise\n    return new MyPromise((resolve, reject) => {\n        // 封装一个执行函数，统一处理成功和失败的情况\n        const fulfilledMicrotask = () => {\n            // 使用 queueMicrotask 创建微任务，保证异步执行\n            queueMicrotask(() => {\n                try {\n                    const x = onFulfilled(this.value);\n                    // 处理返回值（详见下一节）\n                    resolvePromise(promise2, x, resolve, reject);\n                } catch (error) {\n                    reject(error);\n                }\n            });\n        };\n        \n        const rejectedMicrotask = () => {\n            queueMicrotask(() => {\n                try {\n                    const x = onRejected(this.reason);\n                    resolvePromise(promise2, x, resolve, reject);\n                } catch (error) {\n                    reject(error);\n                }\n            });\n        };\n        \n        if (this.status === 'fulfilled') {\n            fulfilledMicrotask();\n        } else if (this.status === 'rejected') {\n            rejectedMicrotask();\n        } else if (this.status === 'pending') {\n            this.onFulfilledCallbacks.push(fulfilledMicrotask);\n            this.onRejectedCallbacks.push(rejectedMicrotask);\n        }\n    });\n}\n```\n\n### 2.4 处理 then 的返回值 - resolvePromise 🎯\n\n这是实现 Promise 最复杂的部分，需要处理各种情况：\n\n```javascript\nfunction resolvePromise(promise2, x, resolve, reject) {\n    // 如果 x === promise2，会造成循环引用\n    if (x === promise2) {\n        return reject(new TypeError('Chaining cycle detected'));\n    }\n    \n    // 如果 x 是 Promise 实例\n    if (x instanceof MyPromise) {\n        // 等待 x 的状态改变，然后递归处理\n        x.then(\n            value => resolvePromise(promise2, value, resolve, reject),\n            reason => reject(reason)\n        );\n        return;\n    }\n    \n    // 如果 x 是对象或函数（可能是 thenable）\n    if (x !== null && (typeof x === 'object' || typeof x === 'function')) {\n        let then;\n        try {\n            then = x.then;\n        } catch (error) {\n            return reject(error);\n        }\n        \n        // 如果 then 是函数，认为 x 是 thenable\n        if (typeof then === 'function') {\n            let called = false; // 防止多次调用\n            try {\n                then.call(\n                    x,\n                    value => {\n                        if (called) return;\n                        called = true;\n                        resolvePromise(promise2, value, resolve, reject);\n                    },\n                    reason => {\n                        if (called) return;\n                        called = true;\n                        reject(reason);\n                    }\n                );\n            } catch (error) {\n                if (called) return;\n                reject(error);\n            }\n        } else {\n            // 如果 then 不是函数，直接 resolve\n            resolve(x);\n        }\n    } else {\n        // 如果 x 是普通值，直接 resolve\n        resolve(x);\n    }\n}\n```\n\n## 三、实现 Promise 的静态方法 🛠️\n\n### 3.1 Promise.resolve 和 Promise.reject\n\n```javascript\nclass MyPromise {\n    // 快速创建一个成功的 Promise\n    static resolve(value) {\n        // 如果 value 已经是 Promise，直接返回\n        if (value instanceof MyPromise) {\n            return value;\n        }\n        \n        return new MyPromise(resolve => resolve(value));\n    }\n    \n    // 快速创建一个失败的 Promise\n    static reject(reason) {\n        return new MyPromise((resolve, reject) => reject(reason));\n    }\n}\n```\n\n### 3.2 Promise.all - 一个都不能少 🎯\n\n`Promise.all` 接收一个 Promise 数组，只有全部成功才成功，有一个失败就失败：\n\n```javascript\nstatic all(promises) {\n    return new MyPromise((resolve, reject) => {\n        const results = [];\n        let completedCount = 0;\n        \n        // 处理空数组的情况\n        if (promises.length === 0) {\n            resolve(results);\n            return;\n        }\n        \n        promises.forEach((promise, index) => {\n            // 将非 Promise 值转换为 Promise\n            MyPromise.resolve(promise).then(\n                value => {\n                    results[index] = value;\n                    completedCount++;\n                    \n                    // 所有 Promise 都成功了\n                    if (completedCount === promises.length) {\n                        resolve(results);\n                    }\n                },\n                reason => {\n                    // 有一个失败就直接 reject\n                    reject(reason);\n                }\n            );\n        });\n    });\n}\n```\n\n### 3.3 Promise.race - 谁快用谁 🏃\n\n```javascript\nstatic race(promises) {\n    return new MyPromise((resolve, reject) => {\n        // 空数组永远 pending\n        if (promises.length === 0) return;\n        \n        promises.forEach(promise => {\n            // 谁先完成就用谁的结果\n            MyPromise.resolve(promise).then(resolve, reject);\n        });\n    });\n}\n```\n\n### 3.4 Promise.allSettled - 等待所有结果 📊\n\n不管成功还是失败，等所有 Promise 都有结果：\n\n```javascript\nstatic allSettled(promises) {\n    return new MyPromise((resolve) => {\n        const results = [];\n        let settledCount = 0;\n        \n        if (promises.length === 0) {\n            resolve(results);\n            return;\n        }\n        \n        promises.forEach((promise, index) => {\n            MyPromise.resolve(promise).then(\n                value => {\n                    results[index] = { status: 'fulfilled', value };\n                    settledCount++;\n                    if (settledCount === promises.length) {\n                        resolve(results);\n                    }\n                },\n                reason => {\n                    results[index] = { status: 'rejected', reason };\n                    settledCount++;\n                    if (settledCount === promises.length) {\n                        resolve(results);\n                    }\n                }\n            );\n        });\n    });\n}\n```\n\n### 3.5 Promise.any - 一个成功就够了 ✅\n\n```javascript\nstatic any(promises) {\n    return new MyPromise((resolve, reject) => {\n        const errors = [];\n        let rejectedCount = 0;\n        \n        if (promises.length === 0) {\n            reject(new AggregateError([], 'All promises were rejected'));\n            return;\n        }\n        \n        promises.forEach((promise, index) => {\n            MyPromise.resolve(promise).then(\n                value => {\n                    // 有一个成功就 resolve\n                    resolve(value);\n                },\n                reason => {\n                    errors[index] = reason;\n                    rejectedCount++;\n                    \n                    // 全部失败才 reject\n                    if (rejectedCount === promises.length) {\n                        reject(new AggregateError(errors, 'All promises were rejected'));\n                    }\n                }\n            );\n        });\n    });\n}\n```\n\n## 四、实现 catch 和 finally 🎣\n\n### 4.1 catch - 错误处理\n\n```javascript\ncatch(onRejected) {\n    // catch 就是 then 的语法糖\n    return this.then(null, onRejected);\n}\n```\n\n### 4.2 finally - 无论如何都要执行\n\n```javascript\nfinally(callback) {\n    return this.then(\n        // 成功时执行 callback，但传递原来的值\n        value => MyPromise.resolve(callback()).then(() => value),\n        // 失败时执行 callback，但传递原来的错误\n        reason => MyPromise.resolve(callback()).then(() => { throw reason })\n    );\n}\n```\n\n## 五、async/await 的实现原理 🔮\n\n### 5.1 理解 async/await\n\n`async/await` 本质上是 Generator + Promise 的语法糖。让我们看看它是如何工作的：\n\n```javascript\n// async 函数\nasync function fetchData() {\n    const user = await getUser();\n    const posts = await getPosts(user.id);\n    return posts;\n}\n\n// 等价于\nfunction fetchData() {\n    return spawn(function* () {\n        const user = yield getUser();\n        const posts = yield getPosts(user.id);\n        return posts;\n    });\n}\n```\n\n### 5.2 实现自动执行器\n\n```javascript\nfunction spawn(genFunc) {\n    return new Promise((resolve, reject) => {\n        const gen = genFunc();\n        \n        function step(nextFunc) {\n            let next;\n            try {\n                next = nextFunc();\n            } catch (error) {\n                return reject(error);\n            }\n            \n            // Generator 函数执行完毕\n            if (next.done) {\n                return resolve(next.value);\n            }\n            \n            // 将 yield 的值包装成 Promise，然后递归执行\n            Promise.resolve(next.value).then(\n                value => step(() => gen.next(value)),\n                error => step(() => gen.throw(error))\n            );\n        }\n        \n        // 开始执行\n        step(() => gen.next());\n    });\n}\n```\n\n### 5.3 一个更简单的实现\n\n```javascript\nfunction asyncToGenerator(generatorFunc) {\n    return function (...args) {\n        const gen = generatorFunc.apply(this, args);\n        \n        return new Promise((resolve, reject) => {\n            function step(key, arg) {\n                let generatorResult;\n                \n                try {\n                    generatorResult = gen[key](arg);\n                } catch (error) {\n                    return reject(error);\n                }\n                \n                const { value, done } = generatorResult;\n                \n                if (done) {\n                    return resolve(value);\n                } else {\n                    return Promise.resolve(value).then(\n                        val => step('next', val),\n                        err => step('throw', err)\n                    );\n                }\n            }\n            \n            step('next');\n        });\n    };\n}\n\n// 使用示例\nconst getData = asyncToGenerator(function* () {\n    const data1 = yield fetch('/api/1');\n    const data2 = yield fetch('/api/2');\n    return [data1, data2];\n});\n\ngetData().then(result => console.log(result));\n```\n\n## 🎯 面试高频考点总结\n\n1. **Promise 的状态机制**：三种状态，只能单向改变，一旦改变不可逆\n2. **then 的链式调用**：then 返回新的 Promise，根据回调函数的返回值决定新 Promise 的状态\n3. **微任务队列**：Promise 的回调在微任务队列中执行\n4. **错误处理**：catch 能捕获前面所有 then 中的错误\n5. **Promise.all vs Promise.race**：一个要全部成功，一个要最快完成\n6. **async/await 原理**：Generator + 自动执行器 + Promise\n\n# 模板渲染引擎\n\n```xml\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>模板渲染示例</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n\n    <script src=\"script.js\"></script>\n</body>\n</html>\n// 渲染引擎\nfunction renderTemplate(template, data) {\n\n    // 处理条件判断\n    template = template.replace(/{{\\s*#if\\s*(\\w+)\\s*}}([\\s\\S]*?){{\\s*\\/if\\s*}}/g, function (_, condition, content) {\n        return data[condition] ? content : '';\n    });\n\n    // 处理循环\n    template = template.replace(/{{\\s*#each\\s*(\\w+)\\s*}}([\\s\\S]*?){{\\s*\\/each\\s*}}/g, function (_, arrayKey, content) {\n        let result = '';\n        let array = data[arrayKey];\n        if (Array.isArray(array)) {\n            array.forEach((item, index) => {\n                // 创建一个独立作用域，避免冲突\n                let temp = content;\n                // 替换模板内的 {{ this }} 为循环项\n                temp = temp.replace(/{{\\s*this\\s*}}/g, function () {\n                    return item;\n                });\n                // 如果是对象，处理它的属性\n                temp = temp.replace(/{{\\s*this\\.(\\w+)\\s*}}/g, function (_, prop) {\n                    return item[prop] || '';\n                });\n                // 替换循环索引（如果需要）\n                temp = temp.replace(/{{\\s*index\\s*}}/g, index);\n                // 将处理后的结果添加到最终结果中\n                result += temp;\n            });\n        }\n        return result;\n    });\n    // 替换变量，一定要放到最后！！\n    template = template.replace(/\\{\\{(.*?)\\}\\}/g, (match, key) => {\n        let keys = key.trim().split('.');\n        return keys.reduce((obj, k) => obj?.[k], data) || '';\n    })\n\n    return template;\n}\n\n// 定义数据\nconst data = {\n    name: \"张三\",\n    age: 25,\n    isEmployed: true,\n    occupation: \"工程师\",\n    hobbies: [\"阅读\", \"编程\", \"旅游\"],\n    friends: [\n        { name: \"李四\", age: 26 },\n        { name: \"王五\", age: 24 }\n    ]\n};\n\n// 定义模板\nconst template = `\n    <h1>个人信息</h1>\n    <p>姓名: {{ name }}</p>\n    <p>年龄: {{ age }}</p>\n    <p>职业: {{ occupation }}</p>\n\n    {{#if isEmployed}}\n        <p>当前状态: 在职</p>\n    {{/if}}\n\n    <h2>兴趣爱好</h2>\n    <ul>\n        {{#each hobbies}}\n            <li>{{ this }}</li>\n        {{/each}}\n    </ul>\n\n    <h2>朋友列表</h2>\n    <ul>\n        {{#each friends}}\n            <li>{{ this.name }} - {{ this.age }} 岁</li>\n        {{/each}}\n    </ul>\n`;\n\n// 渲染模板并插入 HTML\ndocument.getElementById('app').innerHTML = renderTemplate(template, data);\n```\n\n# 防抖截流\n\n```JavaScript\nconst debounce = (fn, ms, Immediate = false) => {\n    // Immediate选择是否立即执行\n    let timer = null;\n    return function (...thisArgs) {\n        if (timer) {\n            clearTimeout(timer)\n        }\n        if (Immediate) {\n            let flag = !timer\n            flag && fn.apply(this, thisArgs)\n            timer = setTimeout(() => {\n                timer = null\n            }, ms)\n        } else {\n            timer = setTimeout(() => {\n                fn.apply(this, thisArgs)\n                timer = null\n            }, ms)\n        }\n    }\n}\n\nconst throttle = (fn, ms) => {\n    let timer = null;\n    return function (...thisArgs) {\n        if (!timer) {\n            fn.apply(this, thisArgs);\n            timer = setTimeout(() => {\n                timer = null;\n            }, ms);\n        }\n    }\n}\n```\n\n# 技巧\n\n## 数组去重\n\n```javascript\nlet arr = [1, 0, 2, 3, 4, 5, 2, 3, 4];\n//indexOf去重\nfunction removeRepeat(arr) {\n  let res = [];\n  for (let i of arr) {\n    if (res.indexOf(i) == -1) {\n      res.push(i);\n    }\n  }\n  return res;\n}\n// set 去重\nfunction removeRepeat(arr) {\n  let res = new Set(arr);\n  return Array.from(res);\n}\n// for循环去重\nfunction removeRepeat(arr) {\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] == arr[j]) {\n        arr.splice(j, 1);\n        j--;\n      }\n    }\n  }\n  return arr;\n}\n// filter 去重\nfunction removeRepeat(arr) {\n  return arr.filter((item, index) => {\n    return arr.indexOf(item) == index;\n  });\n}\n// includes 去重\nfunction removeRepeat(arr) {\n  let res = [];\n  for (let i of arr) {\n    if (!res.includes(i)) {\n      res.push(i);\n    }\n  }\n  return res;\n}\nlet res = removeRepeat(arr);\nconsole.log(res);\n```\n\n## 快排和归并\n\n```javascript\nArray.prototype.quicksort = function (l, r) {\n    if (l >= r) return this;\n    let key = this[l];\n    let i = l - 1, j = r + 1;\n    while (i < j) {\n        do i++; while (this[i] < key);\n        do j--; while (this[j] > key);\n        if (i < j) [this[i], this[j]] = [this[j], this[i]];\n    }\n    this.quicksort(l, j);\n    this.quicksort(j + 1, r);\n    return this;\n}\nlet arr = [5,8,3,6,4,2];\nconsole.log(arr.quicksort(0, arr.length-1));\n\n\nArray.prototype.mergesort = function (temp, l, r) {\n    if (l >= r) return this;\n    let mid = l + r >> 1;\n    this.mergesort(temp, l, mid);\n    this.mergesort(temp, mid + 1, r);\n\n    let i = l, j = mid + 1, k = 0;\n    while (i <= mid && j <= r) {\n        if (this[i] <= this[j]) temp[k++] = this[i++];\n        else temp[k++] = this[j++];\n    }\n    while (i <= mid) temp[k++] = this[i++];\n    while (j <= r) temp[k++] = this[j++];\n\n    for (let m = 0, n = l; n <= r; m++, n++) {\n        this[n] = temp[m];\n    }\n    return this;\n}\n\nlet arr = [7, 1, 0, 3, 0, 5, 6, 4];\nconsole.log(arr.mergesort(Array(arr.length).fill(0), 0, arr.length - 1));\n```\n\n## 下划线和驼峰相互转换\n\n```javascript\n//方式一：操作字符串数组\nfunction transformStr2Hump1(str) {\n    if(str == null) {\n        return \"\";\n    }\n    var strArr = str.split('-');\n    for(var i = 1; i < strArr.length; i++) {\n        strArr[i] = strArr[i].charAt(0).toUpperCase() + strArr[i].substring(1);\n    }\n    return strArr.join('');\n}\n\n//方式二：操作字符数组\nfunction transformStr2Hump2(str) {\n    if(str == null) {\n        return \"\";\n    }\n    var strArr  =str.split('');\n    for(var i = 0; i < strArr.length; i++) {\n        if(strArr[i] == \"-\"){\n            //删除-\n            strArr.splice(i, 1);\n            //将该处改为大写\n            if(i < strArr.length) {\n                strArr[i] = strArr[i].toUpperCase();\n            }\n        }\n    }\n    return strArr.join(\"\");\n}\n\n//方式三：利用正则\nfunction transformStr2Hump3(str) {\n    if(str == null) {\n        return \"\";\n    }\n    var reg = /-(\\w)/g;//匹配字母或数字或下划线或汉字\n    return str.replace(reg, function($0, $1) {\n        return $1.toUpperCase();\n    })\n}\n```\n\n## 懒加载\n\n- 首先，不要将图片地址放到src属性中，而是放到其它属性(data-original)中。\n- 页面加载完成后，根据scrollTop判断图片是否在用户的视野内，如果在，则将data-original属性中的值取出存放到src属性中。\n- 在滚动事件中重复判断图片是否进入视野，如果进入，则将data-original属性中的值取出存放到src属性中。\n\n>  elementNode.getAttribute(name)：方法通过名称获取属性的值。\n>\n>  elementNode.setAttribute(name, value)：方法创建或改变某个新属性。\n>\n>  elementNode.removeAttribute(name)：方法通过名称删除属性的值。\n\n```javascript\n//懒加载代码实现\nvar viewHeight = document.documentElement.clientHeight;//可视化区域的高度\n\nfunction lazyload () {\n    //获取所有要进行懒加载的图片\n    let eles = document.querySelectorAll('img[data-original][lazyload]');//获取属性名中有data-original的\n    Array.prototype.forEach.call(eles, function(item, index) {\n        let rect;\n        if(item.dataset.original === '') {\n            return;\n        }\n\n        rect = item.getBoundingClientRect();\n\n        //图片一进入可视区，动态加载\n        if(rect.bottom >= 0 && rect.top < viewHeight) {\n            !function () {\n                let img = new Image();\n                img.src = item.dataset.original;\n                img.onload = function () {\n                    item.src = img.src;\n                }\n                item.removeAttribute('data-original');\n                item.removeAttribute('lazyload');\n            }();\n        }\n    })\n}\n\nlazyload();\n\ndocument.addEventListener('scroll', lazyload);\n```\n\n## 数组扁平化\n\n```javascript\n//传入参数 决定扁平化的阶数\nArray.prototype._flat = function (n) {\n    let result = [];\n    let num = n;\n    for (let item of this) {\n        // 如果是数组\n        if (Array.isArray(item)) {\n            n--;\n            //   没有扁平化的空间 直接推入\n            if (n < 0) {\n                result.push(item);\n            }\n            // 继续扁平化 并将n传入 决定item这一个数组中的扁平化\n            else {\n                result.push(...item._flat(n));\n            }\n        }\n        // 不是数组直接推入\n        else {\n            result.push(item);\n        }\n        // 每次循环 重置n 为传入的参数 因为每一项都需要扁平化 需要进行判断\n        n = num;\n    }\n    return result;\n};\nlet arr = [1, 2, [3, 4], [5, 6, [7, 8]]];\nlet res = arr._flat(1);\nconsole.log(res); // [ 1, 2, 3, 4, 5, 6, [ 7, 8 ] ]\n```\n\n## 计算属性\n\n请不要为所有函数添加缓存！\n\n```javascript\nconst computed = (func, content) => {\n    let cache = Object.create(null);\n    content = content || this;\n    return (...key) => {\n        console.log(cache)\n        if (!cache[key]) {\n            cache[key] = func.apply(content, key);\n        }\n        return cache[key];\n    }\n}\n```\n\n## 有并发限制的Promise调度器\n\n```JavaScript\nclass Scheduler{\n    constructor(limit){\n        this.limit = limit;\n        this.running = 0;\n        this.queue = [];\n    }\n    createTask(callback, duration){\n        return ()=>{\n            return new Promise((resolve, reject)=>{\n                setTimeout(()=>{\n                    callback();\n                    resolve();\n                },duration);\n            });\n        };\n    }\n    \n    add(callback, duration){\n        const task = this.createTask(callback, duration);\n        this.queue.push(task);\n    }\n    \n    start(){\n        for(let i=0;i<this.limit;++i){\n            this.schedule();\n        }\n    }\n    schedule(){\n        if(this.queue.length === 0 || this.running >= this.limit)return;\n        this.running++;\n        const task = this.queue.shift();\n        \n        task().then(()=>{\n            this.running--;\n            schedule();\n        });\n    }\n}\n```\n\n# 网络请求和跨域解决方案\n\n## 原生ajax\n\n```javascript\nfunction sendajax() {\n    // 1、 初始化xhr对象\n    const xhr = new XMLHttpRequest();\n    //  2、 建立连接 设置请求方法和url\n    xhr.open(\"get\", \"./data.json\");\n    //   3、发送请求\n    xhr.send();\n    //   4、状态改变时 进行回调\n    xhr.onreadystatechange = function () {\n        // readyState 有0-4 五个值\n        // 0 代表 未初始化 1 代表 初始化成功 2 代表发送请求\n        // 3 代表返回了部分数据 4 代表返回了全部数据\n        if (xhr.readyState == 4) {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                //   进行成功的操作\n                console.log(xhr.responseText);\n            }\n        }\n    };\n}\nsendajax();\n```\n\n## JSONP跨域\n\n首先在客户端注册一个callback，然后把callback的名字传给服务器。此时，服务器先生成json数据，然后以JavaScript的语法方式，生成function，function的名字就是传递上来带参数的jsonp，最后将json数据直接以入参的方式，放置在function中，这样子就生成JavaScript语法文档，返回给客户端。客户端浏览器，通过解析，并执行返回JavaScript文档，此时数据作为参数，传入到客户端预先定义好的callback函数中，简单地说，就是**利用script标签没有跨域限制地漏洞来达到第三方通讯的目的（href、src 都不受同源策略的限制。）**\n\n**优点：**\n\n- 它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制，JSONP可以跨越同源策略；\n- 它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；\n\n**缺点:**\n\n- 它**只支持GET请求**而不支持POST等其它类型的HTTP请求\n- 它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。\n- jsonp在调用失败的时候不会返回各种HTTP状态码。\n- 需要后端配合\n\n```javascript\n        function jsonp({url,params,cb}){\n                return new Promise((resolve, reject)=>{\n                        window[cb] = function(data){\n                                console.log(data)\n                                resolve(data);\n                                document.body.removeChild(script);\n                        }//window对象上设置show方法\n                        params= {...params,cb}\n                        let arrs = [];\n                        for (let key in params){\n                                arrs.push(`${key}=${params[key]}`)\n                        }\n                        let script = document.createElement('script');\n                        script.src = `${url}?${arrs.join('&')}`;\n                        script.onerror = () => reject('加载失败') \n                        document.body.appendChild(script);\n                \n\n                })\n        }\n        jsonp({\n                url:\"http://localhost:3000/users\",\n                params:{name:\"jin\",age:12},\n                cb:'show'\n        }).then(data=>{\n                console.log(data)\n        })\n```\n\n后端：\n\n```javascript\nlet express = require('express');\nlet app = express();\napp.get('/users', function(req, res, next) {\n        // 模拟的数据\n        let {name,age,cb} = req.query\n        let data = `\"${name}现在${age}岁\"`\n        res.send(`${cb}(${data})`);// show(data)\n});\n\napp.listen(3000)\n```\n\n## cors跨域\n\n同源策略是不允许接收响应而不是不允许发送请求，所以可以通过在响应头中设置某些字段来允许满足条件的请求跨域，比如设置 `Access-Control-Allow-Origin` 字段允许来自某个源的请求跨域，比如设置 `Access-Control-Allow-Methods` 字段允许'GET'或者'POST'方式的请求跨域\n\n后端：\n\n```javascript\nlet express = require('express');\nlet app = express();\napp.all('*', function (req, res, next) {\n  let origin = req.headers.origin\n        //设置哪个源可以访问我\n  res.header(\"Access-Control-Allow-Origin\",origin);\n        // 允许携带哪个头访问我\n  res.header(\"Access-Control-Allow-Headers\", \"name\");\n        // 允许哪个方法访问我\n  res.header(\"Access-Control-Allow-Methods\", \"POST\");\n        // 允许携带cookie\n  res.set(\"Access-Control-Allow-Credentials\", true);\n        // 预检的存活时间\n  res.header(\"Access-Control-Max-Age\", 6);\n        // 允许前端获取哪个头\n        res.header(\"Access-Control-Expose-Headers\", \"name\");\n        // 请求头的格式\n  res.header(\"Content-Type\", \"application/json;charset=utf-8\");        \n  next();\n});\napp.post('/getData', function(req, res, next) {\n        console.log(req.headers)\n        res.send(\"你拿不到数据了！\");\n});\n\napp.listen(4000)\n```\n\n![img](https://k0x1mohrv2i.feishu.cn/space/api/box/stream/download/asynccode/?code=NDZkMzY0OGQyNDNmNjUxZDIwMjU1MWNlN2E0Mzg4MWFfa29GVk90bXpPWThOWlE3b2RzVFJJclhjRG45R01BaXFfVG9rZW46TlBKZGJkQlJ4b0F3V3h4NDRxWWNHNmxnbldjXzE3NTMxNjg3NjA6MTc1MzE3MjM2MF9WNA)\n\n非简单请求是那种对服务器有特殊要求的请求，比如请求方法是`PUT`或`DELETE`，或者`Content-Type`字段的类型是`application/json`。\n\n非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为\"预检\"请求（preflight）。\n\n浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。 代码修改一下：\n\n```javascript\n// 在请求头的设置中加上\nif(req.method ==='OPTIONS'){\n    res.end();//OPTIONS请求不做任何处理\n}\n```\n\n![img](https://k0x1mohrv2i.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGZhMjliNjM3ZDgyYTViMWZjYjdkZGJkOGMxZDE4YTBfclJZQzR4MzMwZmRpd3J4MEl3UWlqbVE3NEU2UDZwODFfVG9rZW46Qk53bWJ2T2dSb3BoZU14eXNFRmNZN1M0blNYXzE3NTMxNjg3NjA6MTc1MzE3MjM2MF9WNA)\n\n## postMessage跨域\n\n**「window.postMessage()」** 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 https），端口号（443 为 https 的默认值），以及主机 (两个页面的模数 [`Document.domain`]设置为相同的值) 时，这两个脚本才能相互通信。**「window.postMessage()」** 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。\n\n**用途**\n\n1.页面和其打开的新窗口的数据传递\n\n2.多窗口之间消息传递\n\n3.页面与嵌套的 iframe 消息传递\n\n**实现**\n\na.html\n\n```xml\n<iframe src=\"http://localhost:4000/b.html\" frameborder=\"0\" id=\"frame\" onload=\"load()\"></iframe>\n<script>\n    function load(){\n        let frame = document.getElementById('frame');\n        frame.contentWindow.postMessage('你好','http://localhost:4000/');\n        //接收\n        window.onmessage= function(e){\n            console.log(e.data)\n        }\n    }\n</script>\n```\n\nb.html\n\n```xml\nwindow.onmessage = function(e){\n    console.log(e.data);\n    //发送\n    e.source.postMessage('hello',e.origin)\n}\n```\n\n## 本地代理跨域\n\nproxy其实就是因为浏览器同源协议无法请求非同源的地址，但是服务器直接没有同源协议，利用将本地请求转到本地服务器进行代理转发，从而绕过了同源协议的限制，通过代理的实现可以解决跨域的问题\n\n通过设置一个 node 后端作为中间层，前端发送的请求首先到达这个中间层，然后再由中间层将请求转发到目标服务器。响应过程也是如此，服务器先响应给中间层，中间层再将响应数据发送回前端。\n\n这个中间层就起到了一个代理的作用。这样，浏览器看到的是同源请求，从而绕过了CORS限制。\n\n假设前端现在要将请求发送给 [http://192.168.1.63:3000](https://link.juejin.cn?target=http%3A%2F%2F192.168.1.63%3A3000) 这个后端，就可以先由本机的 3001 端口作一个代理\n\n```xml\n<!-- 前端 -->\n<body>\n    <script>\n        const xhr = new XMLHttpRequest()\n        xhr.open('GET', 'https://localhost:3001')\n        xhr.send()\n        xhr.onreadystatechange = function() {\n            if (xhr.readyState === 4 && xhr.status === 200) {\n                console.log(xhr.responseText)\n            }\n        }\n    </script>\n</body>\n```\n\n本机后端\n\n```javascript\n// 后端\nconst http = require('http')\n\n// 监听本机3001端口，有新请求时调用回调函数\nhttp.createServer((req, res)  => {\n\n    // 设置响应头，以允许前端应用访问响应内容\n    res.writeHead(200, {\n        'Access-Control-Allow-Origin': '*'\n    })\n\n    // 转发请求到目标服务器，并处理响应\n    http.request({\n        host: '192.168.1.63',\n        port: 3000,\n        path: '/',\n        method: 'GET',\n        headers: {}\n    }, proxyRes => {\n        proxyRes.on('data', chunk => {\n            res.end(chunk.toString())\n        })\n    }).end()\n    \n}).listen(3001)\n```\n\n### 各脚手架的proxy配置：\n\n#### Webpack (4.x)\n\n在`webpack`中可以配置`proxy`来快速获得接口代理的能力。\n\n```JavaScript\nconst path = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nmodule.exports = {\n  entry: {\n    index: \"./index.js\"\n  },\n  output: {\n    filename: \"bundle.js\",\n    path: path.resolve(__dirname, \"dist\")\n  },\n  devServer: {\n    port: 8000,\n    proxy: {\n      \"/api\": {\n        target: \"http://localhost:8080\"\n      }\n    }\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: \"index.html\",\n      template: \"webpack.html\"\n    })\n  ]\n};\n```\n\n#### **Vue-cli 2.x**\n\n```JavaScript\n// config/index.js\n\n...\nproxyTable: {\n  '/api': {\n     target: 'http://localhost:8080',\n  }\n},\n...\n```\n\n#### Vue-cli 3.x\n\n```JavaScript\n// vue.config.js 如果没有就新建\nmodule.exports = {\n  devServer: {\n    port: 8000,\n    proxy: {\n      \"/api\": {\n        target: \"http://localhost:8080\"\n      }\n    }\n  }\n};\n```\n\n#### vite\n\n```javascript\nimport { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\nimport styleImport, { VantResolve } from 'vite-plugin-style-import';\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [\n    vue(),\n    styleImport({\n      resolves: [VantResolve()],\n    }),],\n    server: { //主要是加上这段代码\n      host: '127.0.0.1',\n      port: 3000,\n      proxy: {\n        '/api': {\n          target: 'http://127.0.0.1:8888',        //实际请求地址\n          changeOrigin: true,\n          rewrite: (path) => path.replace(/^\\/api/, '')\n        },\n      }\n    }\n})\n```\n\n## nginx反向代理跨域\n\n反向代理与本地代理相反。本地代理是客户端搞定的，反向代理就是服务端搞定的\n\n反向代理的是在服务端内部完成。\n\n是服务端（数据应用）向服务端（网页应用）发送数据， 服务端向客户端发送数据 其本质是在服务端（网页应用）通过配置Access-Control-Allow-Origin * 来解决跨域问题。相当于对后端接口进行了统一的cors配置\n\n`Access-Control-Allow-Origin: *` 值表明，该资源可以被**任意**外源访问。\n\n```bash\n    #通过配置nginx文件既可\n    \n    events{}\n\nhttp{\n    include       mime.types;\n    default_type  application/octet-stream;\n    server{\n        listen 80;\n        server_name 127.0.0.1;\n        root D:/nginx-1.26.1/dist;\n        index index.html;\n        location / {\n   \n               location /api {\n                proxy_pass http://127.0.0.1:8080/;\n                proxy_set_header Host $host;\n                proxy_set_header X-Real-IP $remote_addr;\n                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n                proxy_set_header X-Forwarded-Proto $scheme;\n\n                # 解决跨域问题\n                add_header Access-Control-Allow-Origin *;\n                add_header Access-Control-Allow-Methods \"GET, POST, OPTIONS, HEAD, PUT, DELETE\";\n                add_header Access-Control-Allow-Headers \"Origin, X-Requested-With, Content-Type, Accept, Authorization, User-Agent, DNT\";\n                add_header Access-Control-Max-Age 86400;\n\n                \n            }\n        }\n    }\n}\n```\n\n# 设计模式\n\n## 单例模式\n\n```typescript\n// 单例模式示例代码\nclass Singleton {\n  constructor() {\n    if (!Singleton.instance) {\n      Singleton.instance = this;\n    }\n    return Singleton.instance;\n  }\n\n  createInstance() {\n    const object = { name: \"example\" };\n    return object;\n  }\n\n  getInstance() {\n    if (!Singleton.instance) {\n      Singleton.instance = this.createInstance();\n    }\n    return Singleton.instance;\n  }\n}\n\n// 使用示例\nconst instance1 = new Singleton();\nconst instance2 = new Singleton();\n\nconsole.log(instance1 === instance2); // true\n```\n\n## 工厂模式\n\n```javascript\nclass Product {\n  constructor(name) {\n    this.name = name;\n  }\n\n  getName() {\n    return this.name;\n  }\n}\n\nclass ProductFactory {\n  static createProduct(name) {\n    return new Product(name);\n  }\n}\n\n// 使用示例\nconst product = ProductFactory.createProduct(\"Example Product\");\nconsole.log(product.getName()); // \"Example Product\"\n```\n\n## 观察者模式\n\n```javascript\nclass Subject {\n  constructor() {\n    this.observers = [];\n  }\n\n  addObserver(observer) {\n    this.observers.push(observer);\n  }\n\n  removeObserver(observer) {\n    const index = this.observers.indexOf(observer);\n    if (index !== -1) {\n      this.observers.splice(index, 1);\n    }\n  }\n\n  notify(data) {\n    this.observers.forEach(observer => observer.update(data));\n  }\n}\n\nclass Observer {\n  update(data) {\n    console.log(`Received data: ${data}`);\n  }\n}\n\n// 使用示例\nconst subject = new Subject();\nconst observer1 = new Observer();\nconst observer2 = new Observer();\n\nsubject.addObserver(observer1);\nsubject.addObserver(observer2);\n\nsubject.notify(\"Hello World!\");\n```\n\n## 装饰器模式\n\n```java\ninterface Component {\n  operation(): void;\n}\n\nclass ConcreteComponent implements Component {\n  public operation(): void {\n    console.log(\"ConcreteComponent: operation.\");\n  }\n}\n\nclass Decorator implements Component {\n  protected component: Component;\n\n  constructor(component: Component) {\n    this.component = component;\n  }\n\n  public operation(): void {\n    console.log(\"Decorator: operation.\");\n    this.component.operation();\n  }\n}\n\nclass ConcreteDecoratorA extends Decorator {\n  public operation(): void {\n    super.operation();\n    console.log(\"ConcreteDecoratorA: operation.\");\n  }\n}\n\nclass ConcreteDecoratorB extends Decorator {\n  public operation(): void {\n    super.operation();\n    console.log(\"ConcreteDecoratorB: operation.\");\n  }\n}\n\n// 使用示例\nconst concreteComponent = new ConcreteComponent();\nconst concreteDecoratorA = new ConcreteDecoratorA(concreteComponent);\nconst concreteDecoratorB = new ConcreteDecoratorB(concreteDecoratorA);\n\nconcreteDecoratorB.operation();\n```\n\n## 代理模式\n\n```javascript\nconst target = {\n  method() {\n    console.log(\"Target method.\");\n  }\n};\n\nconst proxy = new Proxy(target, {\n  get(target, prop) {\n    console.log(`Called ${prop} method.`);\n    return target[prop];\n  }\n});\n\n// 使用示例\nproxy.method(); // \"Called method method. Target method.\"\n```\n\n## 适配器模式\n\n```javascript\nclass Adaptee {\n  specificRequest() {\n    return \"适配者中的业务代码被调用\";\n  }\n}\n\nclass Target {\n  constructor() {\n    this.adaptee = new Adaptee();\n  }\n\n  request() {\n    let info = this.adaptee.specificRequest();\n    return `${info} - 转换器 - 适配器代码被调用`;\n  }\n}\n\n// 使用示例\nlet target = new Target();\ntarget.request(); // \"适配者中的业务代码被调用 - 转换器 - 适配器代码被调用\"\n```\n\n## MVC模式\n\n```javascript\nclass Model {\n  constructor() {\n    this.data = {\n      name: \"example\",\n      age: 18,\n      gender: \"male\"\n    };\n  }\n\n  setData(key, value) {\n    this.data[key] = value;\n  }\n\n  getData() {\n    return this.data;\n  }\n}\n\nclass View {\n  constructor() {\n    this.container = document.createElement(\"div\");\n  }\n\n  render(data) {\n    const { name, age, gender } = data;\n    this.container.innerHTML = `\n      <p>Name: ${name}</p>\n      <p>Age: ${age}</p>\n      <p>Gender: ${gender}</p>\n    `;\n    document.body.appendChild(this.container);\n  }\n}\n\nclass Controller {\n  constructor(model, view) {\n    this.model = model;\n    this.view = view;\n    this.view.render(this.model.getData());\n  }\n\n  setData(key, value) {\n    this.model.setData(key, value);\n    this.view.render(this.model.getData());\n  }\n}\n\n// 使用示例\nconst model = new Model();\nconst view = new View();\nconst controller = new Controller(model, view);\n\ncontroller.setData(\"age\", 20);\n```\n\n## 策略模式\n\n表单验证情景：\n\n```ts\n// 验证策略\nconst validationStrategies = {\n  required: {\n    validate: (value) => value !== '',\n    message: '该字段不能为空'\n  },\n  \n  minLength: {\n    validate: (value, length) => value.length >= length,\n    message: (length) => `最少需要${length}个字符`\n  },\n  \n  email: {\n    validate: (value) => /^\\S+@\\S+\\.\\S+$/.test(value),\n    message: '请输入有效的邮箱地址'\n  },\n  \n  phone: {\n    validate: (value) => /^1[3-9]\\d{9}$/.test(value),\n    message: '请输入有效的手机号'\n  },\n  \n  custom: {\n    validate: (value, validator) => validator(value),\n    message: '自定义验证失败'\n  }\n};\n\n// 表单验证器\nclass FormValidator {\n  constructor() {\n    this.rules = [];\n  }\n  \n  // 添加验证规则\n  addRule(field, strategy, ...params) {\n    this.rules.push({\n      field,\n      strategy,\n      params\n    });\n  }\n  \n  // 执行验证\n  validate(formData) {\n    const errors = [];\n    \n    for (const rule of this.rules) {\n      const { field, strategy, params } = rule;\n      const value = formData[field];\n      const validationStrategy = validationStrategies[strategy];\n      \n      if (!validationStrategy.validate(value, ...params)) {\n        errors.push({\n          field,\n          message: typeof validationStrategy.message === 'function' \n            ? validationStrategy.message(...params)\n            : validationStrategy.message\n        });\n      }\n    }\n    \n    return {\n      isValid: errors.length === 0,\n      errors\n    };\n  }\n}\n\n// 使用示例\nconst validator = new FormValidator();\nvalidator.addRule('username', 'required');\nvalidator.addRule('username', 'minLength', 3);\nvalidator.addRule('email', 'required');\nvalidator.addRule('email', 'email');\nvalidator.addRule('phone', 'phone');\n\nconst formData = {\n  username: 'ab',\n  email: 'invalid-email',\n  phone: '12345678901'\n};\n\nconst result = validator.validate(formData);\nconsole.log(result);\n// {\n//   isValid: false,\n//   errors: [\n//     { field: 'username', message: '最少需要3个字符' },\n//     { field: 'email', message: '请输入有效的邮箱地址' },\n//     { field: 'phone', message: '请输入有效的手机号' }\n//   ]\n// }\n```\n\n","tags":["秋招","ES","面试题","前端手撕"],"categories":["秋招准备"]},{"title":"【秋招备战】计算机网络","url":"/2025/07/22/【秋招备战】计算机网络/","content":"\n# 前言\n\n计算机网络作为前端开发中绕不开的基础知识，面试时也特爱问，很多时候都有可能被打一个冷不防。这份文档旨在整理前端面试中高频出现的计算机网络知识点，希望能帮助到正在准备面试的你。\n\n内容基于个人面试经验和学习总结，如有不当之处，欢迎指正交流。  本文不追求面面俱到，而是聚焦于前端面试中的高频考点，力求每个知识点都讲透彻、讲实用。\n\n# 一、HTTP 协议篇\n\n## 1.1 HTTP 基础\n\n- **HTTP 是什么？**\n\n  **核心答案：** HTTP（超文本传输协议）是应用层协议，基于TCP/IP，采用请求-响应模式，无状态。用于客户端和服务器之间传输超文本数据。\n\n- **HTTP 请求方法详解**\n\n  **核心答案：**\n\n  - **GET**：获取资源，幂等，可缓存\n  - **POST**：提交数据，非幂等，不可缓存\n  - **PUT**：更新整个资源，幂等\n  - **DELETE**：删除资源，幂等\n  - **HEAD**：获取响应头，不返回body\n  - **OPTIONS**：预检请求，询问支持的方法\n  - **PATCH**：部分更新资源\n\n- **HTTP 状态码分类及常见状态码**\n\n  **核心答案：**\n\n  - **1xx**：信息提示（100 Continue）\n  - **2xx**：成功（200 OK、201 Created、204 No Content）\n  - **3xx**：重定向（301永久、302临时、304未修改）\n  - **4xx**：客户端错误（400 Bad Request、401未授权、403禁止、404未找到）\n  - **5xx**：服务器错误（500内部错误、502网关错误、503服务不可用）\n\n- HTTP 报文结构\n  \n  ```markdown\n  请求报文：\n  请求行：GET /index.html HTTP/1.1\n  请求头：Host: www.example.com\n  空行\n  请求体：（POST请求的数据）\n  \n  响应报文：\n  状态行：HTTP/1.1 200 OK\n  响应头：Content-Type: text/html\n  空行\n  响应体：<html>...</html>\n  ```\n\n## 1.2 HTTP 缓存机制\n\n- 强缓存 vs 协商缓存\n\n  **核心答案：**\n\n  - **强缓存**：不发请求，直接从缓存取（Cache-Control、Expires）\n  - **协商缓存**：发请求询问服务器，资源是否更新（ETag/If-None-Match、Last-Modified/If-Modified-Since）\n\n  **理解tips：**\n\n  - 强缓存像**冰箱里的牛奶**：看保质期（Cache-Control），没过期直接喝\n  - 协商缓存像**打电话问妈妈**：冰箱里的菜还能吃吗？妈妈说能吃（304）就吃，不能吃就买新的（200）\n\n- **Cache-Control 详解**\n\n  ```\n  // 常用指令\n  Cache-Control: max-age=3600     // 强缓存3600秒\n  Cache-Control: no-cache         // 需要协商缓存\n  Cache-Control: no-store         // 不缓存\n  Cache-Control: private          // 只能浏览器缓存\n  Cache-Control: public           // 可以被代理服务器缓存\n  Cache-Control: must-revalidate  // 过期前可用，过期后必须验证\n  ```\n\n  **记忆技巧：** \"max定时间，no-cache要协商，no-store不存储\"\n\n- **ETag 和 Last-Modified**\n\n  **核心答案：**\n\n  - **Last-Modified**：文件最后修改时间（精度秒级，可能误判）\n  - **ETag**：文件内容哈希值（精度高，需要计算）\n\n  **优先级：** ETag > Last-Modified（ETag更准确）\n\n  **实际场景：**\n\n  ```\n  // 第一次请求\n  Response Headers:\n    Last-Modified: Mon, 10 Jan 2024 10:00:00 GMT\n    ETag: \"abc123\"\n  \n  // 第二次请求\n  Request Headers:\n    If-Modified-Since: Mon, 10 Jan 2024 10:00:00 GMT\n    If-None-Match: \"abc123\"\n  \n  // 未修改返回304，修改了返回200+新内容\n  ```\n\n  \n\n- **缓存位置（Memory Cache、Disk Cache等）**\n  \n  **核心答案（优先级从高到低）：**\n  \n  1. **Service Worker**：可编程控制\n  2. **Memory Cache**：内存缓存，快但量小，关闭Tab就没了\n  3. **Disk Cache**：硬盘缓存，慢但量大，持久化\n  4. **Push Cache**：HTTP/2推送缓存，会话级别\n  \n  **记忆口诀：** \"Service控制权最高，Memory快但活不久，Disk慢但能持久，Push是HTTP/2特有\"\n\n## 1.3 HTTP 版本演进\n\n- **HTTP/1.0 vs HTTP/1.1**\n\n  **核心答案：** HTTP/1.1 的改进：\n\n  - **持久连接**：Connection: keep-alive（默认开启）\n  - **管道化**：可以同时发多个请求（但有队头阻塞）\n  - **Host头**：支持虚拟主机\n  - **断点续传**：Range头支持\n  - **缓存增强**：Cache-Control、ETag等\n\n  **理解tips：**\n\n  - HTTP/1.0像**打一次电话说一件事就挂**\n  - HTTP/1.1像**打一次电话可以说多件事**\n\n- **HTTP/2 的优势（多路复用、服务器推送等）**\n\n  **核心答案：**\n\n  - **二进制分帧**：将数据分成帧，不再是文本\n  - **多路复用**：一个TCP连接并行处理多个请求\n  - **头部压缩**：HPACK算法压缩头部\n  - **服务器推送**：主动推送资源\n  - **流优先级**：可以设置请求优先级\n\n  **理解tips：** HTTP/1.1像**单车道**排队通行，HTTP/2像**多车道高速**并行通行\n\n- **HTTP/3 和 QUIC 协议**\n  \n  **核心答案：**\n  \n  - **基于UDP**：避免TCP的队头阻塞\n  - **0-RTT建连**：减少握手延迟\n  - **连接迁移**：IP变化不断连（手机切换WiFi/4G）\n  - **改进的拥塞控制**：更快的恢复\n  \n  **记忆要点：** \"HTTP/3 = HTTP/2 + QUIC(UDP)\"\n\n## 1.4 HTTPS 安全通信\n\n- **HTTP vs HTTPS**\n\n  **核心答案：**\n\n  - HTTP：明文传输，80端口，不安全\n  - HTTPS：HTTP + SSL/TLS加密，443端口，安全\n\n- **HTTPS 加密原理**\n\n  **核心答案（混合加密）：**\n\n  1. **非对称加密**：交换对称密钥（慢但安全）\n  2. **对称加密**：传输数据（快）\n  3. **数字证书**：验证服务器身份\n  4. **摘要算法**：验证数据完整性\n\n  **理解tips：** 像**寄贵重物品**：先用保险箱（对称加密）装东西，用挂号信（非对称加密）寄保险箱钥匙，快递公司的营业执照（数字证书）证明身份\n\n- **HTTPS 握手过程：**\n\n  **精简版答案：**\n\n  1. **Client Hello**：客户端发送支持的加密套件\n  2. **Server Hello**：服务器选择加密套件+发送证书\n  3. **客户端验证证书**：验证证书合法性\n  4. **生成会话密钥**：用服务器公钥加密随机数\n  5. **服务器解密**：得到会话密钥\n  6. **加密通信**：使用会话密钥对称加密\n\n  **中间人攻击：**\n\n  **核心答案：** 攻击者在客户端和服务器之间，分别与两者建立连接，窃取或篡改数据。\n\n  **防御方式：**\n\n  - 数字证书验证\n  - HSTS（强制使用HTTPS）\n  - 证书锁定（Certificate Pinning）\n\n# 二、TCP/IP 协议篇\n\n## 2.1 TCP 基础\n\n- **TCP 三次握手详解**\n\n  **核心答案：**\n\n  1. **SYN**：客户端发送SYN=1, seq=x\n  2. **SYN+ACK**：服务器发送SYN=1, ACK=1, seq=y, ack=x+1\n  3. **ACK**：客户端发送ACK=1, seq=x+1, ack=y+1\n\n  **生动比喻：** 像**打电话**：\n\n  - \"喂，听得到吗？\"（SYN）\n  - \"听得到，你听得到我吗？\"（SYN+ACK）\n  - \"我也听得到\"（ACK）\n\n  **为什么需要三次握手？**\n\n  **核心答案：**\n\n  - 确认双方收发能力正常\n  - 防止已失效的连接请求突然传到服务器\n  - 同步双方序列号\n\n  **两次不行的原因：** 无法确认客户端的接收能力，可能造成服务器资源浪费\n\n- **TCP 四次挥手详解**\n\n  **核心答案：**\n\n  1. **FIN**：客户端发送FIN，进入FIN_WAIT_1\n  2. **ACK**：服务器发送ACK，客户端进入FIN_WAIT_2\n  3. **FIN**：服务器发送FIN，进入LAST_ACK\n  4. **ACK**：客户端发送ACK，进入TIME_WAIT\n\n  **为什么是四次不是三次？** 服务器收到FIN时可能还有数据要发送，所以ACK和FIN分开发送\n\n  **TIME_WAIT 状态的作用：**\n\n  **核心答案：**\n\n  - 持续2MSL（最大报文生存时间）\n  - 作用：\n    1. 确保最后的ACK能到达\n    2. 让所有报文在网络中消失，避免影响新连接\n\n## 2.2 TCP 可靠传输\n\n- **序列号和确认应答**\n\n  **核心答案：**\n\n  - **序列号**：给每个字节编号，保证数据顺序\n  - **确认应答**：ACK=期望收到的下一个序列号\n  - **累积确认**：确认号之前的数据都已收到\n\n  **理解tips：** 像**老师点名**：1号到了，2号到了...如果说\"我要3号\"，说明1、2号都到了\n\n- **超时重传机制**\n\n  **核心答案：**\n\n  - **RTO**（超时时间）= RTT（往返时间）+ 4×RTT偏差\n  - **超时加倍**：每次超时RTO翻倍（避免网络雪崩）\n  - **快速重传**：收到3个重复ACK立即重传（不等超时）\n\n  **记忆要点：** \"超时要等，快重传收3个重复ACK就传\"\n\n- **流量控制（滑动窗口）**\n\n  **核心答案：**\n\n  - **接收窗口**：接收方告诉发送方自己还能接收多少数据\n  - **发送窗口**：发送方根据接收窗口调整发送量\n  - **零窗口探测**：窗口为0时定期发送探测报文\n\n  **生动比喻：** 像**自助餐**：服务员（接收方）告诉你盘子还能装多少（窗口大小），装满了就说\"等一下\"（窗口为0）\n\n- **拥塞控制**\n\n  **核心答案（四个算法）：**\n\n  1. **慢开始**：指数增长（1,2,4,8...）\n  2. **拥塞避免**：线性增长（到达阈值后）\n  3. **快重传**：3个重复ACK立即重传\n  4. **快恢复**：阈值减半，不重新慢开始\n\n  **记忆口诀：** \"慢开始指数增，避免后线性增，快重传3个ACK，快恢复阈值减半\"\n\n## 2.3 TCP vs UDP\n\n- **两者的区别对比**\n\n  **核心答案：**\n\n  | TCP                  | UDP                |\n  | :------------------- | ------------------ |\n  | 可靠传输             | 不可靠             |\n  | 面向连接             | 无连接             |\n  | 字节流               | 数据报             |\n  | 有序                 | 可能乱序           |\n  | 有流量控制、拥塞控制 | 无                 |\n  | 头部20字节           | 头部8字节          |\n  | 一对一               | 支持一对多、多对多 |\n\n  **记忆技巧：** TCP像**打电话**（可靠但费事），UDP像**发短信**（快但不保证送达）\n\n- **各自的应用场景**\n\n  **TCP适用：**\n\n  - HTTP/HTTPS\n  - FTP文件传输\n  - SMTP邮件\n  - SSH远程登录\n\n  **UDP适用：**\n\n  - DNS查询\n  - 视频直播/语音通话\n  - 游戏实时对战\n  - DHCP\n\n- **为什么视频直播常用 UDP？**\n  \n  **核心答案：**\n  \n  - **实时性要求高**：宁可丢帧也不要卡顿\n  - **可以容忍少量丢包**：丢几帧人眼察觉不到\n  - **不需要重传**：重传的旧数据没意义\n\n# 三、浏览器网络篇\n\n## 3.1 跨域问题\n\n- **同源策略是什么？**\n\n  **核心答案：**\n\n  - **同源**：协议+域名+端口都相同\n  - **限制**：DOM访问、Cookie/LocalStorage读取、AJAX请求\n  - **不限制**：`<script>`、`<img>`、`<link>`标签\n\n  **记忆要点：** \"协议域名端口，三同才同源\"\n\n- **跨域的解决方案汇总**\n\n  **核心答案（按常用度排序）：**\n\n  1. **CORS**：服务器设置Access-Control-Allow-Origin\n  2. **代理服务器**：同源服务器转发请求\n  3. **JSONP**：script标签+回调函数\n  4. **WebSocket**：没有同源限制\n  5. **postMessage**：iframe通信\n\n- **CORS 详解**\n\n  **核心答案：**\n\n  ```\n  // 简单请求（GET/POST/HEAD + 简单头）\n  Access-Control-Allow-Origin: *\n  Access-Control-Allow-Credentials: true  // 携带Cookie\n  \n  // 预检请求（复杂请求先发OPTIONS）\n  Access-Control-Allow-Methods: GET, POST, PUT\n  Access-Control-Allow-Headers: Content-Type, X-Token\n  Access-Control-Max-Age: 86400  // 预检缓存时间\n  ```\n\n  **触发预检的条件：**\n\n  - 非简单请求方法（PUT/DELETE等）\n  - 自定义请求头\n  - Content-Type不是简单类型\n\n- **JSONP 原理及限制**\n\n  **核心答案：**\n\n  ```javascript\n  // 原理：动态创建script标签\n  function jsonp(url, callback) {\n    const script = document.createElement('script');\n    window[callback] = function(data) {\n      console.log(data);\n      delete window[callback];\n      document.body.removeChild(script);\n    }\n    script.src = `${url}?callback=${callback}`;\n    document.body.appendChild(script);\n  }\n  ```\n\n  **限制：**\n\n  - 只支持GET请求\n  - 可能XSS攻击\n  - 错误处理困难\n\n## 3.2 经典问题：从 URL 到页面展示\n\n非常详细的一片回答：https://bytetech.info/articles/6903166461217341454?searchId=2025081516181986474146815928AE395F\n\n## 3.3 WebSocket\n\n- **WebSocket vs HTTP**\n\n  **核心答案：**\n\n  | **HTTP**         | **WebSocket**    |\n  | ---------------- | ---------------- |\n  | 半双工           | 全双工           |\n  | 无状态           | 有状态           |\n  | 请求-响应模式    | 持久连接         |\n  | 文本/二进制      | 帧协议           |\n  | 每次请求都有头部 | 建立后头部开销小 |\n\n- **WebSocket 连接过程**\n\n  **核心答案：**\n\n  ```\n  // 1. 握手请求（HTTP升级）\n  GET /ws HTTP/1.1\n  Upgrade: websocket\n  Connection: Upgrade\n  Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\n  \n  // 2. 握手响应\n  HTTP/1.1 101 Switching Protocols\n  Upgrade: websocket\n  Connection: Upgrade\n  Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=\n  \n  // 3. 数据传输（使用帧）\n  const ws = new WebSocket('ws://localhost:8080');\n  ws.onmessage = (e) => console.log(e.data);\n  ws.send('Hello Server');\n  ```\n\n  应用场景：\n\n  - 实时聊天\n  - 实时推送\n  - 协同编辑\n  - 实时游戏\n  - 股票行情\n\n# 四、Web 安全篇\n\n## 4.1 XSS 攻击\n\n- **XSS 类型（反射型、存储型、DOM型）**\n\n  **核心答案：**\n\n  1. **反射型XSS**：URL参数直接输出到页面\n  2. **存储型XSS**：恶意脚本存入数据库\n  3. **DOM型XSS**：修改DOM节点触发\n\n  **记忆口诀：** \"反射即时现，存储入库险，DOM改节点\"\n\n- **XSS 防御策略**\n\n  ```js\n  // 1. 输入过滤（不可靠）\n  // 2. 输出转义（核心）\n  function escape(str) {\n    return str\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&#x27;');\n  }\n  \n  // 3. CSP内容安全策略\n  Content-Security-Policy: default-src 'self'\n  \n  // 4. HttpOnly Cookie（防止JS读取）\n  Set-Cookie: session=abc; HttpOnly\n  ```\n\n- **CSP 内容安全策略**\n  \n  ```\n  // 限制资源加载来源\n  Content-Security-Policy: \n    default-src 'self';           // 默认同源\n    script-src 'self' cdn.com;    // JS来源\n    style-src 'self' 'unsafe-inline'; // CSS来源\n    img-src *;                     // 图片来源\n    connect-src api.example.com;  // AJAX/WebSocket\n  ```\n  \n  \n\n## 4.2 CSRF 攻击\n\n- **CSRF 攻击原理**\n\n  **核心答案：** 跨站请求伪造：利用用户已登录的身份，诱导用户访问恶意网站，恶意网站向目标网站发送请求。\n\n  **攻击流程：**\n\n  1. 用户登录银行网站，有了Cookie\n  2. 用户访问恶意网站\n  3. 恶意网站发送转账请求到银行\n  4. 浏览器自动带上Cookie\n  5. 银行执行转账\n\n  **生动比喻：** 像**偷用你的身份证**：你登录了银行（有身份证明），骗子网站偷偷拿你的身份证明去办事\n\n- **CSRF 防御方法**\n\n  ```\n  // 1. CSRF Token\n  // 服务器生成token放在表单中\n  <input type=\"hidden\" name=\"csrf_token\" value=\"random_token\">\n  \n  // 2. 验证Referer\n  if (request.headers.referer !== 'https://mybank.com') {\n    return 403;\n  }\n  \n  // 3. SameSite Cookie\n  Set-Cookie: session=abc; SameSite=Strict;  // 完全禁止第三方\n  Set-Cookie: session=abc; SameSite=Lax;     // 部分允许（链接可以）\n  Set-Cookie: session=abc; SameSite=None;    // 都允许（需HTTPS）\n  \n  // 4. 双重Cookie验证\n  // Cookie中和请求参数都带token，服务器对比\n  ```\n\n  **记忆要点：** \"Token验身份，Referer看来源，SameSite限Cookie\"\n\n\n# 五、性能优化篇\n\n## 5.1 网络层优化\n\n- **减少 HTTP 请求数**\n\n  ```\n  // 1. 资源合并\n  // CSS Sprites、JS/CSS打包\n  \n  // 2. 内联资源\n  // 小图片base64、关键CSS内联\n  \n  // 3. 使用缓存\n  // 强缓存避免请求\n  \n  // 4. 懒加载\n  // 图片懒加载、路由懒加载\n  ```\n\n- **使用 HTTP/2**\n\n  **核心答案：**\n\n  - 多路复用减少连接数\n  - 服务器推送关键资源\n  - 头部压缩减少传输量\n  - 请求优先级优化加载顺序\n\n- **启用 Gzip 压缩**\n\n  ```\n  // Nginx配置\n  gzip on;\n  gzip_types text/plain text/css application/javascript;\n  gzip_min_length 1024;\n  gzip_comp_level 6;  // 压缩级别1-9\n  \n  // 效果：通常能压缩60-80%\n  ```\n\n- **使用 CDN**\n\n  **核心答案：**\n\n  - **就近访问**：用户访问最近节点\n  - **负载均衡**：分散服务器压力\n  - **缓存静态资源**：减少源站压力\n  - **抗DDoS**：分布式架构\n\n  **记忆要点：** \"CDN = 内容分发网络，让用户就近拿资源\"\n\n  \n\n## 5.2 资源加载优化\n\n- **预加载（preload、prefetch）**\n\n  ```html\n  <!-- preload：当前页面必需，高优先级 -->\n  <link rel=\"preload\" href=\"style.css\" as=\"style\">\n  <link rel=\"preload\" href=\"font.woff2\" as=\"font\" crossorigin>\n  \n  <!-- prefetch：未来页面需要，低优先级 -->\n  <link rel=\"prefetch\" href=\"next-page.js\">\n  \n  <!-- dns-prefetch：预解析DNS -->\n  <link rel=\"dns-prefetch\" href=\"//api.example.com\">\n  \n  <!-- preconnect：预建立连接(DNS+TCP+TLS) -->\n  <link rel=\"preconnect\" href=\"//api.example.com\">\n  ```\n\n- **懒加载**\n\n  ```js\n  // 1. 图片懒加载\n  // Intersection Observer API\n  const observer = new IntersectionObserver((entries) => {\n    entries.forEach(entry => {\n      if (entry.isIntersecting) {\n        const img = entry.target;\n        img.src = img.dataset.src;\n        observer.unobserve(img);\n      }\n    });\n  });\n  \n  // 2. 路由懒加载\n  const Home = () => import('./views/Home.vue');\n  \n  // 3. 组件懒加载\n  const HeavyComponent = React.lazy(() => import('./Heavy'));\n  ```\n\n  \n\n- **图片优化策略**\n\n  ```html\n  // 1. 选择合适格式\n  WebP > JPEG/PNG    // 新浏览器\n  JPEG：照片        // 有损压缩\n  PNG：透明图       // 无损压缩\n  SVG：图标矢量图   // 可缩放\n  \n  // 2. 响应式图片\n  <picture>\n    <source srcset=\"image.webp\" type=\"image/webp\">\n    <source srcset=\"image.jpg\" type=\"image/jpeg\">\n    <img src=\"image.jpg\" alt=\"\">\n  </picture>\n  \n  // 3. 图片尺寸\n  <img srcset=\"320w.jpg 320w, 640w.jpg 640w\" \n       sizes=\"(max-width: 320px) 320px, 640px\">\n  \n  // 4. 渐进式加载\n  // 先模糊后清晰（如知乎、Medium）\n  ```\n\n  \n\n# 六、实战题目篇\n\n（收录各大公司真实面试题及详解）","tags":["秋招","计算机网络","面试八股文"],"categories":["秋招准备"]},{"title":"【建站日志】Simon成功搬家","url":"/2025/06/12/【建站日志】Simon已着陆/","content":"\n之前用Wordpress建的网站突然炸了T_T，只好搬家到Hexo这边来，虽然之前就想换成ssg静态网站就是了。毕竟Wordpress博客系统上传文章太便秘了，完全用不惯他的文本编辑器，还是MD大法好啊！\n","tags":["建站日志","生活记录"]}]