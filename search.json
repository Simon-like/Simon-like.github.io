[{"title":"面试手撕大集合","url":"/2025/07/22/面试手撕大集合/","content":"\n# **所有遍历数组的方法**\n\n\n\n1. ## forEach\n\n```JavaScript\n// 自定义 forEach 函数，添加到 Array 原型链\nArray.prototype.myForEach = function (callback, thisArg) {\n\n    // 类型检查：确保 callback 是一个函数\n    if (typeof callback !== 'function') {\n        throw new TypeError('第一个参数必须是一个函数');\n    }\n\n    // 遍历数组，调用 callback 函数\n    for (let i = 0; i < this.length; i++) {\n        // 如果数组的当前元素是 undefined 或 null, 则跳过\n        if (i in this) {//对于数组而言，in运算符用于检查是否有这个索引值\n            callback.call(thisArg, this[i], i, this);\n        }\n    }\n};\n```\n\n1. ## map\n\n```JavaScript\n// 自定义 Map 函数，添加到 Array 原型链\nArray.prototype.myMap = function (callback) {\n\n    // 类型检查：确保 callback 是一个函数\n    if (typeof callback !== 'function') {\n        throw new TypeError('第一个参数必须是一个函数');\n    }\n    let res = [];\n\n    // 遍历数组，调用 callback 函数\n    for (let i = 0; i < this.length; i++) {\n        // 如果数组的当前元素是 undefined 或 null, 则跳过\n        if (i in this) {\n            res.push(callback(this[i], i, this));\n        }\n    }\n    return res\n};\n```\n\n1. ## Filter\n\n```JavaScript\nArray.prototype.my_filter = function (cb) {\n    let newArr = []\n    for (var i = 0; i < this.length; i++) {\n        if (cb(this[i], i, this)) {\n            newArr.push(this[i])\n        }\n    }\n    return newArr\n}\n```\n\n1. ## every(判断数组中的每一个元素是否都满足某个条件)\n\n```JavaScript\nArray.prototype.my_every = function (cb) {\n    for (let i = 0; i < this.length; i++) {\n        if (!cb(this[i], i, this)) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n1. ## some（判断数组中是否存在一个元素满足某个条件）\n\n```JavaScript\nArray.prototype.my_some = function (cb) {\n    for (let i = 0; i < this.length; i++) {\n        if (cb(this[i], i, this)) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n1. ## reduce\n\n```JavaScript\nArray.prototype.my_reduce = function (cb, ...args) {\n    let start, index = 0\n    if (args.length) {\n        start = args[0]\n    } else {\n        start = this[0];\n        index = 1\n    }\n    for (let i = index; i < this.length; i++) {\n        start = cb(start, this[i], i, this);\n    }\n    return start;\n}\n```\n\n1. ## includes\n\n```JavaScript\nArray.prototype.my_includes = function (item, ...args) {\n    let index\n    if (args.length && !Number.isNaN(Number(args[0])) && Number(args[0])>0) {\n        index = Number(args[0])\n    } else {\n        index = 0;\n    }\n    for (let i = index; i < this.length; i++) {\n        if (this[i] === item) return true;\n    }\n    return false\n}\n```\n\n1. ## splice\n\n```JavaScript\nlet arr = ['a', 'b', 'c', 'd', 'e']\n\nArray.prototype.my_splice = function (start, len, ...args) {\n   // 如果没有任何参数传递，直接返回空数组\n    if (arguments.length === 0) {\n        return [];\n    }\n    \n    // 如果 start 是 undefined，设置为 0\n    if (start === undefined) {\n        start = 0;\n    }else if(start<0){\n        start = this.length+start \n        start = !!start?start:0\n    }\n\n    // 如果 len 是 undefined，设置为 0\n    if (len === undefined) {\n        len = 0;\n    }\n    \n    const res = [], newArr = []\n    for (let i = 0; i < this.length; i++) {\n        if (i < start || i >= start + len) {\n            newArr.push(this[i])\n        } else {\n            res.push(this[i])\n        }\n        //还有要添加的值是存放在args里的，所以我们还要把args中的值添加到原数组中去\n        if (i === start - 1) {\n            newArr.push(...args)\n        }\n    }\n    \n    while (this.length) {\n        this.pop()\n    }\n    this.push(...newArr)\n    return res\n}\n```\n\n# JS内置方法、对象以及运算符\n\n1. ## new运算符\n\n```javascript\nfunction myNew (Func, ...arg){\n        if (fn.prototype === undefined) throw new TypeError('function is not a constructor');\n        let obj = {}  //定义了一个对象。\n        obj.__proto__ = Func.prototype  \n        //将Func.prototype赋值为对象的__proto__属性,即原型链的概念\n        let res = Func.call(obj, ...arg) //更改Func的this指向\n        return res instanceof Object ? res : obj \n}\n```\n\n1. ## 手撕curry\n\n```javascript\nconst my_curry = (fn, ...args) =>\n    args.length >= fn.length\n        ? fn(...args)\n        : (...args1) => my_curry(fn, ...args, ...args1);\n\nfunction adder(x, y, z) {\n    return x + y + z;\n}\nconst add = my_curry(adder);\nconsole.log(add(1, 2, 3));  //6\nconsole.log(add(1)(2)(3));  //6\nconsole.log(add(1, 2)(3));  //6\nconsole.log(add(1)(2, 3));  //6\n```\n\n1. ## 手写compose函数\n\n```JavaScript\nconst compose = (...fns)=>(x)=>fns.reduceRight((v, fn)=>fn(v),x);\nconst doubleAndSuare = compose(double, square);//先翻倍再平方\nconsole.log(doubleAndSuare(3));\n```\n\n1. ## 手撕vue3响应式代理\n\n```javascript\n//测试代码\nclass Depend {\n  constructor() {\n    this.reactiveFns = new Set()//依赖组\n  }\n\n  // 更好的收集依赖\n  depend() {\n    if (activeReactiveFn) this.reactiveFns.add(activeReactiveFn)\n  }\n\n  //对所有依赖进行统一通知处理\n  notify() {\n    console.log(this.reactiveFns)\n    this.reactiveFns.forEach(fn => {\n      //遍历依赖处理\n      if (fn) fn()\n    })\n  }\n}\n\n// 封装响应式函数\nlet activeReactiveFn = null\nfunction watchFn(fn) {\n  activeReactiveFn = fn\n  fn()\n  activeReactiveFn = null\n}\n\n// 封装一个获取depend函数\nconst targetMap = new WeakMap()\nfunction getDepend(target, key) {\n  // 1、根据target对象获取map的过程\n  let map = targetMap.get(target)\n  if (!map) {\n    map = new Map()\n    targetMap.set(target, map)\n  }\n  // 2、根据对象属性获取depend依赖\n  let depend = map.get(key)\n  if (!depend) {\n    depend = new Depend()\n    map.set(key, depend)\n  }\n  return depend\n}\n\n\n//使用Proxy监听对象变化\nfunction reactive(obj) {\n  return new Proxy(obj, {\n    get: function (target, key, receiver) {\n      const depend = getDepend(target, key)\n      depend.depend()\n      return Reflect.get(target, key, receiver)\n    },\n    set: function (target, key, newValue, receiver) {\n      Reflect.set(target, key, newValue, receiver)\n      const depend = getDepend(target, key)\n      depend.notify()\n    }\n  })\n}\n\nconst obj = {\n  name: \"coderwhy\",//depend实例对象\n  age: 18//depend实例对象\n}\n\nconst info = {\n  name:\"小余\",\n  age:18\n}\n//响应式开关媒介\nconst objRef = reactive({\n  name: \"coderwhy\",\n  age: 18\n})\nconst infoRef = reactive({\n  name:\"小余\",\n  age:18\n})\n\nwatchFn(() => {\n  console.log(infoRef.name);  \n})\nwatchFn(() => {\n  console.log(objRef.name);  \n})\n\ninfoRef.name = '响应式-小余'\nobjRef.name = '响应式-coderwhy'\n\n// 小余\n// coderwhy\n// Set(1) { [Function (anonymous)] }\n// 响应式-小余\n// Set(1) { [Function (anonymous)] }\n// 响应式-coderwhy\n```\n\n1. ## 手撕instanceof\n\n```sql\nconst myInstanceOf=(Left,Right)=>{\n  if(!Left){\n    return false\n  }\n  while(Left){\n    if(Left.__proto__===Right.prototype){\n      return true\n    }else{\n      Left=Left.__proto__\n    }\n  }\n  return false\n}\n\n//验证\nconsole.log(myInstanceOf({},Array));  //false\n```\n\n1. ## call，bind，apply\n\n```javascript\nfunction foo(x,y){\n  console.log(this.a,x+y);\n}\n\nconst obj={\n  a:1\n}\n\nFunction.prototype.myCall=function(context,...args){\n  if(typeof this !== 'function')  return new TypeError('is not a function')\n  const fn = Symbol('fn') //使用Symbol尽可能降低myCall对其他的影响\n  context[fn] = this  //this指向foo\n  const res = context[fn](...args)  //解构，调用fn\n  delete context[fn]  //不要忘了删除obj上的工具函数fn\n  return res  //将结果返回\n}\n\n//验证\nfoo.myCall(obj,1,2)   //1,3\n\nfunction foo(x,y){\n  console.log(this.a,x+y);\n}\n\nconst obj={\n  a:1\n}\n\nFunction.prototype.myApply=function(context,args){\n  if(typeof this !== 'function')  return new TypeError('is not a function')\n  const fn = Symbol('fn') //使用Symbol尽可能降低myCall对其他的影响\n  context[fn] = this  //this指向foo\n  const res = context[fn](...args)  //解构，调用fn\n  delete context[fn]  //不要忘了删除obj上的工具函数fn\n  return res  //将结果返回\n}\n\n//验证\nfoo.myApply(obj,1,2)   //1,3\n\nfunction foo(x,y,z){\n  this.name='zt'\n  console.log(this.a,x+y+z);\n}\n\nconst obj={\n  a:1\n}\n\nFunction.prototype.myBind=function(context,...args){\n  if(typeof this !== 'function')  return new TypeError('It is not a function');\n  context = context || window; // 上下文环境\n  const _this = this; // 当前的函数的上下文this\n  return function F(...arg) {\n    //判断返回出去的F有没有被new，有就要把foo给到new出来的对象\n    if (this instanceof F) {\n       return new _this(...args, ...arg);\n    } else {\n       _this.call(this, ...args, ...arg);\n    }\n  }\n}\n\n//验证\nconst bar=foo.myBind(obj,1,2)\nconsole.log(new bar(3));   //undefined 6  foo { name: 'zt' }\n```\n\n1. ## 值相等\n\n```javascript\nfunction compare(data1, data2) {\n  if (typeof data1 != typeof data2) {\n    return false;\n  }\n\n  if (typeof data1 != \"object\" && typeof data1 == typeof data2) {\n    return data1 === data2;\n  }\n\n  if ((!data1 instanceof Array && data2 instanceof Array) || (data1 instanceof Array && !data2 instanceof Array)) {\n    return false;\n  } else if (data1 instanceof Array  && data2 instanceof Array) {\n    if (data1.length == data2.length) {\n      for (let i = 0; i < data1.length; i++) {\n        if (!compare(data1[i], data2[i])) {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n  } else {\n      if (Object.keys(data1).length == Object.keys(data2).length) {\n      for (let key in data1) {\n        if (!data2[key] || !compare(data1[key], data2[key])) {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\n```\n\n1. ## 深拷贝\n\n```javascript\nfunction isObject(value) {\n  const valueType = typeof value\n  return (value !== null) && (valueType === \"object\" || valueType === \"function\")\n}\n\nfunction deepClone(originValue) {\n  // 判断传入的originValue是否是一个对象类型\n  if (!isObject(originValue)) {\n    return originValue\n  }\n\n  const newObject = {}\n  for (const key in originValue) {\n    newObject[key] = deepClone(originValue[key])\n  }\n  //返回通过递归深层遍历赋值后，全新的数据对象\n  return newObject\n}\n```\n\n1. ## 实现Object.create()\n\n创建一个空对象，定义其原型对象并设置其枚举属性\n\n```javascript\n// proto 可以是object 或者function\nObject.myCreate = function (proto, defineProperties){\n    if((typeof proto === 'object' && proto !== null) || typeof proto === 'function'){\n        let obj = {};\n\n        // obj.__proto__ = proto;\n        Object.setPrototypeOf(obj, proto);\n        Object.defineProperty(obj, defineProperties);\n        return obj;\n    }else {\n        throw new TypeError('类型错误');\n    }\n}\n```\n\n1. ## 实现Object.assign（浅拷贝）\n\n```javascript\nfunction myAssign(target,...objs){\n    if(target === null || target === undefined){\n        throw new TypeError(\"can not convert null or undefined to object\")\n    }\n    let res = Object(target)\n    objs.forEach(obj => {\n        'use strict'\n        if(obj != null && obj != undefined){\n            for(let key in obj){\n                //hasOwnProperty用来判断一个属性是定义在对象本身而不是继承自原型链的\n                if(Object.prototype.hasOwnProperty.call(obj,key)){\n                    res[key] = obj[key]\n                }\n            }\n        }\n    })\n    return res\n}\nObject.defineProperty(Object,'myAssign',{\n    value: myAssign,\n    writable: true,\n    configurable: true,\n    enumerable: false\n})\n```\n\n1. ## trim方法\n\n```javascript\nfunction myTrim(str) {\n  const reg = /^\\s+|\\s+$/g;\n  return str.replace(reg, '');\n}\n```\n\n1. ## 模板字符串\n\n```javascript\nconst render = (template, data) => {\n    const reg = /\\$\\{(.*?)\\}/g;\n    template = template.replace(reg, (match, key) => {\n        let keys = key.trim().split('.');\n        return keys.reduce((obj, k) => obj?.[k], data) || '';\n    })\n    return template;\n}\n```\n\n1. ## sleep函数\n\n```javascript\nfunction sleep(ms) {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            console.log('sleep...')\n            resolve()\n        }, ms);\n    })\n}\n\nasync function test(){\n    console.log('1');\n    await sleep(400)\n    console.log('2')\n}\n\ntest();\n```\n\n1. ## 利用setTimeout实现setInterval\n\n```javascript\nfunction coustomSetInterval(callback, time) {\n    let intervalId = null;\n    function loop() {\n        intervalId = setTimeout(() => {\n            callback();\n            loop();\n        }, time)\n    }\n    loop();\n    return () => clearTimeout(intervalId)\n}\nconst interval = coustomSetInterval(() => {\n    console.log('想你了')\n}, 1000)\n\nsetTimeout(() => {\n    interval()\n}, 5000)\n```\n\n# Promise手撕大全\n\n1. ## promise基础\n\n**基本结构：**\n\n```javascript\nclass MyPromise {\n    constructor(executor) {\n        // 定义 resolve\n        let resolve = res => {}\n        // 定义 reject\n        let reject = err => {}\n\n        // 自动执行\n        executor(resolve, reject);\n    }\n}\n```\n\n**基本状态：**\n\nPromise有三种状态：\n\n- pending [待定] 初始状态\n- fulfilled [实现] 操作成功\n- rejected [被否决] 操作失败\n\npromise 状态有如下特点:\n\n1.promise 对象初始化状态为 pending。\n\n2.当调用resolve(成功)，会由pending => fulfilled。\n\n3.当调用reject(失败)，会由pending => rejected。\n\n```javascript\nclass Promise {\n    constructor(executor) {\n        this.status = \"pending\"; // 默认状态\n        this.value;  // resolve 成功时的值\n        this.error;  // reject 失败时的值\n\n        let resolve = res => {\n            if(this.status === \"pending\") {\n                this.value = res;\n                this.status = \"resolved\";\n            }\n        }\n\n        let reject = err => {\n            if(this.status === \"pending\") {\n                this.error = err;\n                this.status = \"rejected\";\n            }\n        }\n\n        executor(resolve, reject);\n    }\n}\n```\n\n1. ## then方法实现\n\n该方法接收两个回调：onFulfilled(成功)、onRejected(失败回调)\n\npromise.then(onFulfilled, onRejected); 1.onFulfilled(onResolved)：可选参数，如果不是函数则必须忽略。 2.onRejected：可选参数，如果不是函数则必须忽略。 3.当promise成功执行，所有onFulfilled按注册顺序执行，如果promise被拒绝，所有onRejected按注册顺序执行。 4.onFulfilled 和 onRejected必须作为**纯函数调用**。 5.promise的executor执行完毕并调用resolve或reject方可调用then参数onFulfilled 和 onRejected。 6.无论promise状态是resolved还是rejected，**只要还有未执行onFulfilled,onRejected或catch（只处理reject状态）存在且调用，返回的promise均为resolved状态。**\n\n```JavaScript\nconst PROMISE_STATUS_PENDING = 'pending'\nconst PROMISE_STATUS_FULFILLED = 'fulfilled'\nconst PROMISE_STATUS_REJECTED = 'rejected'\n\n// 工具函数\nfunction execFunctionWithCatchError(execFn, value, resolve, reject) {\n    try {\n        const result = execFn(value)\n        resolve(result)\n    } catch (err) {\n        reject(err)\n    }\n}\n\nclass MyPromise {\n    constructor(executor) {\n        this.status = PROMISE_STATUS_PENDING\n        this.value = undefined\n        this.reason = undefined\n        this.onFulfilledFns = []\n        this.onRejectedFns = []\n\n        const resolve = (value) => {\n            if (this.status === PROMISE_STATUS_PENDING) {\n\n                // 检测 value 是否为 Promise\n                if (value instanceof MyPromise) {\n                    // 如果 value 是 Promise，等待它兑现或拒绝\n                    value.then(resolve, reject);\n                    return;\n                }\n\n                // 检测 value 是否为 thenable\n                if (value !== null && (typeof value === 'object' || typeof value === 'function')) {\n                    let then;\n                    try {\n                        then = value.then;\n                    } catch (error) {\n                        reject(error);\n                        return;\n                    }\n\n                    // 如果 then 是函数，认为 value 是一个 thenable 对象\n                    if (typeof then === 'function') {\n                        let called = false; // 避免多次调用\n                        try {\n                            then.call(value, (y) => {\n                                if (called) return;\n                                called = true;\n                                resolve(y);\n                            }, (r) => {\n                                if (called) return;\n                                called = true;\n                                reject(r);\n                            });\n                        } catch (error) {\n                            if (called) return;\n                            called = true;\n                            reject(error);\n                        }\n                        return;\n                    }\n                }\n\n                // 添加微任务\n                queueMicrotask(() => {\n                    if (this.status !== PROMISE_STATUS_PENDING) return\n                    this.status = PROMISE_STATUS_FULFILLED\n                    this.value = value\n                    this.onFulfilledFns.forEach(fn => {\n                        fn(this.value)\n                    })\n                });\n            }\n        }\n\n        const reject = (reason) => {\n            if (this.status === PROMISE_STATUS_PENDING) {\n\n                // 检测 value 是否为 Promise\n                if (reason instanceof MyPromise) {\n                    // 如果 value 是 Promise，等待它兑现或拒绝\n                    value.then(resolve, reject);\n                    return;\n                }\n\n                // 检测 value 是否为 thenable\n                if (reason !== null && (typeof reason === 'object' || typeof reason === 'function')) {\n                    let then;\n                    try {\n                        then = reason.then;\n                    } catch (error) {\n                        reject(error);\n                        return;\n                    }\n\n                    // 如果 then 是函数，认为 value 是一个 thenable 对象\n                    if (typeof then === 'function') {\n                        let called = false; // 避免多次调用\n                        try {\n                            then.call(reason, (y) => {\n                                if (called) return;\n                                called = true;\n                                resolve(y);\n                            }, (r) => {\n                                if (called) return;\n                                called = true;\n                                reject(r);\n                            });\n                        } catch (error) {\n                            if (called) return;\n                            called = true;\n                            reject(error);\n                        }\n                        return;\n                    }\n                }\n\n                // 添加微任务\n                queueMicrotask(() => {\n                    if (this.status !== PROMISE_STATUS_PENDING) return\n                    this.status = PROMISE_STATUS_REJECTED\n                    this.reason = reason\n                    this.onRejectedFns.forEach(fn => {\n                        fn(this.reason)\n                    })\n                })\n            }\n        }\n\n        try {\n            executor(resolve, reject)\n        } catch (err) {\n            reject(err)\n        }\n    }\n\n    then(onFulfilled, onRejected) {\n        return new MyPromise((resolve, reject) => {\n            // 1.如果在then调用的时候, 状态已经确定下来\n            if (this.status === PROMISE_STATUS_FULFILLED && onFulfilled) {\n                execFunctionWithCatchError(onFulfilled, this.value, resolve, reject)\n            }\n            if (this.status === PROMISE_STATUS_REJECTED && onRejected) {\n                execFunctionWithCatchError(onRejected, this.reason, resolve, reject)\n            }\n\n            // 2.将成功回调和失败的回调放到数组中\n            if (this.status === PROMISE_STATUS_PENDING) {\n                this.onFulfilledFns.push(() => {\n                    execFunctionWithCatchError(onFulfilled, this.value, resolve, reject)\n                })\n                this.onRejectedFns.push(() => {\n                    execFunctionWithCatchError(onRejected, this.reason, resolve, reject)\n                })\n            }\n        })\n    }\n    catch(onRejected) {\n        this.then(undefined, onRejected);\n    }\n}\n\nconst promise = new MyPromise((resolve, reject) => {\n    console.log(\"状态pending\")\n    resolve(2222)\n})\n\n// 调用then方法多次调用\npromise.then(res => {\n    console.log(\"res1:\", res)\n    return new Promise((resolve, reject) => {\n        console.log(\"状态pending-----\")\n        reject('simon' + res);\n    })\n}, err => {\n    console.log(\"err1:\", err)\n    return \"bbbbb\"\n}).then(res => {\n    console.log(\"res2:\", res)\n}, err => {\n    console.log(\"err2:\", err)\n})\n```\n\n1. ## Promise.reject和Promise.resolve\n\n```javascript\nclass MyPromise {\n    // ...\n    // 将现有对象转为 Promise 对象\n    static resolve(value) {\n        // 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。\n        if (value instanceof Promise) return value;\n\n        // 参数是一个thenable对象（具有then方法的对象）,Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。\n        if (typeof value === 'object' || typeof value === 'function') {\n            try {\n                let then = value.then;\n                if (typeof then === 'function') {\n                    return new Promise(then.bind(value));\n                }\n            } catch (e) {\n                return new Promise((resolve, reject) => {\n                    reject(e);\n                })\n            }\n        }\n\n        // 参数不是具有then方法的对象，或根本就不是对象,Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。\n        return new Promise((resolve, reject) => {\n            resolve(value);\n        })\n    }\n}\n\n\nclass MyPromise {\n    // ...\n    // 返回一个新的 Promise 实例，该实例的状态为rejected。\n    static reject(reason) {\n        return new Promise((resolve, reject) => {\n            reject(reason);\n        })\n    }\n}\n```\n\n1. ## Promise.catch\n\n```javascript\nclass MyPromise {\n    // ...\n    // 是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。\n    catch(onRejected) {\n        return this.then(undefined, onRejected);\n    }\n}\n```\n\n1. ## Promise.finally\n\n```javascript\nclass MyPromise {\n    // ...\n    // 用于指定不管 Promise 对象最后状态如何，都会执行的操作。\n    finally(callback) {\n        return this.then(\n            value => Promise.resolve(callback()).then(() => value),\n            reason => Promise.resolve(callback()).then(() => { throw reason })\n        )\n    }\n}\n```\n\n1. ## Promise.all方法\n\n```javascript\nstatic all(promises) {\n  // 问题关键: 什么时候要执行resolve, 什么时候要执行reject\n  return new MyPromise((resolve, reject) => {\n    //存储所有遍历resolve结果\n    const values = []\n    promises.forEach(promise => {\n      promise.then(res => {\n        //收集所有成功结果\n        values.push(res)\n        //promise全部正常调用resolve，返回存储所有内容的结果\n        if (values.length === promises.length) {\n          resolve(values)\n        }\n      }, err => {\n        //有一个拒绝状态，则直接返回err内容\n        reject(err)\n      })\n    })\n  })\n}\n```\n\n1. ## Promise.allSettled方法\n\n```javascript\nstatic allSettled(promises) {\n  // 问题关键: 什么时候要执行resolve, 什么时候要执行reject\n  return new MyPromise((resolve, reject) => {\n    const values = []\n    promises.forEach(promise => {\n      promise.then(res => {\n        values.push({ status: PROMISE_STATUS_FULFILLED, value: res })\n        if (values.length === promises.length) resolve(values)\n      }, err => {\n        values.push({ status: PROMISE_STATUS_REJECTED, reason: err })\n        if (values.length === promises.length) resolve(values)\n      })\n    })\n  })\n}\n```\n\n1. ## Promise.race方法\n\n```javascript\nstatic race(promises) {\n  return new HYPromise((resolve, reject) => {\n    promises.forEach(promise => {\n      // promise.then(res => {\n      //   resolve(res)\n      // }, err => {\n      //   reject(err)\n      // })\n      //代码优化\n      promise.then(resolve, reject)\n    })\n  })\n}\n```\n\n1. ## Promise.any方法\n\n```javascript\nstatic any(promises) {\n  // resolve必须等到有一个成功的结果\n  // reject所有的都失败才执行reject\n  const reasons = []\n  return new HYPromise((resolve, reject) => {\n    promises.forEach(promise => {\n      promise.then(resolve, err => {\n        reasons.push(err)\n        if (reasons.length === promises.length) {\n          reject(new AggregateError(reasons))\n        }\n      })\n    })\n  })\n}\n```\n\n1. ## Async await原理\n\n```javascript\nfunction run(genF) {\n    // 返回值是Promise\n    return new Promise((resolve, reject) => {\n        const gen = genF();\n        function step(nextF) {\n            let next;\n            try {\n                // 执行该函数，获取一个有着value和done两个属性的对象\n                next = nextF();\n            } catch (e) {\n                // 出现异常则将该Promise变为rejected状态\n                reject(e);\n            }\n\n            // 判断是否到达末尾，Generator函数到达末尾则将该Promise变为fulfilled状态\n            if (next.done) {\n                return resolve(next.value);\n            }\n\n            // 没到达末尾，则利用Promise封装该value，直到执行完毕，反复调用step函数，实现自动执行\n            Promise.resolve(next.value).then((v) => {\n                step(() => gen.next(v))\n            }, (e) => {\n                step(() => gen.throw(e))\n            })\n        }\n\n        step(() => gen.next(undefined));\n    })\n}\n或者使用迭代器函数\nfunction readFile(file) {\n        return new Promise(resolve => {\n                setTimeout(() => {\n                        resolve(file);\n    }, 1000);\n        })\n};\n\nfunction asyncFunc(generator) {\n        const iterator = generator(); // 接下来要执行next\n  // data为第一次执行之后的返回结果，用于传给第二次执行\n  const next = (data) => {\n                let { value, done } = iterator.next(data); // 第二次执行，并接收第一次的请求结果 data\n    \n    if (done) return; // 执行完毕(到第三次)直接返回\n    // 第一次执行next时，yield返回的 promise实例 赋值给了 value\n    value.then(data => {\n      next(data); // 当第一次value 执行完毕且成功时，执行下一步(并把第一次的结果传递下一步)\n    });\n  }\n  next();\n};\n\nasyncFunc(function* () {\n        // 生成器函数：控制代码一步步执行 \n  let data = yield readFile('a.js'); // 等这一步骤执行执行成功之后，再往下走，没执行完的时候，直接返回\n  data = yield readFile(data + 'b.js');\n  return data;\n})\n```\n\n# 模板渲染引擎\n\n```xml\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>模板渲染示例</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n\n    <script src=\"script.js\"></script>\n</body>\n</html>\n// 渲染引擎\nfunction renderTemplate(template, data) {\n\n    // 处理条件判断\n    template = template.replace(/{{\\s*#if\\s*(\\w+)\\s*}}([\\s\\S]*?){{\\s*\\/if\\s*}}/g, function (_, condition, content) {\n        return data[condition] ? content : '';\n    });\n\n    // 处理循环\n    template = template.replace(/{{\\s*#each\\s*(\\w+)\\s*}}([\\s\\S]*?){{\\s*\\/each\\s*}}/g, function (_, arrayKey, content) {\n        let result = '';\n        let array = data[arrayKey];\n        if (Array.isArray(array)) {\n            array.forEach((item, index) => {\n                // 创建一个独立作用域，避免冲突\n                let temp = content;\n                // 替换模板内的 {{ this }} 为循环项\n                temp = temp.replace(/{{\\s*this\\s*}}/g, function () {\n                    return item;\n                });\n                // 如果是对象，处理它的属性\n                temp = temp.replace(/{{\\s*this\\.(\\w+)\\s*}}/g, function (_, prop) {\n                    return item[prop] || '';\n                });\n                // 替换循环索引（如果需要）\n                temp = temp.replace(/{{\\s*index\\s*}}/g, index);\n                // 将处理后的结果添加到最终结果中\n                result += temp;\n            });\n        }\n        return result;\n    });\n    // 替换变量，一定要放到最后！！\n    template = template.replace(/\\{\\{(.*?)\\}\\}/g, (match, key) => {\n        let keys = key.trim().split('.');\n        return keys.reduce((obj, k) => obj?.[k], data) || '';\n    })\n\n    return template;\n}\n\n// 定义数据\nconst data = {\n    name: \"张三\",\n    age: 25,\n    isEmployed: true,\n    occupation: \"工程师\",\n    hobbies: [\"阅读\", \"编程\", \"旅游\"],\n    friends: [\n        { name: \"李四\", age: 26 },\n        { name: \"王五\", age: 24 }\n    ]\n};\n\n// 定义模板\nconst template = `\n    <h1>个人信息</h1>\n    <p>姓名: {{ name }}</p>\n    <p>年龄: {{ age }}</p>\n    <p>职业: {{ occupation }}</p>\n\n    {{#if isEmployed}}\n        <p>当前状态: 在职</p>\n    {{/if}}\n\n    <h2>兴趣爱好</h2>\n    <ul>\n        {{#each hobbies}}\n            <li>{{ this }}</li>\n        {{/each}}\n    </ul>\n\n    <h2>朋友列表</h2>\n    <ul>\n        {{#each friends}}\n            <li>{{ this.name }} - {{ this.age }} 岁</li>\n        {{/each}}\n    </ul>\n`;\n\n// 渲染模板并插入 HTML\ndocument.getElementById('app').innerHTML = renderTemplate(template, data);\n```\n\n# 防抖截流\n\n```JavaScript\nconst debounce = (fn, ms, Immediate = false) => {\n    // Immediate选择是否立即执行\n    let timer = null;\n    return function (...thisArgs) {\n        if (timer) {\n            clearTimeout(timer)\n        }\n        if (Immediate) {\n            let flag = !timer\n            flag && fn.apply(this, thisArgs)\n            timer = setTimeout(() => {\n                timer = null\n            }, ms)\n        } else {\n            timer = setTimeout(() => {\n                fn.apply(this, thisArgs)\n                timer = null\n            }, ms)\n        }\n    }\n}\n\nconst throttle = (fn, ms) => {\n    let timer = null;\n    return function (...thisArgs) {\n        if (!timer) {\n            fn.apply(this, thisArgs);\n            timer = setTimeout(() => {\n                timer = null;\n            }, ms);\n        }\n    }\n}\n```\n\n# 技巧\n\n1. ## 数组去重\n\n```javascript\nlet arr = [1, 0, 2, 3, 4, 5, 2, 3, 4];\n//indexOf去重\nfunction removeRepeat(arr) {\n  let res = [];\n  for (let i of arr) {\n    if (res.indexOf(i) == -1) {\n      res.push(i);\n    }\n  }\n  return res;\n}\n// set 去重\nfunction removeRepeat(arr) {\n  let res = new Set(arr);\n  return Array.from(res);\n}\n// for循环去重\nfunction removeRepeat(arr) {\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] == arr[j]) {\n        arr.splice(j, 1);\n        j--;\n      }\n    }\n  }\n  return arr;\n}\n// filter 去重\nfunction removeRepeat(arr) {\n  return arr.filter((item, index) => {\n    return arr.indexOf(item) == index;\n  });\n}\n// includes 去重\nfunction removeRepeat(arr) {\n  let res = [];\n  for (let i of arr) {\n    if (!res.includes(i)) {\n      res.push(i);\n    }\n  }\n  return res;\n}\nlet res = removeRepeat(arr);\nconsole.log(res);\n```\n\n1. ## 快排和归并\n\n```javascript\nArray.prototype.quicksort = function (l, r) {\n    if (l >= r) return this;\n    let key = this[l];\n    let i = l - 1, j = r + 1;\n    while (i < j) {\n        do i++; while (this[i] < key);\n        do j--; while (this[j] > key);\n        if (i < j) [this[i], this[j]] = [this[j], this[i]];\n    }\n    this.quicksort(l, j);\n    this.quicksort(j + 1, r);\n    return this;\n}\nlet arr = [5,8,3,6,4,2];\nconsole.log(arr.quicksort(0, arr.length-1));\n\n\nArray.prototype.mergesort = function (temp, l, r) {\n    if (l >= r) return this;\n    let mid = l + r >> 1;\n    this.mergesort(temp, l, mid);\n    this.mergesort(temp, mid + 1, r);\n\n    let i = l, j = mid + 1, k = 0;\n    while (i <= mid && j <= r) {\n        if (this[i] <= this[j]) temp[k++] = this[i++];\n        else temp[k++] = this[j++];\n    }\n    while (i <= mid) temp[k++] = this[i++];\n    while (j <= r) temp[k++] = this[j++];\n\n    for (let m = 0, n = l; n <= r; m++, n++) {\n        this[n] = temp[m];\n    }\n    return this;\n}\n\nlet arr = [7, 1, 0, 3, 0, 5, 6, 4];\nconsole.log(arr.mergesort(Array(arr.length).fill(0), 0, arr.length - 1));\n```\n\n1. ## 下划线和驼峰相互转换\n\n```javascript\n//方式一：操作字符串数组\nfunction transformStr2Hump1(str) {\n    if(str == null) {\n        return \"\";\n    }\n    var strArr = str.split('-');\n    for(var i = 1; i < strArr.length; i++) {\n        strArr[i] = strArr[i].charAt(0).toUpperCase() + strArr[i].substring(1);\n    }\n    return strArr.join('');\n}\n\n//方式二：操作字符数组\nfunction transformStr2Hump2(str) {\n    if(str == null) {\n        return \"\";\n    }\n    var strArr  =str.split('');\n    for(var i = 0; i < strArr.length; i++) {\n        if(strArr[i] == \"-\"){\n            //删除-\n            strArr.splice(i, 1);\n            //将该处改为大写\n            if(i < strArr.length) {\n                strArr[i] = strArr[i].toUpperCase();\n            }\n        }\n    }\n    return strArr.join(\"\");\n}\n\n//方式三：利用正则\nfunction transformStr2Hump3(str) {\n    if(str == null) {\n        return \"\";\n    }\n    var reg = /-(\\w)/g;//匹配字母或数字或下划线或汉字\n    return str.replace(reg, function($0, $1) {\n        return $1.toUpperCase();\n    })\n}\n```\n\n1. ## 懒加载\n\n- 首先，不要将图片地址放到src属性中，而是放到其它属性(data-original)中。\n- 页面加载完成后，根据scrollTop判断图片是否在用户的视野内，如果在，则将data-original属性中的值取出存放到src属性中。\n- 在滚动事件中重复判断图片是否进入视野，如果进入，则将data-original属性中的值取出存放到src属性中。\n\n>  elementNode.getAttribute(name)：方法通过名称获取属性的值。\n>\n>  elementNode.setAttribute(name, value)：方法创建或改变某个新属性。\n>\n>  elementNode.removeAttribute(name)：方法通过名称删除属性的值。\n\n```javascript\n//懒加载代码实现\nvar viewHeight = document.documentElement.clientHeight;//可视化区域的高度\n\nfunction lazyload () {\n    //获取所有要进行懒加载的图片\n    let eles = document.querySelectorAll('img[data-original][lazyload]');//获取属性名中有data-original的\n    Array.prototype.forEach.call(eles, function(item, index) {\n        let rect;\n        if(item.dataset.original === '') {\n            return;\n        }\n\n        rect = item.getBoundingClientRect();\n\n        //图片一进入可视区，动态加载\n        if(rect.bottom >= 0 && rect.top < viewHeight) {\n            !function () {\n                let img = new Image();\n                img.src = item.dataset.original;\n                img.onload = function () {\n                    item.src = img.src;\n                }\n                item.removeAttribute('data-original');\n                item.removeAttribute('lazyload');\n            }();\n        }\n    })\n}\n\nlazyload();\n\ndocument.addEventListener('scroll', lazyload);\n```\n\n1. ## 数组扁平化\n\n```javascript\n//传入参数 决定扁平化的阶数\nArray.prototype._flat = function (n) {\n    let result = [];\n    let num = n;\n    for (let item of this) {\n        // 如果是数组\n        if (Array.isArray(item)) {\n            n--;\n            //   没有扁平化的空间 直接推入\n            if (n < 0) {\n                result.push(item);\n            }\n            // 继续扁平化 并将n传入 决定item这一个数组中的扁平化\n            else {\n                result.push(...item._flat(n));\n            }\n        }\n        // 不是数组直接推入\n        else {\n            result.push(item);\n        }\n        // 每次循环 重置n 为传入的参数 因为每一项都需要扁平化 需要进行判断\n        n = num;\n    }\n    return result;\n};\nlet arr = [1, 2, [3, 4], [5, 6, [7, 8]]];\nlet res = arr._flat(1);\nconsole.log(res); // [ 1, 2, 3, 4, 5, 6, [ 7, 8 ] ]\n```\n\n1. ## 计算属性\n\n请不要为所有函数添加缓存！\n\n```javascript\nconst computed = (func, content) => {\n    let cache = Object.create(null);\n    content = content || this;\n    return (...key) => {\n        console.log(cache)\n        if (!cache[key]) {\n            cache[key] = func.apply(content, key);\n        }\n        return cache[key];\n    }\n}\n```\n\n1. ## 有并发限制的Promise调度器\n\n```JavaScript\nclass Scheduler{\n    constructor(limit){\n        this.limit = limit;\n        this.running = 0;\n        this.queue = [];\n    }\n    createTask(callback, duration){\n        return ()=>{\n            return new Promise((resolve, reject)=>{\n                setTimeout(()=>{\n                    callback();\n                    resolve();\n                },duration);\n            });\n        };\n    }\n    \n    add(callback, duration){\n        const task = this.createTask(callback, duration);\n        this.queue.push(task);\n    }\n    \n    start(){\n        for(let i=0;i<this.limit;++i){\n            this.schedule();\n        }\n    }\n    schedule(){\n        if(this.queue.length === 0 || this.running >= this.limit)return;\n        this.running++;\n        const task = this.queue.shift();\n        \n        task().then(()=>{\n            this.running--;\n            schedule();\n        });\n    }\n}\n```\n\n# 网络请求和跨域解决方案\n\n1. ## 原生ajax\n\n```javascript\nfunction sendajax() {\n    // 1、 初始化xhr对象\n    const xhr = new XMLHttpRequest();\n    //  2、 建立连接 设置请求方法和url\n    xhr.open(\"get\", \"./data.json\");\n    //   3、发送请求\n    xhr.send();\n    //   4、状态改变时 进行回调\n    xhr.onreadystatechange = function () {\n        // readyState 有0-4 五个值\n        // 0 代表 未初始化 1 代表 初始化成功 2 代表发送请求\n        // 3 代表返回了部分数据 4 代表返回了全部数据\n        if (xhr.readyState == 4) {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                //   进行成功的操作\n                console.log(xhr.responseText);\n            }\n        }\n    };\n}\nsendajax();\n```\n\n1. ## JSONP跨域\n\n首先在客户端注册一个callback，然后把callback的名字传给服务器。此时，服务器先生成json数据，然后以JavaScript的语法方式，生成function，function的名字就是传递上来带参数的jsonp，最后将json数据直接以入参的方式，放置在function中，这样子就生成JavaScript语法文档，返回给客户端。客户端浏览器，通过解析，并执行返回JavaScript文档，此时数据作为参数，传入到客户端预先定义好的callback函数中，简单地说，就是**利用script标签没有跨域限制地漏洞来达到第三方通讯的目的（href、src 都不受同源策略的限制。）**\n\n**优点：**\n\n- 它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制，JSONP可以跨越同源策略；\n- 它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；\n\n**缺点:**\n\n- 它**只支持GET请求**而不支持POST等其它类型的HTTP请求\n- 它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。\n- jsonp在调用失败的时候不会返回各种HTTP状态码。\n- 需要后端配合\n\n```javascript\n        function jsonp({url,params,cb}){\n                return new Promise((resolve, reject)=>{\n                        window[cb] = function(data){\n                                console.log(data)\n                                resolve(data);\n                                document.body.removeChild(script);\n                        }//window对象上设置show方法\n                        params= {...params,cb}\n                        let arrs = [];\n                        for (let key in params){\n                                arrs.push(`${key}=${params[key]}`)\n                        }\n                        let script = document.createElement('script');\n                        script.src = `${url}?${arrs.join('&')}`;\n                        script.onerror = () => reject('加载失败') \n                        document.body.appendChild(script);\n                \n\n                })\n        }\n        jsonp({\n                url:\"http://localhost:3000/users\",\n                params:{name:\"jin\",age:12},\n                cb:'show'\n        }).then(data=>{\n                console.log(data)\n        })\n```\n\n后端：\n\n```javascript\nlet express = require('express');\nlet app = express();\napp.get('/users', function(req, res, next) {\n        // 模拟的数据\n        let {name,age,cb} = req.query\n        let data = `\"${name}现在${age}岁\"`\n        res.send(`${cb}(${data})`);// show(data)\n});\n\napp.listen(3000)\n```\n\n1. ## cors跨域\n\n同源策略是不允许接收响应而不是不允许发送请求，所以可以通过在响应头中设置某些字段来允许满足条件的请求跨域，比如设置 `Access-Control-Allow-Origin` 字段允许来自某个源的请求跨域，比如设置 `Access-Control-Allow-Methods` 字段允许'GET'或者'POST'方式的请求跨域\n\n后端：\n\n```javascript\nlet express = require('express');\nlet app = express();\napp.all('*', function (req, res, next) {\n  let origin = req.headers.origin\n        //设置哪个源可以访问我\n  res.header(\"Access-Control-Allow-Origin\",origin);\n        // 允许携带哪个头访问我\n  res.header(\"Access-Control-Allow-Headers\", \"name\");\n        // 允许哪个方法访问我\n  res.header(\"Access-Control-Allow-Methods\", \"POST\");\n        // 允许携带cookie\n  res.set(\"Access-Control-Allow-Credentials\", true);\n        // 预检的存活时间\n  res.header(\"Access-Control-Max-Age\", 6);\n        // 允许前端获取哪个头\n        res.header(\"Access-Control-Expose-Headers\", \"name\");\n        // 请求头的格式\n  res.header(\"Content-Type\", \"application/json;charset=utf-8\");        \n  next();\n});\napp.post('/getData', function(req, res, next) {\n        console.log(req.headers)\n        res.send(\"你拿不到数据了！\");\n});\n\napp.listen(4000)\n```\n\n![img](https://k0x1mohrv2i.feishu.cn/space/api/box/stream/download/asynccode/?code=NDZkMzY0OGQyNDNmNjUxZDIwMjU1MWNlN2E0Mzg4MWFfa29GVk90bXpPWThOWlE3b2RzVFJJclhjRG45R01BaXFfVG9rZW46TlBKZGJkQlJ4b0F3V3h4NDRxWWNHNmxnbldjXzE3NTMxNjg3NjA6MTc1MzE3MjM2MF9WNA)\n\n非简单请求是那种对服务器有特殊要求的请求，比如请求方法是`PUT`或`DELETE`，或者`Content-Type`字段的类型是`application/json`。\n\n非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为\"预检\"请求（preflight）。\n\n浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。 代码修改一下：\n\n```javascript\n// 在请求头的设置中加上\nif(req.method ==='OPTIONS'){\n    res.end();//OPTIONS请求不做任何处理\n}\n```\n\n![img](https://k0x1mohrv2i.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGZhMjliNjM3ZDgyYTViMWZjYjdkZGJkOGMxZDE4YTBfclJZQzR4MzMwZmRpd3J4MEl3UWlqbVE3NEU2UDZwODFfVG9rZW46Qk53bWJ2T2dSb3BoZU14eXNFRmNZN1M0blNYXzE3NTMxNjg3NjA6MTc1MzE3MjM2MF9WNA)\n\n1. ## postMessage跨域\n\n**「window.postMessage()」** 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 https），端口号（443 为 https 的默认值），以及主机 (两个页面的模数 [`Document.domain`]设置为相同的值) 时，这两个脚本才能相互通信。**「window.postMessage()」** 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。\n\n**用途**\n\n1.页面和其打开的新窗口的数据传递\n\n2.多窗口之间消息传递\n\n3.页面与嵌套的 iframe 消息传递\n\n**实现**\n\na.html\n\n```xml\n<iframe src=\"http://localhost:4000/b.html\" frameborder=\"0\" id=\"frame\" onload=\"load()\"></iframe>\n<script>\n    function load(){\n        let frame = document.getElementById('frame');\n        frame.contentWindow.postMessage('你好','http://localhost:4000/');\n        //接收\n        window.onmessage= function(e){\n            console.log(e.data)\n        }\n    }\n</script>\n```\n\nb.html\n\n```xml\nwindow.onmessage = function(e){\n    console.log(e.data);\n    //发送\n    e.source.postMessage('hello',e.origin)\n}\n```\n\n1. ## 本地代理跨域\n\nproxy其实就是因为浏览器同源协议无法请求非同源的地址，但是服务器直接没有同源协议，利用将本地请求转到本地服务器进行代理转发，从而绕过了同源协议的限制，通过代理的实现可以解决跨域的问题\n\n通过设置一个 node 后端作为中间层，前端发送的请求首先到达这个中间层，然后再由中间层将请求转发到目标服务器。响应过程也是如此，服务器先响应给中间层，中间层再将响应数据发送回前端。\n\n这个中间层就起到了一个代理的作用。这样，浏览器看到的是同源请求，从而绕过了CORS限制。\n\n假设前端现在要将请求发送给 [http://192.168.1.63:3000](https://link.juejin.cn?target=http%3A%2F%2F192.168.1.63%3A3000) 这个后端，就可以先由本机的 3001 端口作一个代理\n\n```xml\n<!-- 前端 -->\n<body>\n    <script>\n        const xhr = new XMLHttpRequest()\n        xhr.open('GET', 'https://localhost:3001')\n        xhr.send()\n        xhr.onreadystatechange = function() {\n            if (xhr.readyState === 4 && xhr.status === 200) {\n                console.log(xhr.responseText)\n            }\n        }\n    </script>\n</body>\n```\n\n本机后端\n\n```javascript\n// 后端\nconst http = require('http')\n\n// 监听本机3001端口，有新请求时调用回调函数\nhttp.createServer((req, res)  => {\n\n    // 设置响应头，以允许前端应用访问响应内容\n    res.writeHead(200, {\n        'Access-Control-Allow-Origin': '*'\n    })\n\n    // 转发请求到目标服务器，并处理响应\n    http.request({\n        host: '192.168.1.63',\n        port: 3000,\n        path: '/',\n        method: 'GET',\n        headers: {}\n    }, proxyRes => {\n        proxyRes.on('data', chunk => {\n            res.end(chunk.toString())\n        })\n    }).end()\n    \n}).listen(3001)\n```\n\n### 各脚手架的proxy配置：\n\n#### Webpack (4.x)\n\n在`webpack`中可以配置`proxy`来快速获得接口代理的能力。\n\n```JavaScript\nconst path = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nmodule.exports = {\n  entry: {\n    index: \"./index.js\"\n  },\n  output: {\n    filename: \"bundle.js\",\n    path: path.resolve(__dirname, \"dist\")\n  },\n  devServer: {\n    port: 8000,\n    proxy: {\n      \"/api\": {\n        target: \"http://localhost:8080\"\n      }\n    }\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: \"index.html\",\n      template: \"webpack.html\"\n    })\n  ]\n};\n```\n\n#### **Vue-cli 2.x**\n\n```JavaScript\n// config/index.js\n\n...\nproxyTable: {\n  '/api': {\n     target: 'http://localhost:8080',\n  }\n},\n...\n```\n\n#### Vue-cli 3.x\n\n```JavaScript\n// vue.config.js 如果没有就新建\nmodule.exports = {\n  devServer: {\n    port: 8000,\n    proxy: {\n      \"/api\": {\n        target: \"http://localhost:8080\"\n      }\n    }\n  }\n};\n```\n\n#### vite\n\n```javascript\nimport { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\nimport styleImport, { VantResolve } from 'vite-plugin-style-import';\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [\n    vue(),\n    styleImport({\n      resolves: [VantResolve()],\n    }),],\n    server: { //主要是加上这段代码\n      host: '127.0.0.1',\n      port: 3000,\n      proxy: {\n        '/api': {\n          target: 'http://127.0.0.1:8888',        //实际请求地址\n          changeOrigin: true,\n          rewrite: (path) => path.replace(/^\\/api/, '')\n        },\n      }\n    }\n})\n```\n\n## nginx反向代理跨域\n\n反向代理与本地代理相反。本地代理是客户端搞定的，反向代理就是服务端搞定的\n\n反向代理的是在服务端内部完成。\n\n是服务端（数据应用）向服务端（网页应用）发送数据， 服务端向客户端发送数据 其本质是在服务端（网页应用）通过配置Access-Control-Allow-Origin * 来解决跨域问题。相当于对后端接口进行了统一的cors配置\n\n`Access-Control-Allow-Origin: *` 值表明，该资源可以被**任意**外源访问。\n\n```bash\n    #通过配置nginx文件既可\n    \n    events{}\n\nhttp{\n    include       mime.types;\n    default_type  application/octet-stream;\n    server{\n        listen 80;\n        server_name 127.0.0.1;\n        root D:/nginx-1.26.1/dist;\n        index index.html;\n        location / {\n   \n               location /api {\n                proxy_pass http://127.0.0.1:8080/;\n                proxy_set_header Host $host;\n                proxy_set_header X-Real-IP $remote_addr;\n                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n                proxy_set_header X-Forwarded-Proto $scheme;\n\n                # 解决跨域问题\n                add_header Access-Control-Allow-Origin *;\n                add_header Access-Control-Allow-Methods \"GET, POST, OPTIONS, HEAD, PUT, DELETE\";\n                add_header Access-Control-Allow-Headers \"Origin, X-Requested-With, Content-Type, Accept, Authorization, User-Agent, DNT\";\n                add_header Access-Control-Max-Age 86400;\n\n                \n            }\n        }\n    }\n}\n```\n\n# 设计模式\n\n1. ## 单例模式\n\n```typescript\n// 单例模式示例代码\nclass Singleton {\n  constructor() {\n    if (!Singleton.instance) {\n      Singleton.instance = this;\n    }\n    return Singleton.instance;\n  }\n\n  createInstance() {\n    const object = { name: \"example\" };\n    return object;\n  }\n\n  getInstance() {\n    if (!Singleton.instance) {\n      Singleton.instance = this.createInstance();\n    }\n    return Singleton.instance;\n  }\n}\n\n// 使用示例\nconst instance1 = new Singleton();\nconst instance2 = new Singleton();\n\nconsole.log(instance1 === instance2); // true\n```\n\n1. ## 工厂模式\n\n```javascript\nclass Product {\n  constructor(name) {\n    this.name = name;\n  }\n\n  getName() {\n    return this.name;\n  }\n}\n\nclass ProductFactory {\n  static createProduct(name) {\n    return new Product(name);\n  }\n}\n\n// 使用示例\nconst product = ProductFactory.createProduct(\"Example Product\");\nconsole.log(product.getName()); // \"Example Product\"\n```\n\n1. ## 观察者模式\n\n```javascript\nclass Subject {\n  constructor() {\n    this.observers = [];\n  }\n\n  addObserver(observer) {\n    this.observers.push(observer);\n  }\n\n  removeObserver(observer) {\n    const index = this.observers.indexOf(observer);\n    if (index !== -1) {\n      this.observers.splice(index, 1);\n    }\n  }\n\n  notify(data) {\n    this.observers.forEach(observer => observer.update(data));\n  }\n}\n\nclass Observer {\n  update(data) {\n    console.log(`Received data: ${data}`);\n  }\n}\n\n// 使用示例\nconst subject = new Subject();\nconst observer1 = new Observer();\nconst observer2 = new Observer();\n\nsubject.addObserver(observer1);\nsubject.addObserver(observer2);\n\nsubject.notify(\"Hello World!\");\n```\n\n1. ## 装饰器模式\n\n```java\ninterface Component {\n  operation(): void;\n}\n\nclass ConcreteComponent implements Component {\n  public operation(): void {\n    console.log(\"ConcreteComponent: operation.\");\n  }\n}\n\nclass Decorator implements Component {\n  protected component: Component;\n\n  constructor(component: Component) {\n    this.component = component;\n  }\n\n  public operation(): void {\n    console.log(\"Decorator: operation.\");\n    this.component.operation();\n  }\n}\n\nclass ConcreteDecoratorA extends Decorator {\n  public operation(): void {\n    super.operation();\n    console.log(\"ConcreteDecoratorA: operation.\");\n  }\n}\n\nclass ConcreteDecoratorB extends Decorator {\n  public operation(): void {\n    super.operation();\n    console.log(\"ConcreteDecoratorB: operation.\");\n  }\n}\n\n// 使用示例\nconst concreteComponent = new ConcreteComponent();\nconst concreteDecoratorA = new ConcreteDecoratorA(concreteComponent);\nconst concreteDecoratorB = new ConcreteDecoratorB(concreteDecoratorA);\n\nconcreteDecoratorB.operation();\n```\n\n1. ## 代理模式\n\n```javascript\nconst target = {\n  method() {\n    console.log(\"Target method.\");\n  }\n};\n\nconst proxy = new Proxy(target, {\n  get(target, prop) {\n    console.log(`Called ${prop} method.`);\n    return target[prop];\n  }\n});\n\n// 使用示例\nproxy.method(); // \"Called method method. Target method.\"\n```\n\n1. ## 适配器模式\n\n```javascript\nclass Adaptee {\n  specificRequest() {\n    return \"适配者中的业务代码被调用\";\n  }\n}\n\nclass Target {\n  constructor() {\n    this.adaptee = new Adaptee();\n  }\n\n  request() {\n    let info = this.adaptee.specificRequest();\n    return `${info} - 转换器 - 适配器代码被调用`;\n  }\n}\n\n// 使用示例\nlet target = new Target();\ntarget.request(); // \"适配者中的业务代码被调用 - 转换器 - 适配器代码被调用\"\n```\n\n1. ## MVC模式\n\n```javascript\nclass Model {\n  constructor() {\n    this.data = {\n      name: \"example\",\n      age: 18,\n      gender: \"male\"\n    };\n  }\n\n  setData(key, value) {\n    this.data[key] = value;\n  }\n\n  getData() {\n    return this.data;\n  }\n}\n\nclass View {\n  constructor() {\n    this.container = document.createElement(\"div\");\n  }\n\n  render(data) {\n    const { name, age, gender } = data;\n    this.container.innerHTML = `\n      <p>Name: ${name}</p>\n      <p>Age: ${age}</p>\n      <p>Gender: ${gender}</p>\n    `;\n    document.body.appendChild(this.container);\n  }\n}\n\nclass Controller {\n  constructor(model, view) {\n    this.model = model;\n    this.view = view;\n    this.view.render(this.model.getData());\n  }\n\n  setData(key, value) {\n    this.model.setData(key, value);\n    this.view.render(this.model.getData());\n  }\n}\n\n// 使用示例\nconst model = new Model();\nconst view = new View();\nconst controller = new Controller(model, view);\n\ncontroller.setData(\"age\", 20);\n```","tags":["秋招","ES","面试题","前端手撕"],"categories":["秋招准备"]},{"title":"【秋招备战】计算机网络","url":"/2025/07/22/【秋招备战】计算机网络/","content":"\n# 前言\n\n计算机网络作为前端开发中绕不开的基础知识，面试时也特爱问，很多时候都有可能被打一个冷不防。这份文档旨在整理前端面试中高频出现的计算机网络知识点，希望能帮助到正在准备面试的你。\n\n内容基于个人面试经验和学习总结，如有不当之处，欢迎指正交流。  本文不追求面面俱到，而是聚焦于前端面试中的高频考点，力求每个知识点都讲透彻、讲实用。\n\n# 一、HTTP 协议篇\n\n## 1.1 HTTP 基础\n\n- HTTP 是什么？\n- HTTP 请求方法详解\n- HTTP 状态码分类及常见状态码\n- HTTP 报文结构\n  - \n\n## 1.2 HTTP 缓存机制\n\n- 强缓存 vs 协商缓存\n- Cache-Control 详解\n- ETag 和 Last-Modified\n- 缓存位置（Memory Cache、Disk Cache等）\n  - \n\n## 1.3 HTTP 版本演进\n\n- HTTP/1.0 vs HTTP/1.1\n- HTTP/2 的优势（多路复用、服务器推送等）\n- HTTP/3 和 QUIC 协议\n  - \n\n## 1.4 HTTPS 安全通信\n\n- HTTP vs HTTPS\n- HTTPS 加密原理\n- 证书验证过程\n- 中间人攻击\n  - \n\n# 二、TCP/IP 协议篇\n\n## 2.1 TCP 基础\n\n- TCP 三次握手详解\n- TCP 四次挥手详解\n- 为什么需要三次握手？两次行不行？\n- TIME_WAIT 状态的作用\n  - \n\n## 2.2 TCP 可靠传输\n\n- 序列号和确认应答\n- 超时重传机制\n- 流量控制（滑动窗口）\n- 拥塞控制\n  - \n\n## 2.3 TCP vs UDP\n\n- 两者的区别对比\n- 各自的应用场景\n- 为什么视频直播常用 UDP？\n  - \n\n# 三、浏览器网络篇\n\n## 3.1 跨域问题\n\n- 同源策略是什么？\n- 跨域的解决方案汇总\n- CORS 详解\n- JSONP 原理及限制\n- 其他跨域方案\n  - \n\n## 3.2 经典问题：从 URL 到页面展示\n\n- DNS 解析过程\n- 建立 TCP 连接\n- 发送 HTTP 请求\n- 服务器处理请求\n- 浏览器渲染页面\n  - \n\n## 3.3 WebSocket\n\n- WebSocket vs HTTP\n- WebSocket 连接过程\n- 应用场景\n  - \n\n# 四、Web 安全篇\n\n## 4.1 XSS 攻击\n\n- XSS 类型（反射型、存储型、DOM型）\n- XSS 防御策略\n- CSP 内容安全策略\n  - \n\n## 4.2 CSRF 攻击\n\n- CSRF 攻击原理\n- CSRF 防御方法\n- SameSite Cookie\n  - \n\n## 4.3 其他安全问题\n\n- SQL 注入\n- 点击劫持\n- 中间人攻击\n  - \n\n# 五、性能优化篇\n\n## 5.1 网络层优化\n\n- 减少 HTTP 请求数\n- 使用 HTTP/2\n- 启用 Gzip 压缩\n- 使用 CDN\n  - \n\n## 5.2 资源加载优化\n\n- 预加载（preload、prefetch）\n- 懒加载\n- 图片优化策略\n  - \n\n# 六、实战题目篇\n\n（收录各大公司真实面试题及详解）","tags":["计算机网络","秋招","面试八股文"],"categories":["秋招准备"]},{"title":"Simon成功搬家","url":"/2025/06/12/Simon已着陆/","content":"\n之前用Wordpress建的网站模拟奇妙炸了，只好搬家到Hexo这边来，用了才发现，真香～哈哈哈。虽然Wordpress博客系统管理很方便，但是上传文章太便秘了，还是md大法好啊！\n","tags":["建站日志","生活记录"]}]