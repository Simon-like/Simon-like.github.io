<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>React渲染时机完全指南：从一个电商组件的优化说起</title>
    <url>/2025/07/24/%E3%80%90%E4%BB%8E%E9%A1%B9%E7%9B%AE%E5%88%B0%E6%8A%80%E6%9C%AF%E3%80%91React%E6%B8%B2%E6%9F%93%E6%97%B6%E6%9C%BA%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[前言作为前端开发者，我们每天都在和 React 打交道，但你真的了解 React 的渲染时机吗？

为什么有时候获取 DOM 元素的高度是 0？
为什么设置的动画效果没有生效？
为什么页面会出现闪烁？
useEffect 和 useLayoutEffect 到底该用哪个？
requestAnimationFrame 在 React 中有什么用？

在这篇文章中，我将通过一个真实的电商项目案例去搞懂 React 的渲染时机。
一、从一个真实的电商场景说起1.1 业务背景在电商项目中，商品分类筛选是一个非常常见的功能。想象一下淘宝或京东的商品列表页，顶部通常会有这样的筛选器：
手机通讯 &gt; 手机 &gt; 华为 | 小米 | OPPO | vivo | 苹果 | 三星 | 荣耀 | realme | 一加 | 魅族...

当分类项特别多时，我们需要：

默认只显示 2 行，多余的折叠起来
提供展开&#x2F;收起按钮
支持平滑的展开&#x2F;收起动画
切换一级分类时，二级分类需要重置

1.2 组件效果演示

(gif效果太差了。。。。)
1.3 核心技术挑战看似简单的需求，实现起来却遇到了不少挑战：

高度计算问题：如何准确获取内容的完整高度？
动画流畅性：如何实现平滑的高度过渡动画？
状态切换问题：切换分类时如何避免不必要的动画？
响应式适配：如何在不同屏幕尺寸下保持良好体验？

这些问题的核心都指向一个关键点：我们需要在正确的时机执行正确的操作。
二、React 渲染机制深度解析2.1 React 的工作流程在深入代码之前，我们先来理解 React 的完整工作流程：
graph TB
    A[用户交互/Props变化] --> B[触发状态更新]
    B --> C[React 调度更新]
    C --> D[Render Phase渲染阶段]
    D --> E[Reconciliation协调过程]
    E --> F[生成 Fiber 树]
    F --> G[Commit Phase提交阶段]
    G --> H[更新 DOM]
    H --> I[执行 useLayoutEffect]
    I --> J[浏览器绘制]
    J --> K[执行 useEffect]
    K --> L[用户看到更新]
    
    style D fill:#f9f,stroke:#333,stroke-width:2px
    style G fill:#9ff,stroke:#333,stroke-width:2px
    style J fill:#ff9,stroke:#333,stroke-width:2px

2.2 三个关键阶段阶段一：Render Phase（渲染阶段）
特点：可中断、可恢复、可并发
任务：调用组件函数，生成新的虚拟 DOM 树
限制：不能执行副作用（side effects）

// 这个阶段执行的代码function MyComponent(&#123; data &#125;) &#123;  // ✅ 纯计算  const processedData = useMemo(() =&gt; processData(data), [data]);    // ❌ 不要在这里执行副作用  // document.title = &#x27;New Title&#x27;; // 错误！    return &lt;div&gt;&#123;processedData&#125;&lt;/div&gt;;&#125;

阶段二：Commit Phase（提交阶段）
特点：同步执行，不可中断
任务：将变更应用到真实 DOM
时机：useLayoutEffect 在此阶段执行

function MyComponent() &#123;  useLayoutEffect(() =&gt; &#123;    // 这里 DOM 已更新，但浏览器还未绘制    // 适合进行 DOM 测量或紧急的样式调整    const height = ref.current.scrollHeight;    console.log(&#x27;真实高度:&#x27;, height);  &#125;);&#125;

阶段三：Browser Paint（浏览器绘制）
特点：浏览器的工作，React 不参与
任务：计算布局、绘制像素
时机：useEffect 在此之后执行

2.3 时序对比图让我们通过一个详细的时序图来对比不同 Hook 的执行时机：
sequenceDiagram
    participant User as 用户
    participant React as React
    participant DOM as DOM
    participant Browser as 浏览器
    participant Effect as useEffect
    participant LayoutEffect as useLayoutEffect
    
    User->>React: 点击按钮
    React->>React: setState 更新状态
    
    rect rgb(255, 230, 230)
        Note over React: Render Phase 开始
        React->>React: 调用组件函数
        React->>React: 生成虚拟 DOM
        React->>React: Diff 算法对比
        Note over React: Render Phase 结束
    end
    
    rect rgb(230, 255, 230)
        Note over React,DOM: Commit Phase 开始
        React->>DOM: 更新真实 DOM
        DOM-->>React: DOM 更新完成
        React->>LayoutEffect: 同步执行 useLayoutEffect
        LayoutEffect-->>React: 执行完成
        Note over React,DOM: Commit Phase 结束
    end
    
    rect rgb(230, 230, 255)
        Note over Browser: Paint Phase 开始
        DOM->>Browser: 触发重排/重绘
        Browser->>Browser: 计算布局
        Browser->>Browser: 绘制像素
        Browser->>User: 显示更新后的界面
        Note over Browser: Paint Phase 结束
    end
    
    Browser->>Effect: 异步执行 useEffect
    Effect-->>React: 执行完成

三、代码实战：剖析折叠组件的实现现在让我们来看看实际的代码实现，我会逐步解析每个关键部分。
3.1 组件整体结构首先，让我们了解组件的整体结构：
// 主组件：SecondCategoryBoxconst SecondCategoryBox = (&#123;  categoryList,        // 分类数据  defaultCategoryIds,  // 默认选中项  maxVisibleRows,      // 最大可见行数  onCategoryChange     // 选中项变化回调&#125;) =&gt; &#123;  // 状态管理  const [activeIDList, setActiveIDList] = useState([]);    // 使用自定义 Hook 管理折叠逻辑  const &#123; containerRef, isExpanded, showToggleButton, setIsExpanded &#125; = useCollapse(&#123;    maxVisibleRows,    dependencies: [categoryList]  &#125;);    // 渲染逻辑...&#125;;

3.2 核心难点一：精确的高度计算这是整个组件最核心的部分。我们需要：

获取内容的完整高度（展开时的高度）
计算折叠时应该显示的高度
决定是否需要显示展开&#x2F;收起按钮

const calculateHeightsWithScale = useCallback(() =&gt; &#123;  if (!containerRef.current) return;    const container = containerRef.current;    // 步骤1：临时解除高度限制  const originalHeight = container.style.height;  const originalOverflow = container.style.overflow;    container.style.height = &#x27;auto&#x27;;  container.style.overflow = &#x27;visible&#x27;;    // 步骤2：测量真实高度  // 注意：这里必须等待浏览器完成布局计算  const fullHeight = container.scrollHeight;    // 步骤3：计算折叠高度  const visibleHeight = rowHeight * maxVisibleRows + gap * (maxVisibleRows - 1);    // 步骤4：恢复原始样式  container.style.height = originalHeight;  container.style.overflow = originalOverflow;    // 步骤5：更新状态  setHeights(&#123; full: fullHeight, visible: visibleHeight &#125;);  setShowToggleButton(fullHeight &gt; visibleHeight);&#125;, [maxVisibleRows, rowHeight, gap]);

关键问题：什么时候调用这个函数？
3.3 核心难点二：选择正确的执行时机这就涉及到我们要深入讨论的 React 渲染时机问题。让我们看看不同方案的对比：
方案一：使用 useEffect（❌ 会闪烁）useEffect(() =&gt; &#123;  calculateHeightsWithScale();&#125;, [categoryList]);

问题分析：
graph LR
    A[分类数据变化] --> B[组件重新渲染]
    B --> C[DOM 更新]
    C --> D[浏览器绘制]
    D --> E[用户看到错误高度]
    E --> F[useEffect 执行]
    F --> G[计算并设置正确高度]
    G --> H[再次渲染]
    H --> I[用户看到正确高度]
    
    style E fill:#ffcccc
    style I fill:#ccffcc

用户会先看到错误的高度，然后突然跳到正确高度——这就是”闪烁”！
方案二：使用 useLayoutEffect（⚠️ 可能阻塞渲染）useLayoutEffect(() =&gt; &#123;  calculateHeightsWithScale();&#125;, [categoryList]);

优点：在浏览器绘制前执行，避免闪烁 缺点：同步执行，可能阻塞渲染，影响性能
方案三：使用 requestAnimationFrame（✅ 最佳方案）useEffect(() =&gt; &#123;  requestAnimationFrame(() =&gt; &#123;    calculateHeightsWithScale();  &#125;);&#125;, [categoryList]);

为什么这是最佳方案？
graph TB
    A[useEffect 执行] --> B[注册 RAF 回调]
    B --> C[浏览器完成当前帧绘制]
    C --> D[布局信息已确定]
    D --> E[RAF 回调执行]
    E --> F[准确获取高度]
    F --> G[更新组件状态]
    
    style D fill:#ccffcc
    style F fill:#ccffcc

requestAnimationFrame 确保：

不阻塞当前的渲染
在下一帧开始前执行
此时布局计算已完成，可以准确获取尺寸

3.4 核心难点三：优雅地处理动画当用户切换一级分类时，我们需要重置二级分类，但不希望用户看到收起动画：
useEffect(() =&gt; &#123;  if (firstUpdate) &#123;    // 首次加载，使用默认选中项    setActiveIDList(defaultCategoryIds);    setFirstUpdate(false);  &#125; else &#123;    // 切换分类时的处理        // 步骤1：立即禁用 CSS 过渡    setEnableTransition(false);        // 步骤2：重置所有状态    setIsExpanded(false);    setActiveIDList([]);        // 步骤3：在下一帧恢复过渡效果    requestAnimationFrame(() =&gt; &#123;      setEnableTransition(true);    &#125;);  &#125;&#125;, [categoryList]);

时序分析：
sequenceDiagram
    participant User as 用户
    participant Component as 组件
    participant CSS as CSS动画
    participant Browser as 浏览器
    
    User->>Component: 切换一级分类
    Component->>Component: categoryList 变化
    Component->>CSS: 禁用 transition
    Component->>Component: 重置状态（高度变为折叠状态）
    Note over CSS: 无动画，瞬间变化
    Component->>Browser: 请求下一帧
    Browser-->>Component: 下一帧开始
    Component->>CSS: 启用 transition
    Note over CSS: 后续交互有动画

3.5 性能优化：响应式设计组件还实现了一个巧妙的响应式系统：
const calculateScale = useCallback(() =&gt; &#123;  const currentWidth = window.innerWidth;  const scale = currentWidth / baseWidth;    // 限制缩放范围，避免极端情况  const clampedScale = Math.max(0.8, Math.min(1.5, scale));    return &#123;    scale: clampedScale,    rowHeight: Math.round(baseRowHeight * clampedScale),    gap: Math.round(baseGap * clampedScale)  &#125;;&#125;, [baseWidth, baseRowHeight, baseGap]);

这确保了组件在不同设备上都有合适的显示效果。
四、深入理解 useEffect 和 useLayoutEffect4.1 本质区别// useEffect：在浏览器完成绘制后异步执行useEffect(() =&gt; &#123;  console.log(&#x27;1. DOM 已更新&#x27;);  console.log(&#x27;2. 浏览器已绘制&#x27;);  console.log(&#x27;3. 用户已看到变化&#x27;);  console.log(&#x27;4. 现在执行不会阻塞渲染&#x27;);&#125;);// useLayoutEffect：在浏览器绘制前同步执行useLayoutEffect(() =&gt; &#123;  console.log(&#x27;1. DOM 已更新&#x27;);  console.log(&#x27;2. 浏览器还未绘制&#x27;);  console.log(&#x27;3. 用户还看不到变化&#x27;);  console.log(&#x27;4. 可以在这里调整样式避免闪烁&#x27;);&#125;);

4.2 使用场景对比graph TB
    A[需要执行副作用] --> B{是否影响视觉呈现?}
    
    B -->|是| C{是否需要 DOM 测量?}
    B -->|否| D[使用 useEffect]
    
    C -->|是| E{测量是否紧急?}
    C -->|否| F[使用 useLayoutEffect]
    
    E -->|是| G[useLayoutEffect]
    E -->|否| H[useEffect + RAF]
    
    D --> I[数据获取事件订阅日志上报]
    F --> J[阻止闪烁同步滚动焦点管理]
    G --> K[关键布局计算动画初始状态]
    H --> L[非关键测量性能优化]
    
    style B fill:#ffffcc
    style C fill:#ffffcc
    style E fill:#ffffcc

4.3 实际案例对比让我们通过几个实际例子来加深理解：
案例1：工具提示定位function Tooltip(&#123; children, content &#125;) &#123;  const [position, setPosition] = useState(&#123; top: 0, left: 0 &#125;);  const triggerRef = useRef();  const tooltipRef = useRef();    // ✅ 使用 useLayoutEffect 避免工具提示闪烁  useLayoutEffect(() =&gt; &#123;    if (triggerRef.current &amp;&amp; tooltipRef.current) &#123;      const triggerRect = triggerRef.current.getBoundingClientRect();      const tooltipRect = tooltipRef.current.getBoundingClientRect();            setPosition(&#123;        top: triggerRect.top - tooltipRect.height - 8,        left: triggerRect.left + (triggerRect.width - tooltipRect.width) / 2      &#125;);    &#125;  &#125;, []);    return (    &lt;&gt;      &lt;span ref=&#123;triggerRef&#125;&gt;&#123;children&#125;&lt;/span&gt;      &lt;div         ref=&#123;tooltipRef&#125;        className=&quot;tooltip&quot;        style=&#123;&#123; position: &#x27;fixed&#x27;, ...position &#125;&#125;      &gt;        &#123;content&#125;      &lt;/div&gt;    &lt;/&gt;  );&#125;

案例2：滚动位置恢复function ScrollRestore(&#123; location &#125;) &#123;  // ✅ 使用 useLayoutEffect 立即恢复滚动位置  useLayoutEffect(() =&gt; &#123;    const savedPosition = sessionStorage.getItem(`scroll-$&#123;location&#125;`);    if (savedPosition) &#123;      window.scrollTo(0, parseInt(savedPosition));    &#125;  &#125;, [location]);    // ✅ 使用 useEffect 保存滚动位置（非紧急）  useEffect(() =&gt; &#123;    const handleScroll = () =&gt; &#123;      sessionStorage.setItem(`scroll-$&#123;location&#125;`, window.scrollY);    &#125;;        window.addEventListener(&#x27;scroll&#x27;, handleScroll);    return () =&gt; window.removeEventListener(&#x27;scroll&#x27;, handleScroll);  &#125;, [location]);&#125;

案例3：动画序列function AnimatedList(&#123; items &#125;) &#123;  const [visibleItems, setVisibleItems] = useState([]);    // ❌ 错误：在 useLayoutEffect 中做复杂计算  // useLayoutEffect(() =&gt; &#123;  //   items.forEach((item, index) =&gt; &#123;  //     setTimeout(() =&gt; &#123;  //       setVisibleItems(prev =&gt; [...prev, item]);  //     &#125;, index * 100);  //   &#125;);  // &#125;, [items]);    // ✅ 正确：使用 useEffect + RAF  useEffect(() =&gt; &#123;    let frameId;    let index = 0;        const animate = () =&gt; &#123;      if (index &lt; items.length) &#123;        setVisibleItems(prev =&gt; [...prev, items[index]]);        index++;        frameId = requestAnimationFrame(animate);      &#125;    &#125;;        frameId = requestAnimationFrame(animate);        return () =&gt; &#123;      if (frameId) &#123;        cancelAnimationFrame(frameId);      &#125;    &#125;;  &#125;, [items]);&#125;

五、requestAnimationFrame 的高级应用5.1 什么是 requestAnimationFrame？requestAnimationFrame（简称 RAF）是浏览器提供的一个 API，用于在下一次重绘之前执行动画。它的执行时机非常特殊：
graph LR
    A[帧开始] --> B[处理用户输入]
    B --> C[JS 执行]
    C --> D[RAF 回调]
    D --> E[样式计算]
    E --> F[布局]
    F --> G[绘制]
    G --> H[合成]
    H --> I[帧结束]
    
    style D fill:#ffcccc

5.2 在 React 中的应用场景场景1：确保布局完成后测量function useMeasure() &#123;  const ref = useRef();  const [bounds, setBounds] = useState(&#123;&#125;);    useEffect(() =&gt; &#123;    if (!ref.current) return;        // 确保在布局稳定后测量    const measure = () =&gt; &#123;      requestAnimationFrame(() =&gt; &#123;        if (ref.current) &#123;          setBounds(ref.current.getBoundingClientRect());        &#125;      &#125;);    &#125;;        measure();    window.addEventListener(&#x27;resize&#x27;, measure);        return () =&gt; window.removeEventListener(&#x27;resize&#x27;, measure);  &#125;, []);    return [ref, bounds];&#125;

场景2：批量 DOM 操作function batchDOMUpdates(updates) &#123;  requestAnimationFrame(() =&gt; &#123;    // 在一个帧内完成所有 DOM 操作    updates.forEach(update =&gt; update());        // 强制浏览器立即计算样式（如果需要读取）    // 注意：这会触发强制同步布局，谨慎使用    if (needsRead) &#123;      document.body.offsetHeight; // 强制重排    &#125;  &#125;);&#125;

场景3：平滑动画function useAnimation(duration = 300) &#123;  const [progress, setProgress] = useState(0);  const frameRef = useRef();  const startTimeRef = useRef();    const start = useCallback(() =&gt; &#123;    startTimeRef.current = performance.now();        const animate = (currentTime) =&gt; &#123;      const elapsed = currentTime - startTimeRef.current;      const progress = Math.min(elapsed / duration, 1);            setProgress(progress);            if (progress &lt; 1) &#123;        frameRef.current = requestAnimationFrame(animate);      &#125;    &#125;;        frameRef.current = requestAnimationFrame(animate);  &#125;, [duration]);    useEffect(() =&gt; &#123;    return () =&gt; &#123;      if (frameRef.current) &#123;        cancelAnimationFrame(frameRef.current);      &#125;    &#125;;  &#125;, []);    return [progress, start];&#125;

5.3 RAF vs setTimeout&#x2F;setInterval// ❌ 不推荐：可能导致掉帧或不流畅useEffect(() =&gt; &#123;  const timer = setInterval(() =&gt; &#123;    setPosition(prev =&gt; prev + 1);  &#125;, 16); // 约 60fps    return () =&gt; clearInterval(timer);&#125;, []);// ✅ 推荐：与浏览器刷新率同步useEffect(() =&gt; &#123;  let frameId;    const animate = () =&gt; &#123;    setPosition(prev =&gt; prev + 1);    frameId = requestAnimationFrame(animate);  &#125;;    frameId = requestAnimationFrame(animate);    return () =&gt; cancelAnimationFrame(frameId);&#125;, []);

六、常见问题与最佳实践6.1 常见错误及解决方案错误1：在渲染阶段读取 DOM// ❌ 错误function BadComponent() &#123;  const ref = useRef();  // 这里 ref.current 可能是 null  const height = ref.current?.offsetHeight || 0;    return &lt;div ref=&#123;ref&#125;&gt;Content&lt;/div&gt;;&#125;// ✅ 正确function GoodComponent() &#123;  const ref = useRef();  const [height, setHeight] = useState(0);    useEffect(() =&gt; &#123;    if (ref.current) &#123;      setHeight(ref.current.offsetHeight);    &#125;  &#125;, []);    return &lt;div ref=&#123;ref&#125;&gt;Content&lt;/div&gt;;&#125;

错误2：过度使用 useLayoutEffect// ❌ 错误：非视觉相关操作useLayoutEffect(() =&gt; &#123;  // 数据获取不应该阻塞渲染  fetch(&#x27;/api/data&#x27;).then(setData);&#125;, []);// ✅ 正确useEffect(() =&gt; &#123;  fetch(&#x27;/api/data&#x27;).then(setData);&#125;, []);

错误3：忽视清理函数// ❌ 错误：内存泄漏useEffect(() =&gt; &#123;  const timer = setInterval(() =&gt; &#123;    console.log(&#x27;tick&#x27;);  &#125;, 1000);  // 忘记清理！&#125;, []);// ✅ 正确useEffect(() =&gt; &#123;  const timer = setInterval(() =&gt; &#123;    console.log(&#x27;tick&#x27;);  &#125;, 1000);    return () =&gt; clearInterval(timer);&#125;, []);

6.2 性能优化建议1. 避免不必要的布局计算// ❌ 性能差：每次渲染都计算function BadComponent(&#123; items &#125;) &#123;  const heights = items.map(item =&gt; &#123;    const element = document.getElementById(item.id);    return element?.offsetHeight || 0;  &#125;);&#125;// ✅ 性能好：只在必要时计算function GoodComponent(&#123; items &#125;) &#123;  const [heights, setHeights] = useState([]);    useEffect(() =&gt; &#123;    requestAnimationFrame(() =&gt; &#123;      const newHeights = items.map(item =&gt; &#123;        const element = document.getElementById(item.id);        return element?.offsetHeight || 0;      &#125;);      setHeights(newHeights);    &#125;);  &#125;, [items]);&#125;

2. 批量更新 DOM// ✅ 批量读取和写入function BatchUpdate(&#123; items &#125;) &#123;  useLayoutEffect(() =&gt; &#123;    // 第一阶段：批量读取    const measurements = items.map(item =&gt; (&#123;      id: item.id,      height: document.getElementById(item.id)?.offsetHeight || 0    &#125;));        // 第二阶段：批量写入    measurements.forEach((&#123; id, height &#125;) =&gt; &#123;      const element = document.getElementById(id);      if (element) &#123;        element.style.transform = `translateY($&#123;height&#125;px)`;      &#125;    &#125;);  &#125;, [items]);&#125;

3. 使用 CSS 代替 JS 动画// ❌ JS 动画（性能较差）const [height, setHeight] = useState(0);useEffect(() =&gt; &#123;  let current = 0;  const timer = setInterval(() =&gt; &#123;    current += 5;    setHeight(current);    if (current &gt;= 100) clearInterval(timer);  &#125;, 16);&#125;, []);// ✅ CSS 动画（性能更好）const [expanded, setExpanded] = useState(false);return (  &lt;div     className=&#123;`container $&#123;expanded ? &#x27;expanded&#x27; : &#x27;&#x27;&#125;`&#125;    style=&#123;&#123;      transition: &#x27;height 0.3s ease-out&#x27;,      height: expanded ? &#x27;100px&#x27; : &#x27;0px&#x27;    &#125;&#125;  /&gt;);

6.3 调试技巧1. 可视化渲染时机function useRenderLog(name) &#123;  console.log(`$&#123;name&#125; rendering`);    useLayoutEffect(() =&gt; &#123;    console.log(`$&#123;name&#125; layout effect`);  &#125;);    useEffect(() =&gt; &#123;    console.log(`$&#123;name&#125; effect`);        requestAnimationFrame(() =&gt; &#123;      console.log(`$&#123;name&#125; next frame`);    &#125;);  &#125;);&#125;

2. 性能监控function usePerformanceMonitor(name) &#123;  const renderStart = performance.now();    useLayoutEffect(() =&gt; &#123;    const layoutEffectTime = performance.now();    console.log(`$&#123;name&#125; to layout effect: $&#123;layoutEffectTime - renderStart&#125;ms`);  &#125;);    useEffect(() =&gt; &#123;    const effectTime = performance.now();    console.log(`$&#123;name&#125; to effect: $&#123;effectTime - renderStart&#125;ms`);        requestAnimationFrame(() =&gt; &#123;      const frameTime = performance.now();      console.log(`$&#123;name&#125; to next frame: $&#123;frameTime - renderStart&#125;ms`);    &#125;);  &#125;);&#125;

七、React 18 并发特性与渲染时机7.1 并发渲染的影响React 18 引入的并发特性改变了一些渲染行为：
import &#123; startTransition, useDeferredValue, useId &#125; from &#x27;react&#x27;;function ConcurrentComponent(&#123; searchTerm, items &#125;) &#123;  // 延迟非紧急更新  const deferredSearchTerm = useDeferredValue(searchTerm);    // 标记低优先级更新  const handleExpensiveUpdate = () =&gt; &#123;    startTransition(() =&gt; &#123;      // 这个更新可以被中断      setExpensiveState(calculateExpensiveValue());    &#125;);  &#125;;    // 紧急更新仍然同步处理  const handleUrgentUpdate = () =&gt; &#123;    setUrgentState(value); // 立即响应  &#125;;&#125;

7.2 并发渲染下的 useEffect在并发模式下，组件可能会多次渲染但只提交一次：
graph TB
    A[开始渲染] --> B{高优先级更新?}
    B -->|是| C[中断当前渲染]
    B -->|否| D[继续渲染]
    C --> E[处理高优先级]
    E --> F[重新开始低优先级]
    D --> G[提交到 DOM]
    F --> D
    G --> H[执行 Effects]
    
    style C fill:#ffcccc
    style E fill:#ffcccc

7.3 实践建议function SearchResults(&#123; query &#125;) &#123;  const [results, setResults] = useState([]);  const [isSearching, setIsSearching] = useState(false);    // 使用 useDeferredValue 优化搜索体验  const deferredQuery = useDeferredValue(query);    // 紧急：显示加载状态  useEffect(() =&gt; &#123;    setIsSearching(query !== deferredQuery);  &#125;, [query, deferredQuery]);    // 非紧急：执行搜索  useEffect(() =&gt; &#123;    let cancelled = false;        async function doSearch() &#123;      const data = await searchAPI(deferredQuery);      if (!cancelled) &#123;        startTransition(() =&gt; &#123;          setResults(data);        &#125;);      &#125;    &#125;        doSearch();        return () =&gt; &#123;      cancelled = true;    &#125;;  &#125;, [deferredQuery]);    return (    &lt;div&gt;      &#123;isSearching &amp;&amp; &lt;Spinner /&gt;&#125;      &lt;ResultsList results=&#123;results&#125; /&gt;    &lt;/div&gt;  );&#125;

八、实战总结：回到我们的折叠组件现在，让我们用学到的知识重新审视最初的折叠组件，看看它是如何解决各种渲染时机问题的：
8.1 问题与解决方案对照


问题
解决方案
原理



获取准确的内容高度
useEffect + RAF
确保布局计算完成


切换分类时的动画闪烁
禁用&#x2F;启用 transition
精确控制 CSS 动画时机


响应式适配
动态计算缩放比例
避免频繁的 DOM 操作


首次加载的默认状态
firstUpdate 标记
区分初始化和更新


8.2 完整的渲染流程sequenceDiagram
    participant U as 用户
    participant C as 组件
    participant D as DOM
    participant B as 浏览器
    
    Note over U,B: 场景1：组件首次加载
    U->>C: 页面加载
    C->>C: 初始化状态
    C->>D: 渲染 DOM
    C->>C: useEffect 执行
    C->>B: RAF 注册回调
    B->>C: 下一帧执行测量
    C->>C: 设置正确高度
    C->>D: 更新 DOM
    B->>U: 显示完整内容
    
    Note over U,B: 场景2：用户点击展开
    U->>C: 点击展开按钮
    C->>C: setIsExpanded(true)
    C->>D: 更新高度样式
    Note over D,B: CSS transition 生效
    B->>U: 平滑展开动画
    
    Note over U,B: 场景3：切换分类
    U->>C: 选择新分类
    C->>C: 禁用 transition
    C->>C: 重置状态
    C->>D: 立即更新（无动画）
    C->>B: RAF 注册回调
    B->>C: 下一帧恢复 transition
    Note over C,B: 后续交互恢复动画

8.3 关键代码片段回顾// 1. 自定义 Hook 封装复杂逻辑export const useCollapse = (options) =&gt; &#123;  const &#123; maxVisibleRows = 2, dependencies = [] &#125; = options;  const containerRef = useRef();  const [isExpanded, setIsExpanded] = useState(false);  const [showToggleButton, setShowToggleButton] = useState(false);    // 2. 使用 RAF 确保准确测量  useEffect(() =&gt; &#123;    requestAnimationFrame(() =&gt; calculateHeightsWithScale());  &#125;, dependencies);    // 3. 返回必要的状态和引用  return &#123;    containerRef,    isExpanded,    showToggleButton,    setIsExpanded,    containerStyle: &#123;      height: !showToggleButton ? &#x27;auto&#x27; :               isExpanded ? heights.full : heights.visible,      overflow: &#x27;hidden&#x27;,      transition: &#x27;height 0.3s ease-in-out&#x27;    &#125;  &#125;;&#125;;

九、写在最后通过这个真实的电商项目案例，我们深入探讨了 React 的渲染时机问题。让我们再次总结一下核心要点：
9.1 核心原则
理解时机：知道代码在 React 生命周期的哪个阶段执行
选对工具：useEffect、useLayoutEffect、RAF 各有适用场景
避免闪烁：需要立即生效的视觉变化用 useLayoutEffect
性能优先：非紧急操作放在 useEffect 中异步执行
精确控制：使用 RAF 在正确的时机进行 DOM 测量

9.2 决策流程图graph TD
    A[需要副作用?] -->|是| B[影响视觉?]
    A -->|否| Z[纯组件逻辑]
    
    B -->|是| C[需要 DOM 测量?]
    B -->|否| D[useEffect]
    
    C -->|是| E[测量紧急?]
    C -->|否| F[useLayoutEffect]
    
    E -->|是| G[useLayoutEffect]
    E -->|否| H[useEffect + RAF]
    
    D --> I[异步操作数据获取事件订阅]
    F --> J[防止闪烁滚动恢复]
    G --> K[关键测量初始定位]
    H --> L[性能优化非关键测量]
    
    style A fill:#f9f,stroke:#333,stroke-width:4px
    style B fill:#bbf,stroke:#333,stroke-width:2px
    style C fill:#bbf,stroke:#333,stroke-width:2px
    style E fill:#bbf,stroke:#333,stroke-width:2px

9.3 从理论到实践理解 React 的渲染时机不仅仅是理论知识，更是解决实际问题的关键。当你遇到以下问题时，请想起这篇文章：

页面闪烁 → 检查是否应该使用 useLayoutEffect
获取的尺寸为 0 → 使用 RAF 确保布局完成
动画卡顿 → 考虑使用 CSS 动画或 RAF
性能问题 → 将非紧急操作移到 useEffect

十、参考资料
React 官方文档 - Hooks Reference
React 源码解析 - Fiber 架构
Web 性能优化 - requestAnimationFrame
React 18 Working Group
浏览器渲染原理


如果这篇文章对你有帮助，欢迎点赞、收藏和分享。有任何问题或不同见解，也欢迎在评论区讨论！
]]></content>
      <categories>
        <category>从项目到技术</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>项目案例</tag>
        <tag>性能优化</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>【从项目到技术】SPA vs MPA 深度分析</title>
    <url>/2025/08/13/%E3%80%90%E4%BB%8E%E9%A1%B9%E7%9B%AE%E5%88%B0%E6%8A%80%E6%9C%AF%E3%80%91SPA%20vs%20MPA%20%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[2024-2025年前端架构正经历重要转型，开发者正从传统的”JavaScript优先”模式转向更平衡的性能导向解决方案。本报告基于最新行业数据和技术发展，为React开发者提供架构选择的全面指导。
SPA疲劳与架构文艺复兴当前前端社区正经历所谓的”SPA疲劳”现象。虽然单页应用仍占据90%的使用率，但开发者越来越意识到其性能和复杂性成本。行业整体趋势是”更多依赖服务器，向浏览器发送更少JavaScript，减少UI渲染请求，更快地打包代码“，这代表了从客户端重型向服务器重型架构的根本性转变。
关键的变化是混合方法的兴起，而非简单的SPA或MPA二选一。开发者采用岛屿架构（Islands Architecture）进行选择性水合、服务器端渲染配合客户端增强、以及静态站点生成与动态元素的结合。
电商平台中的SPA vs MPA架构对比架构优势分析SPA在电商中的优势：

流畅的用户体验：无刷新页面转换，类似原生应用的交互
卓越的移动端性能：对于移动电商至关重要
动态筛选搜索：即时产品筛选、排序和搜索功能
实时功能支持：购物车更新、库存状态、价格变化
减少服务器负载：初始加载后仅需获取数据(JSON)

MPA在电商中的优势：

卓越的SEO表现：每个页面都有独特URL、元数据和内容，易于搜索引擎索引
更快的初始加载：仅加载当前页面所需资源
更好的浏览器兼容性：适用于所有设备，包括旧版浏览器
独立页面优化：每个产品&#x2F;类目页面可单独优化
成熟的安全模型：服务器端渲染提供传统、易理解的安全模式

不同页面类型的架构选择建议商品列表&#x2F;类目页面 推荐：混合MPA + SPA组件

基础结构使用MPA以获得SEO优势和易于索引
筛选、排序、分页功能采用SPA组件
搜索引擎可以爬取类目结构，用户获得流畅的筛选体验

商品详情页(PDP) 推荐：MPA + 交互式组件

服务器渲染页面确保SEO和快速加载
图片画廊、评论、加购功能使用JavaScript增强
每个产品需要独立URL、元数据和结构化数据

购物车功能 推荐：MPA框架内的SPA组件

购物车更新需要无刷新实时更新以确保用户体验
实施策略：乐观更新配合服务器验证的混合方法

结账支付流程 强烈推荐：MPA架构

分步导航的传统多页面结账可减少放弃率
服务器端渲染对支付处理至关重要
基于页面的方法更适合处理支付失败
客户期望传统结账流程以建立信任感

用户账户页面 推荐：SPA架构

用户期望账户管理具有类似应用的界面
订单状态、偏好设置、愿望清单变化受益于SPA模式
账户页面通常不被搜索引擎索引，SEO优先级较低

React开发者的MPA架构选择时机选择MPA的关键场景应选择MPA架构当：

SEO至关重要：内容为主的网站、博客、营销站点
首屏加载速度优先：MPA的首字节时间(TTFB)和首次内容绘制(FCP)更快
JavaScript需求有限：交互性不强的网站无需复杂客户端状态管理
渐进增强方法：核心功能需要在无JavaScript环境下工作
大规模产品目录：需要优秀SEO表现的电商平台

仍选择SPA架构当：

高交互性需求：仪表板、管理面板、实时应用
类应用体验：流畅导航、跨视图共享状态
复杂客户端逻辑：繁重状态管理、实时更新

性能指标对比基于2024年基准测试数据：

服务器端渲染性能：Svelte(1,641 req&#x2F;s) &gt; Vue(1,139 req&#x2F;s) &gt; React(572 req&#x2F;s)
MPA优势：更好的SEO索引、更快的初始页面加载、更小的JavaScript包大小
SPA优势：更流畅的导航、初始加载后更好的感知性能、共享状态管理

适合React开发者的MPA框架工具对比Next.js：市场领导者技术规格：

渲染方式：SSR、SSG、ISR、客户端渲染支持
路由系统：基于文件的路由（Pages Router vs App Router）
性能特性：React Server Components、Turbopack打包
市场采用率：在State of JS 2024中保持52.9%的采用率

App Router vs Pages Router：

App Router（推荐）：默认使用React Server Components，基于文件夹的路由，更好的性能但学习曲线更陡
Pages Router（遗留）：基于文件的路由，更简单的迁移路径但不再推荐

SvelteKit：性能冠军技术规格：

性能优势：编译时优化，无虚拟DOM开销，更小的JavaScript包
开发体验：基于文件的路由，内置TypeScript支持
兴趣度：43.6%的开发者有兴趣学习SvelteKit
核心Web生命力指标表现优秀

Astro：内容优先架构关键特性：

哲学：内容优先，默认零JavaScript
岛屿架构：选择性水合交互式组件
框架无关：支持React、Vue、Svelte组件
增长数据：尽管是新框架，但已获得25%的采用率

代码示例：
// Astro组件与岛屿水合---import &#123; getCollection &#125; from &#x27;astro:content&#x27;;import BlogPost from &#x27;../components/BlogPost.astro&#x27;;const posts = await getCollection(&#x27;blog&#x27;);---&lt;html&gt;  &lt;body&gt;    &#123;posts.map(post =&gt;       &lt;BlogPost         post=&#123;post&#125;         client:visible       /&gt;    )&#125;  &lt;/body&gt;&lt;/html&gt;

Fresh (Deno)：边缘原生框架技术规格：

运行时：Deno原生，内置TypeScript支持
架构：基于岛屿的Preact组件
边缘计算：专为边缘部署构建
即时渲染：零配置，实时编译

Remix框架深度分析重大更新：Remix转化为React Router v72024年12月重大变更：Remix已演进为React Router v7。Remix团队将Remix功能合并到React Router中，使React Router v7成为Remix v2的继任者。这代表了React生态系统的重要整合。
核心架构与哲学四大支柱：

拥抱服务器&#x2F;客户端模型：源代码与内容&#x2F;数据分离
使用Web标准：利用浏览器、HTTP和HTML基础
用JavaScript增强：模拟而非替代浏览器行为
渐进增强：应用在无JavaScript情况下工作，有JavaScript时增强

设计原则：

UI为中心的路由：专注于UI组件和布局而非模型
Web标准优先：基于Web Fetch API，支持HTTP缓存
“中心栈”方法：融合传统(Web标准)和现代(React)开发模式

与Next.js的详细对比


方面
Remix&#x2F;React Router v7
Next.js



架构
服务器优先，Web标准
混合(SSG&#x2F;SSR&#x2F;CSR)


渲染
SSR + 渐进增强
SSG、SSR、ISR、CSR


数据获取
Loaders(服务器) + 客户端水合
getStaticProps、getServerSideProps


路由
嵌套的，基于URL段
基于文件的pages目录


表单处理
原生HTML表单增强
需要JavaScript的方法


标准聚焦
Web Fetch API、HTTP标准
Node.js生态集成


性能特征：

Remix优势：通过SSR更快的动态内容传递，减少客户端JavaScript包大小，并行数据加载，慢网络下更好的性能
Next.js优势：SSG的卓越静态站点性能，开箱即用的图像优化，增量静态再生成(ISR)

适用场景选择Remix&#x2F;React Router v7当：

动态数据密集型应用
需要强SEO的电商网站
仪表板和管理应用
重视渐进增强的应用

选择Next.js当：

静态或大部分静态的网站
内容密集型网站和博客
需要广泛静态优化的应用
需要成熟生态支持的团队

首屏加载性能优化策略SPA优化策略服务器端渲染(SSR)实现：

传递初始HTML以启用浏览器资源加载优化
防止在客户端渲染应用中出现的后期资产发现
使用React 18的流式SSR与Suspense边界

渐进式水合策略：
// 空闲直到紧急模式实现const EnhancedComponent = withIdleRender(MyComponent);// 在浏览器空闲时间或用户交互时水合组件

性能影响：

Cdiscount通过渐进式水合实现45%的初始水合成本降低(128ms降至70ms)
首次输入延迟降低50%+
关键首屏内容更早实现交互性

捆绑包大小优化：

基于路由的代码分割(最有效的第一步)
基于组件的分割(适用于很少使用的功能，&gt;100KB阈值)
弹窗&#x2F;模态框分割(按需加载)
基于特性的分割(不同功能的独立块)

MPA优化策略缓存策略：

带内容哈希的静态资源长期缓存(推荐1年)
HTML页面短TTL(推荐60秒)
利用浏览器缓存进行后续页面加载

CDN实现：

静态资源的边缘缓存
地理分布减少延迟
Gzip&#x2F;Brotli压缩(可实现70%+文件大小缩减)

资源优化：

最小化阻塞CSS和JavaScript
实现关键CSS内联
使用现代图像格式和响应式图片
使用WOFF2和font-display: swap优化字体加载

混合架构优化PESPA(渐进增强SPA)方法：

Next.js应用与SSG&#x2F;SSR
带选择性交互的Astro
岛屿架构(Qwik、Fresh)
带客户端水合的服务器组件

2024-2025前端架构趋势岛屿架构的崛起定义与概念：岛屿架构旨在通过在静态HTML之上独立交付的”交互岛屿”来减少发送的JavaScript量。
关键优势：

性能：相比传统框架JavaScript代码减少83%
SEO友好：服务器渲染的静态内容
渐进增强：关键内容立即加载，交互性逐步加载
独立性：每个岛屿独立水合，防止级联故障

开发者情绪与采用趋势State of JavaScript 2024结果：

React：保持69.9%使用率但增长放缓
Next.js：在元框架中52.9%采用率
SvelteKit：兴趣上升(43.6%想学习)
Astro：新框架取得25%采用率令人印象深刻

企业采用模式大规模架构决策：

企业越来越多采用微前端架构实现独立团队开发、技术多样性、可扩展性
Backend-for-Frontend(BFF)模式为公司级推荐，以赋能前端团队、降低API复杂性

技术偏好：

成熟生态系统(React、Angular)
长期支持保证
广泛工具和文档
强大社区支持

未来预测(2025-2027)短期趋势：

岛屿架构主流采用：预计成为内容密集型网站的标准模式
AI增强开发：76%开发者计划使用AI工具进行代码生成、性能优化、自动测试
WebAssembly集成：用于高性能计算、遗留系统集成

中期演进：

边缘计算集成：前端架构将更多利用边缘计算实现减少延迟、边缘服务器端渲染
组件流式传输：从服务器到客户端的细粒度组件流式传输演进

实施建议与最佳实践架构选择决策框架


使用场景
推荐框架
备选方案



内容密集型网站
Astro
Next.js SSG


电商平台
Next.js
SvelteKit


营销网站
Astro
SvelteKit


文档站点
Astro
Next.js


管理面板
Next.js SPA模式
Remix


博客
Astro
Next.js


企业应用
Next.js
Remix


性能关键应用
SvelteKit
Astro


边缘计算
Fresh
Next.js Edge


迁移策略SPA到MPA迁移方法：

评估阶段：分析当前SPA结构，识别静态页面、动态页面、交互部分
增量迁移：从静态页面开始，迁移内容密集型部分，保持高交互部分为SPA岛屿
优化阶段：实现渐进式水合、优化关键渲染路径、添加性能监控

性能优化最佳实践Core Web Vitals优化：

最大内容绘制(LCP)：使用适当渲染策略(SSG &gt; SSR &gt; CSR)、优化图片、实现资源优先级
首次输入延迟(FID)：渐进式水合策略、代码分割和懒加载
累积布局偏移(CLS)：为动态内容预留空间、使用骨架屏

框架特定优化Next.js优化：
// 图片优化import Image from &#x27;next/image&#x27;;// 路由预取import Link from &#x27;next/link&#x27;;&lt;Link href=&quot;/blog&quot; prefetch=&#123;true&#125;&gt;// 动态导入const DynamicComponent = dynamic(() =&gt; import(&#x27;../components/Heavy&#x27;));

Astro优化：
// 选择性水合的组件岛屿&lt;Counter client:visible /&gt;&lt;SearchBox client:media=&quot;(max-width: 800px)&quot; /&gt;&lt;Chart client:idle /&gt;

结论与展望2024-2025年的前端架构格局以成熟和实用主义为特征，而非革命性变化。行业正在从”JavaScript优先”方法转向平衡解决方案，优先考虑性能、开发体验和用户需求。岛屿架构代表了最重要的新模式，为传统SPA&#x2F;MPA二分法提供了引人注目的替代方案。
关键建议：

对于企业团队：评估岛屿架构用于内容密集型应用，投资元框架减少复杂性，优先考虑性能监控和优化
对于个人开发者：学习岛屿概念和渐进增强，掌握现代构建工具如Vite，保持框架无关的思维
技术选择准则：不要选择单一方法，而是为每个特定用例选择正确的架构模式

前端架构的未来不在于选择单一方法，而在于为每个特定用例选择合适的架构模式，岛屿架构为开发者工具包提供了强大的新选择。这种架构演进为组织提供了采用经过验证的全栈模式、降低依赖复杂性、改善应用性能、投资长期Web标准知识的机会。
]]></content>
      <categories>
        <category>从项目到技术</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>前端开发</tag>
        <tag>SSR</tag>
        <tag>MPA</tag>
      </tags>
  </entry>
  <entry>
    <title>【建站日志】Simon成功搬家</title>
    <url>/2025/06/12/%E3%80%90%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97%E3%80%91Simon%E5%B7%B2%E7%9D%80%E9%99%86/</url>
    <content><![CDATA[之前用Wordpress建的网站突然炸了T_T，只好搬家到Hexo这边来，虽然之前就想换成ssg静态网站就是了。毕竟Wordpress博客系统上传文章太便秘了，完全用不惯他的文本编辑器，还是MD大法好啊！
]]></content>
      <tags>
        <tag>建站日志</tag>
        <tag>生活记录</tag>
      </tags>
  </entry>
  <entry>
    <title>【概念解析】前端开发中的polypill</title>
    <url>/2025/07/22/%E3%80%90%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%9E%90%E3%80%91%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84Polyfill/</url>
    <content><![CDATA[什么是 Polyfill？Polyfill 是一段代码（通常是 JavaScript），用来为旧浏览器提供它没有原生支持的较新的功能。
名字的由来 🎨“Polyfill” 这个词来源于一种建筑材料 Polyfilla（一种用于填补墙面裂缝的腻子），形象地表示”填补浏览器功能的空缺”。
为什么需要 Polyfill？// 🌰 例子：旧浏览器不支持 Array.includesconst fruits = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;orange&#x27;];// 新浏览器可以直接使用console.log(fruits.includes(&#x27;banana&#x27;)); // true// 旧浏览器会报错：fruits.includes is not a function

常见的 Polyfill 示例1. Array.includes Polyfill// 检查是否已经存在if (!Array.prototype.includes) &#123;  Array.prototype.includes = function(searchElement, fromIndex) &#123;    // 严格模式    &#x27;use strict&#x27;;        const O = Object(this);    const len = parseInt(O.length) || 0;        if (len === 0) return false;        const n = parseInt(fromIndex) || 0;    let k = Math.max(n &gt;= 0 ? n : len + n, 0);        while (k &lt; len) &#123;      if (searchElement === O[k]) return true;      k++;    &#125;        return false;  &#125;;&#125;

2. Promise Polyfill// 简化版 Promise polyfillif (typeof Promise === &#x27;undefined&#x27;) &#123;  window.Promise = function(executor) &#123;    // Promise 实现代码...  &#125;;&#125;

3. Object.assign Polyfillif (!Object.assign) &#123;  Object.assign = function(target) &#123;    &#x27;use strict&#x27;;        if (target == null) &#123;      throw new TypeError(&#x27;Cannot convert undefined or null to object&#x27;);    &#125;        const output = Object(target);        for (let index = 1; index &lt; arguments.length; index++) &#123;      const source = arguments[index];      if (source != null) &#123;        for (const key in source) &#123;          if (Object.prototype.hasOwnProperty.call(source, key)) &#123;            output[key] = source[key];          &#125;        &#125;      &#125;    &#125;        return output;  &#125;;&#125;

4. String.padStart Polyfillif (!String.prototype.padStart) &#123;  String.prototype.padStart = function(targetLength, padString) &#123;    targetLength = targetLength &gt;&gt; 0; // 转为整数    padString = String(padString || &#x27; &#x27;);        if (this.length &gt;= targetLength) &#123;      return String(this);    &#125;        targetLength = targetLength - this.length;    if (targetLength &gt; padString.length) &#123;      padString += padString.repeat(targetLength / padString.length);    &#125;        return padString.slice(0, targetLength) + String(this);  &#125;;&#125;

Polyfill vs 其他概念1. Polyfill vs Transpile（转译）// Polyfill：运行时补充缺失的 APIArray.prototype.find = Array.prototype.find || function() &#123; /* ... */ &#125;;// Transpile：编译时转换语法（如 Babel）// ES6 箭头函数const add = (a, b) =&gt; a + b;// 转译后var add = function(a, b) &#123; return a + b; &#125;;

2. Polyfill vs Shim
Polyfill：实现标准 API，行为与规范一致
Shim：可能有自己的 API，不一定遵循标准

如何使用 Polyfill？1. 手动引入&lt;!-- 引入特定的 polyfill --&gt;&lt;script src=&quot;https://polyfill.io/v3/polyfill.min.js?features=Promise,Array.from&quot;&gt;&lt;/script&gt;

2. 使用 core-js// 安装npm install core-js// 使用import &#x27;core-js/features/array/includes&#x27;;import &#x27;core-js/features/promise&#x27;;

3. 使用 @babel&#x2F;polyfill（已废弃）// 新的推荐方式npm install core-js regenerator-runtime// babel.config.jsmodule.exports = &#123;  presets: [    [&#x27;@babel/preset-env&#x27;, &#123;      useBuiltIns: &#x27;usage&#x27;,      corejs: 3    &#125;]  ]&#125;;

最佳实践1. 按需加载// 只在需要时加载 polyfillif (!window.Promise) &#123;  // 动态加载 Promise polyfill  loadScript(&#x27;promise-polyfill.js&#x27;);&#125;

2. 使用 polyfill.io 服务&lt;!-- 根据用户浏览器自动返回需要的 polyfill --&gt;&lt;script src=&quot;https://polyfill.io/v3/polyfill.min.js&quot;&gt;&lt;/script&gt;

3. 特性检测// 使用特性检测而不是浏览器检测function loadPolyfills() &#123;  const polyfills = [];    if (!window.Promise) &#123;    polyfills.push(import(&#x27;promise-polyfill&#x27;));  &#125;    if (!Array.prototype.includes) &#123;    polyfills.push(import(&#x27;array-includes-polyfill&#x27;));  &#125;    return Promise.all(polyfills);&#125;// 加载完 polyfill 后再启动应用loadPolyfills().then(() =&gt; &#123;  // 启动应用  startApp();&#125;);

常用的 Polyfill 库
core-js - 最全面的 polyfill 库
polyfill.io - 自动化 polyfill 服务
es5-shim&#x2F;es6-shim - ES5&#x2F;ES6 polyfill
fetch-polyfill - Fetch API polyfill
intersection-observer - IntersectionObserver polyfill

注意事项 ⚠️
性能影响：Polyfill 会增加代码体积
选择性加载：只加载需要的 polyfill
版本兼容：确保 polyfill 支持目标浏览器
原生优先：优先使用原生实现

// 好的做法：先检测再添加if (!Array.prototype.flat) &#123;  // 添加 polyfill&#125;// 避免：直接覆盖Array.prototype.flat = function() &#123; /* ... */ &#125;;

总之，Polyfill 是前端开发中实现向后兼容的重要手段，让我们能够在旧浏览器中使用新特性！
]]></content>
      <categories>
        <category>前端知识小册</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
        <tag>概念解析</tag>
      </tags>
  </entry>
  <entry>
    <title>【秋招备战】JavaScript 集合类型深度解析</title>
    <url>/2025/08/05/%E3%80%90%E7%A7%8B%E6%8B%9B%E5%A4%87%E6%88%98%E3%80%91JavaScript%20%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[在 JavaScript 的世界里，除了我们熟悉的对象（Object）和数组（Array），ES6 还引入了四种新的集合类型：Map、Set、WeakMap 和 WeakSet。这些数据结构不仅丰富了我们的工具箱，更是在现代前端框架的底层实现中扮演着重要角色。今天，让我们深入探讨这些集合类型的特性、使用场景，以及它们在 React 和 Vue 源码中的精妙应用。
一、Map：更强大的键值对集合基本概念Map 是一个键值对的集合，与普通对象最大的区别在于：Map 的键可以是任意类型，而不仅仅是字符串或 Symbol。
const map = new Map();// 基本用法map.set(&#x27;name&#x27;, &#x27;JavaScript&#x27;);map.set(42, &#x27;The Answer&#x27;);map.set(true, &#x27;Boolean key&#x27;);// 对象作为键const objKey = &#123; id: 1 &#125;;map.set(objKey, &#x27;Object as key&#x27;);// 函数作为键const funcKey = () =&gt; &#123;&#125;;map.set(funcKey, &#x27;Function as key&#x27;);console.log(map.get(objKey)); // &#x27;Object as key&#x27;console.log(map.size); // 5

Map 的核心特性
键的唯一性：Map 中的键是唯一的，重复设置会覆盖之前的值
保持插入顺序：Map 会记住键值对的插入顺序
可迭代：Map 实现了迭代器协议

const map = new Map([  [&#x27;first&#x27;, 1],  [&#x27;second&#x27;, 2],  [&#x27;third&#x27;, 3]]);// 遍历方法for (const [key, value] of map) &#123;  console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// 获取所有键console.log([...map.keys()]); // [&#x27;first&#x27;, &#x27;second&#x27;, &#x27;third&#x27;]// 获取所有值console.log([...map.values()]); // [1, 2, 3]// 获取所有键值对console.log([...map.entries()]); // [[&#x27;first&#x27;, 1], [&#x27;second&#x27;, 2], [&#x27;third&#x27;, 3]]

Map vs Object 的性能对比// 性能测试：频繁增删操作const testSize = 100000;// Object 测试console.time(&#x27;Object&#x27;);const obj = &#123;&#125;;for (let i = 0; i &lt; testSize; i++) &#123;  obj[`key$&#123;i&#125;`] = i;  delete obj[`key$&#123;i&#125;`];&#125;console.timeEnd(&#x27;Object&#x27;);// Map 测试console.time(&#x27;Map&#x27;);const map = new Map();for (let i = 0; i &lt; testSize; i++) &#123;  map.set(`key$&#123;i&#125;`, i);  map.delete(`key$&#123;i&#125;`);&#125;console.timeEnd(&#x27;Map&#x27;);// Object: 40.439ms// Map: 15.457ms// Map 在频繁增删操作时性能更优

实际应用场景// 缓存管理class LRUCache &#123;  constructor(capacity) &#123;    this.capacity = capacity;    this.cache = new Map();  &#125;  get(key) &#123;    if (!this.cache.has(key)) return -1;        // 将访问的元素移到最后（最新）    const value = this.cache.get(key);    this.cache.delete(key);    this.cache.set(key, value);    return value;  &#125;  put(key, value) &#123;    if (this.cache.has(key)) &#123;      this.cache.delete(key);    &#125;        this.cache.set(key, value);        // 超出容量，删除最旧的（第一个）    if (this.cache.size &gt; this.capacity) &#123;      const firstKey = this.cache.keys().next().value;      this.cache.delete(firstKey);    &#125;  &#125;&#125;

二、Set：独特值的集合基本概念Set 是一个值的集合，其中每个值都是唯一的，不会重复。
const set = new Set();// 添加值set.add(1);set.add(2);set.add(2); // 重复值不会被添加set.add(&#x27;2&#x27;); // 字符串&#x27;2&#x27;和数字2是不同的console.log(set.size); // 3console.log(set.has(2)); // true// 数组去重const numbers = [1, 2, 2, 3, 4, 4, 5];const uniqueNumbers = [...new Set(numbers)];console.log(uniqueNumbers); // [1, 2, 3, 4, 5]

Set 的高级应用// 1. 数组操作const setA = new Set([1, 2, 3, 4]);const setB = new Set([3, 4, 5, 6]);// 并集const union = new Set([...setA, ...setB]);console.log([...union]); // [1, 2, 3, 4, 5, 6]// 交集const intersection = new Set([...setA].filter(x =&gt; setB.has(x)));console.log([...intersection]); // [3, 4]// 差集const difference = new Set([...setA].filter(x =&gt; !setB.has(x)));console.log([...difference]); // [1, 2]// 2. 对象去重const users = [  &#123; id: 1, name: &#x27;Alice&#x27; &#125;,  &#123; id: 2, name: &#x27;Bob&#x27; &#125;,  &#123; id: 1, name: &#x27;Alice&#x27; &#125;,  &#123; id: 3, name: &#x27;Charlie&#x27; &#125;];const uniqueUsers = Array.from(  new Map(users.map(user =&gt; [user.id, user])).values());console.log(uniqueUsers); // 去重后的用户数组

性能优势// Set 的 has 方法性能测试const arr = Array.from(&#123; length: 10000 &#125;, (_, i) =&gt; i);const set = new Set(arr);console.time(&#x27;Array includes&#x27;);for (let i = 0; i &lt; 1000; i++) &#123;  arr.includes(9999);&#125;console.timeEnd(&#x27;Array includes&#x27;);console.time(&#x27;Set has&#x27;);for (let i = 0; i &lt; 1000; i++) &#123;  set.has(9999);&#125;console.timeEnd(&#x27;Set has&#x27;);// Set.has() 的时间复杂度是 O(1)，而 Array.includes() 是 O(n)

三、WeakMap：弱引用的键值对集合核心特性WeakMap 与 Map 类似，但有几个关键区别：

键必须是对象（不能是原始值）
键是弱引用的，不会阻止垃圾回收
不可迭代，没有 size 属性

const wm = new WeakMap();// 只能使用对象作为键const obj1 = &#123; name: &#x27;object1&#x27; &#125;;const obj2 = &#123; name: &#x27;object2&#x27; &#125;;wm.set(obj1, &#x27;value1&#x27;);wm.set(obj2, &#x27;value2&#x27;);console.log(wm.get(obj1)); // &#x27;value1&#x27;// 不能使用原始值作为键// wm.set(&#x27;string&#x27;, &#x27;value&#x27;); // TypeError// 弱引用特性let obj3 = &#123; name: &#x27;object3&#x27; &#125;;wm.set(obj3, &#x27;value3&#x27;);obj3 = null; // obj3 可以被垃圾回收，对应的 WeakMap 条目也会被清除

WeakMap 的实际应用// 1. 私有属性实现const privateData = new WeakMap();class Person &#123;  constructor(name, age) &#123;    privateData.set(this, &#123; name, age &#125;);  &#125;  getName() &#123;    return privateData.get(this).name;  &#125;  getAge() &#123;    return privateData.get(this).age;  &#125;&#125;const person = new Person(&#x27;Alice&#x27;, 30);console.log(person.getName()); // &#x27;Alice&#x27;console.log(person.name); // undefined// 2. DOM 元素关联数据const elementData = new WeakMap();function attachData(element, data) &#123;  elementData.set(element, data);&#125;function getData(element) &#123;  return elementData.get(element);&#125;// 使用const button = document.querySelector(&#x27;#myButton&#x27;);attachData(button, &#123; clickCount: 0 &#125;);button.addEventListener(&#x27;click&#x27;, () =&gt; &#123;  const data = getData(button);  data.clickCount++;  console.log(`Clicked $&#123;data.clickCount&#125; times`);&#125;);

内存管理优势// 使用 Map 可能造成内存泄漏const cache = new Map();function processData(obj) &#123;  if (cache.has(obj)) &#123;    return cache.get(obj);  &#125;    const result = expensiveOperation(obj);  cache.set(obj, result); // obj 被 Map 引用，无法被垃圾回收  return result;&#125;// 使用 WeakMap 避免内存泄漏const weakCache = new WeakMap();function processDataSafe(obj) &#123;  if (weakCache.has(obj)) &#123;    return weakCache.get(obj);  &#125;    const result = expensiveOperation(obj);  weakCache.set(obj, result); // obj 可以被正常垃圾回收  return result;&#125;

四、WeakSet：弱引用的值集合基本特性WeakSet 与 Set 类似，但具有以下特点：

只能存储对象
对象是弱引用的
不可迭代

const ws = new WeakSet();const obj1 = &#123; id: 1 &#125;;const obj2 = &#123; id: 2 &#125;;ws.add(obj1);ws.add(obj2);console.log(ws.has(obj1)); // true// 不能添加原始值// ws.add(1); // TypeError// 防止重复添加ws.add(obj1); // 不会报错，但也不会重复添加

实际应用场景// 1. 标记对象状态const disabledElements = new WeakSet();function disableElement(element) &#123;  disabledElements.add(element);  element.classList.add(&#x27;disabled&#x27;);&#125;function enableElement(element) &#123;  disabledElements.delete(element);  element.classList.remove(&#x27;disabled&#x27;);&#125;function isDisabled(element) &#123;  return disabledElements.has(element);&#125;// 2. 防止递归调用const processing = new WeakSet();function processObject(obj) &#123;  if (processing.has(obj)) &#123;    console.log(&#x27;Already processing this object&#x27;);    return;  &#125;    processing.add(obj);    try &#123;    // 处理对象    console.log(&#x27;Processing:&#x27;, obj);        // 如果对象有子对象，递归处理    if (obj.children) &#123;      obj.children.forEach(child =&gt; processObject(child));    &#125;  &#125; finally &#123;    processing.delete(obj);  &#125;&#125;

五、在 React 中的应用React Fiber 中的 WeakMap 使用React 的 Fiber 架构中使用 WeakMap 来存储组件相关的信息：
// React 源码简化示例const fiberNodeMap = new WeakMap();function createFiberNode(element) &#123;  const fiber = &#123;    type: element.type,    props: element.props,    // ... 其他 fiber 属性  &#125;;    // 将 DOM 元素与 Fiber 节点关联  if (element.dom) &#123;    fiberNodeMap.set(element.dom, fiber);  &#125;    return fiber;&#125;function getFiberFromDOM(domElement) &#123;  return fiberNodeMap.get(domElement);&#125;

React Hooks 中的 Map 应用// React Hooks 实现原理简化let currentComponent = null;const hooksMap = new Map();function useState(initialState) &#123;  const component = currentComponent;    if (!hooksMap.has(component)) &#123;    hooksMap.set(component, []);  &#125;    const hooks = hooksMap.get(component);  const hookIndex = hooks.length;    if (hooks[hookIndex] === undefined) &#123;    hooks[hookIndex] = &#123;      state: initialState,      setState: (newState) =&gt; &#123;        hooks[hookIndex].state = newState;        reRender(component);      &#125;    &#125;;  &#125;    return [hooks[hookIndex].state, hooks[hookIndex].setState];&#125;

六、在 Vue 中的应用Vue 3 响应式系统中的 WeakMapVue 3 的响应式系统大量使用了 WeakMap 来存储依赖关系：
// Vue 3 响应式原理简化const targetMap = new WeakMap();function track(target, key) &#123;  let depsMap = targetMap.get(target);  if (!depsMap) &#123;    targetMap.set(target, (depsMap = new Map()));  &#125;    let dep = depsMap.get(key);  if (!dep) &#123;    depsMap.set(key, (dep = new Set()));  &#125;    dep.add(activeEffect);&#125;function trigger(target, key) &#123;  const depsMap = targetMap.get(target);  if (!depsMap) return;    const dep = depsMap.get(key);  if (!dep) return;    dep.forEach(effect =&gt; effect());&#125;// 创建响应式对象function reactive(target) &#123;  return new Proxy(target, &#123;    get(target, key, receiver) &#123;      track(target, key);      return Reflect.get(target, key, receiver);    &#125;,    set(target, key, value, receiver) &#123;      const result = Reflect.set(target, key, value, receiver);      trigger(target, key);      return result;    &#125;  &#125;);&#125;

Vue 组件实例管理// Vue 组件实例缓存const instanceMap = new WeakMap();class VueComponent &#123;  constructor(options) &#123;    this.options = options;        // 将组件实例与其 DOM 元素关联    if (options.el) &#123;      instanceMap.set(options.el, this);    &#125;  &#125;    static getInstance(element) &#123;    return instanceMap.get(element);  &#125;&#125;// KeepAlive 组件的缓存实现const cache = new Map();const keys = new Set();function pruneCache(keepAliveInstance, filter) &#123;  cache.forEach((entry, key) =&gt; &#123;    const name = getComponentName(entry.componentInstance);    if (name &amp;&amp; !filter(name)) &#123;      pruneCacheEntry(key);    &#125;  &#125;);&#125;function pruneCacheEntry(key) &#123;  const cached = cache.get(key);  if (cached) &#123;    cached.componentInstance.$destroy();  &#125;  cache.delete(key);  keys.delete(key);&#125;

七、性能优化最佳实践选择合适的数据结构// 场景1：需要频繁检查元素是否存在// ❌ 不推荐：使用数组const permissions = [&#x27;read&#x27;, &#x27;write&#x27;, &#x27;delete&#x27;];if (permissions.includes(&#x27;write&#x27;)) &#123; &#125; // O(n)// ✅ 推荐：使用 Setconst permissionSet = new Set([&#x27;read&#x27;, &#x27;write&#x27;, &#x27;delete&#x27;]);if (permissionSet.has(&#x27;write&#x27;)) &#123; &#125; // O(1)// 场景2：需要关联 DOM 元素和数据// ❌ 不推荐：使用 Map（可能造成内存泄漏）const elementDataMap = new Map();// ✅ 推荐：使用 WeakMapconst elementDataWeakMap = new WeakMap();// 场景3：需要有序的键值对// ✅ Map 保持插入顺序const orderedMap = new Map([  [&#x27;first&#x27;, 1],  [&#x27;second&#x27;, 2],  [&#x27;third&#x27;, 3]]);

内存管理注意事项// 避免内存泄漏的模式class EventManager &#123;  constructor() &#123;    // 使用 WeakMap 存储事件监听器    this.listeners = new WeakMap();  &#125;    addEventListener(element, event, handler) &#123;    if (!this.listeners.has(element)) &#123;      this.listeners.set(element, new Map());    &#125;        const elementListeners = this.listeners.get(element);    if (!elementListeners.has(event)) &#123;      elementListeners.set(event, new Set());    &#125;        elementListeners.get(event).add(handler);    element.addEventListener(event, handler);  &#125;    removeEventListener(element, event, handler) &#123;    const elementListeners = this.listeners.get(element);    if (!elementListeners) return;        const eventHandlers = elementListeners.get(event);    if (!eventHandlers) return;        eventHandlers.delete(handler);    element.removeEventListener(event, handler);        // 清理空的集合    if (eventHandlers.size === 0) &#123;      elementListeners.delete(event);    &#125;    if (elementListeners.size === 0) &#123;      this.listeners.delete(element);    &#125;  &#125;&#125;

八、总结与建议何时使用 Map&#x2F;Set
Map：当你需要键值对集合，且键可能是对象或需要保持插入顺序时
Set：当你需要存储唯一值，或进行集合运算（并集、交集、差集）时

何时使用 WeakMap&#x2F;WeakSet
WeakMap：当你需要将数据与对象关联，且不想阻止对象被垃圾回收时
WeakSet：当你需要标记对象，或创建对象的弱引用集合时

性能考虑
查找性能：Map&#x2F;Set 的查找是 O(1)，而数组是 O(n)
内存管理：WeakMap&#x2F;WeakSet 有助于防止内存泄漏
迭代性能：Map&#x2F;Set 可以直接迭代，性能优于对象的 Object.keys()

这四种集合类型极大地丰富了 JavaScript 的数据结构选择，合理使用它们不仅能让代码更简洁、更具表现力，还能在性能和内存管理方面带来显著的提升。在现代前端框架的开发中，它们更是不可或缺的基础设施。
]]></content>
      <categories>
        <category>秋招准备</category>
      </categories>
      <tags>
        <tag>秋招</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>【秋招备战】React Router 进化史</title>
    <url>/2025/08/13/%E3%80%90%E7%A7%8B%E6%8B%9B%E5%A4%87%E6%88%98%E3%80%91React%20Router%20%E8%BF%9B%E5%8C%96%E5%8F%B2/</url>
    <content><![CDATA[
兄弟，还在为秋招发愁？今天咱们来聊聊 React Router 这个”老司机”。从 v5 的稳重大叔到 v6 的激进青年，再到 v7 的王者归来（直接吞并了 Remix），这个故事比宫斗剧还精彩。系好安全带，咱们发车了！

序章：为什么前端需要路由？还记得上古时代的网页吗？每点一个链接，整个页面”唰”地白屏，然后慢慢加载。用户体验？不存在的。
然后 SPA（单页应用）横空出世，页面不刷新了，但新问题来了：

浏览器的前进后退按钮废了
刷新页面就 404 了
分享链接？对不起，都是同一个 URL

这时候，前端路由站出来说：”这活儿我来！”
第一章：React Router v5 —— 稳重的老大哥v5 的基本使用React Router v5 就像个稳重的老司机，虽然有点啰嗦，但靠谱：
import &#123;   BrowserRouter as Router,   Route,   Switch,   Link,  useHistory,  useParams &#125; from &#x27;react-router-dom&#x27;;function App() &#123;  return (    &lt;Router&gt;      &lt;nav&gt;        &lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt;        &lt;Link to=&quot;/about&quot;&gt;关于&lt;/Link&gt;        &lt;Link to=&quot;/user/123&quot;&gt;用户详情&lt;/Link&gt;      &lt;/nav&gt;            &#123;/* Switch 确保只渲染第一个匹配的路由 */&#125;      &lt;Switch&gt;        &lt;Route exact path=&quot;/&quot;&gt;          &lt;Home /&gt;        &lt;/Route&gt;        &lt;Route path=&quot;/about&quot;&gt;          &lt;About /&gt;        &lt;/Route&gt;        &lt;Route path=&quot;/user/:id&quot;&gt;          &lt;UserDetail /&gt;        &lt;/Route&gt;        &lt;Route path=&quot;*&quot;&gt;          &lt;NotFound /&gt;        &lt;/Route&gt;      &lt;/Switch&gt;    &lt;/Router&gt;  );&#125;// 使用 hooks 获取路由信息function UserDetail() &#123;  const &#123; id &#125; = useParams(); // 获取路由参数  const history = useHistory(); // 获取 history 对象    const handleGoBack = () =&gt; &#123;    history.push(&#x27;/&#x27;); // 编程式导航  &#125;;    return (    &lt;div&gt;      &lt;h1&gt;用户 &#123;id&#125; 的详情页&lt;/h1&gt;      &lt;button onClick=&#123;handleGoBack&#125;&gt;返回首页&lt;/button&gt;    &lt;/div&gt;  );&#125;

v5 的高级技巧// 1. 路由配置化（更优雅的写法）const routes = [  &#123; path: &#x27;/&#x27;, component: Home, exact: true &#125;,  &#123; path: &#x27;/about&#x27;, component: About &#125;,  &#123; path: &#x27;/user/:id&#x27;, component: UserDetail &#125;];function App() &#123;  return (    &lt;Router&gt;      &lt;Switch&gt;        &#123;routes.map(route =&gt; (          &lt;Route             key=&#123;route.path&#125;            exact=&#123;route.exact&#125;            path=&#123;route.path&#125;            component=&#123;route.component&#125;          /&gt;        ))&#125;      &lt;/Switch&gt;    &lt;/Router&gt;  );&#125;// 2. 路由守卫（类似 Vue Router 的导航守卫）function PrivateRoute(&#123; children, ...rest &#125;) &#123;  const isAuthenticated = useAuth(); // 假设这是你的认证 hook    return (    &lt;Route &#123;...rest&#125;&gt;      &#123;isAuthenticated ? children : &lt;Redirect to=&quot;/login&quot; /&gt;&#125;    &lt;/Route&gt;  );&#125;// 3. 嵌套路由（v5 的痛点之一）function Users() &#123;  const &#123; path, url &#125; = useRouteMatch();    return (    &lt;div&gt;      &lt;Link to=&#123;`$&#123;url&#125;/profile`&#125;&gt;个人资料&lt;/Link&gt;      &lt;Link to=&#123;`$&#123;url&#125;/settings`&#125;&gt;设置&lt;/Link&gt;            &lt;Switch&gt;        &lt;Route exact path=&#123;path&#125;&gt;          &lt;h3&gt;请选择一个选项&lt;/h3&gt;        &lt;/Route&gt;        &lt;Route path=&#123;`$&#123;path&#125;/profile`&#125;&gt;          &lt;Profile /&gt;        &lt;/Route&gt;        &lt;Route path=&#123;`$&#123;path&#125;/settings`&#125;&gt;          &lt;Settings /&gt;        &lt;/Route&gt;      &lt;/Switch&gt;    &lt;/div&gt;  );&#125;

第二章：React Router v6 —— 激进的革命者v6 来了，带着破坏性更新，社区炸锅了：”你们是要搞事情吗？”
v6 的巨变import &#123;   BrowserRouter,  Routes,  // 注意：Switch 改名了  Route,   Link,  useNavigate,  // useHistory 改名了  useParams,  Outlet  // 新概念：插槽&#125; from &#x27;react-router-dom&#x27;;function App() &#123;  return (    &lt;BrowserRouter&gt;      &lt;Routes&gt;        &#123;/* 不再需要 exact，默认就是精确匹配 */&#125;        &lt;Route path=&quot;/&quot; element=&#123;&lt;Home /&gt;&#125; /&gt;        &lt;Route path=&quot;/about&quot; element=&#123;&lt;About /&gt;&#125; /&gt;                &#123;/* 嵌套路由的新写法，超级优雅！ */&#125;        &lt;Route path=&quot;/users&quot; element=&#123;&lt;Users /&gt;&#125;&gt;          &lt;Route index element=&#123;&lt;UserList /&gt;&#125; /&gt;          &lt;Route path=&quot;:id&quot; element=&#123;&lt;UserDetail /&gt;&#125; /&gt;          &lt;Route path=&quot;settings&quot; element=&#123;&lt;Settings /&gt;&#125; /&gt;        &lt;/Route&gt;                &#123;/* 404 页面的新写法 */&#125;        &lt;Route path=&quot;*&quot; element=&#123;&lt;NotFound /&gt;&#125; /&gt;      &lt;/Routes&gt;    &lt;/BrowserRouter&gt;  );&#125;// 父组件使用 Outlet 渲染子路由function Users() &#123;  return (    &lt;div&gt;      &lt;h1&gt;用户中心&lt;/h1&gt;      &lt;nav&gt;        &lt;Link to=&quot;&quot;&gt;用户列表&lt;/Link&gt;        &lt;Link to=&quot;settings&quot;&gt;设置&lt;/Link&gt;      &lt;/nav&gt;            &#123;/* Outlet 就像 Vue 的 router-view */&#125;      &lt;Outlet /&gt;    &lt;/div&gt;  );&#125;// 编程式导航的新写法function SomeComponent() &#123;  const navigate = useNavigate(); // 不再是 history.push    const handleClick = () =&gt; &#123;    navigate(&#x27;/about&#x27;); // 更直观    navigate(-1); // 后退    navigate(&#x27;/user/123&#x27;, &#123; replace: true &#125;); // 替换当前记录  &#125;;    return &lt;button onClick=&#123;handleClick&#125;&gt;走你！&lt;/button&gt;;&#125;

v6 的杀手锏功能// 1. 相对路由（终于不用拼接路径了！）function UserProfile() &#123;  return (    &lt;div&gt;      &#123;/* 相对于当前路由 */&#125;      &lt;Link to=&quot;..&quot;&gt;返回上级&lt;/Link&gt;      &lt;Link to=&quot;../settings&quot;&gt;设置&lt;/Link&gt;      &lt;Link to=&quot;edit&quot;&gt;编辑&lt;/Link&gt;    &lt;/div&gt;  );&#125;// 2. 路由配置对象（更接近 Vue Router）const routes = [  &#123;    path: &#x27;/&#x27;,    element: &lt;Layout /&gt;,    children: [      &#123; index: true, element: &lt;Home /&gt; &#125;,      &#123; path: &#x27;about&#x27;, element: &lt;About /&gt; &#125;,      &#123;        path: &#x27;users&#x27;,        element: &lt;Users /&gt;,        children: [          &#123; index: true, element: &lt;UserList /&gt; &#125;,          &#123; path: &#x27;:id&#x27;, element: &lt;UserDetail /&gt; &#125;        ]      &#125;    ]  &#125;];// 使用 useRoutes hookfunction App() &#123;  const element = useRoutes(routes);  return element;&#125;// 3. 懒加载（Suspense 集成）const LazyAbout = React.lazy(() =&gt; import(&#x27;./About&#x27;));&lt;Route   path=&quot;/about&quot;   element=&#123;    &lt;React.Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt;      &lt;LazyAbout /&gt;    &lt;/React.Suspense&gt;  &#125; /&gt;

第三章：底层原理 —— 路由的魔法是怎么实现的？来，让我们扒开 React Router 的外衣，看看它的真面目！
History API：一切的基础// 浏览器提供的 History APIwindow.history.pushState(state, title, url); // 添加历史记录window.history.replaceState(state, title, url); // 替换当前记录window.history.back(); // 后退window.history.forward(); // 前进// 监听路由变化window.addEventListener(&#x27;popstate&#x27;, (event) =&gt; &#123;  console.log(&#x27;路由变化了！&#x27;, location.pathname);&#125;);

简化版 React Router 实现让我们自己造个轮子，你就明白了：
// 1. 创建 Router Contextconst RouterContext = React.createContext();// 2. BrowserRouter 实现function BrowserRouter(&#123; children &#125;) &#123;  const [location, setLocation] = useState(window.location.pathname);    useEffect(() =&gt; &#123;    // 监听浏览器前进后退    const handlePopState = () =&gt; &#123;      setLocation(window.location.pathname);    &#125;;        window.addEventListener(&#x27;popstate&#x27;, handlePopState);    return () =&gt; window.removeEventListener(&#x27;popstate&#x27;, handlePopState);  &#125;, []);    const navigate = (to, options = &#123;&#125;) =&gt; &#123;    if (options.replace) &#123;      window.history.replaceState(null, &#x27;&#x27;, to);    &#125; else &#123;      window.history.pushState(null, &#x27;&#x27;, to);    &#125;    setLocation(to);  &#125;;    return (    &lt;RouterContext.Provider value=&#123;&#123; location, navigate &#125;&#125;&gt;      &#123;children&#125;    &lt;/RouterContext.Provider&gt;  );&#125;// 3. Route 组件实现function Route(&#123; path, element &#125;) &#123;  const &#123; location &#125; = useContext(RouterContext);    // 简化版路径匹配（真实的要复杂得多）  const match = matchPath(path, location);    return match ? element : null;&#125;// 4. Link 组件实现function Link(&#123; to, children &#125;) &#123;  const &#123; navigate &#125; = useContext(RouterContext);    const handleClick = (e) =&gt; &#123;    e.preventDefault(); // 阻止默认跳转    navigate(to);  &#125;;    return &lt;a href=&#123;to&#125; onClick=&#123;handleClick&#125;&gt;&#123;children&#125;&lt;/a&gt;;&#125;// 5. 路径匹配算法（简化版）function matchPath(pattern, pathname) &#123;  // 处理动态路由参数  // /user/:id =&gt; /user/123  const regexPattern = pattern    .replace(/:[^/]+/g, &#x27;([^/]+)&#x27;) // 替换 :id 为正则    .replace(/\*/g, &#x27;.*&#x27;); // 处理通配符      const regex = new RegExp(`^$&#123;regexPattern&#125;$`);  return regex.test(pathname);&#125;

Hash Router vs Browser Router// Hash Router：使用 URL 的 hash 部分// http://example.com/#/aboutclass HashRouter &#123;  constructor() &#123;    window.addEventListener(&#x27;hashchange&#x27;, this.handleHashChange);  &#125;    handleHashChange = () =&gt; &#123;    const path = window.location.hash.slice(1); // 去掉 #    this.updateView(path);  &#125;    push(path) &#123;    window.location.hash = path;  &#125;&#125;// Browser Router：使用 HTML5 History API// http://example.com/aboutclass BrowserRouter &#123;  constructor() &#123;    window.addEventListener(&#x27;popstate&#x27;, this.handlePopState);  &#125;    handlePopState = () =&gt; &#123;    this.updateView(window.location.pathname);  &#125;    push(path) &#123;    window.history.pushState(null, &#x27;&#x27;, path);    this.updateView(path);  &#125;&#125;

面试加分点：

Hash Router 兼容性好，但 URL 有个丑陋的 #
Browser Router 需要服务器配置支持（所有路由都返回 index.html）
Hash Router 不会发送到服务器，Browser Router 会

第四章：React Router v7 —— 王者归来（融合 Remix）2024 年底，React Router v7 震撼发布，直接把 Remix 给”吞并”了！
v7 的重磅特性：SSR 支持// v7 最大的变化：原生支持 SSR！// 这不是简单的路由了，这是全栈框架！// 1. 数据加载（类似 Next.js 的 getServerSideProps）export async function loader(&#123; params &#125;) &#123;  const user = await fetchUser(params.id);  return &#123; user &#125;;&#125;export default function UserProfile() &#123;  const &#123; user &#125; = useLoaderData();    return &lt;h1&gt;欢迎，&#123;user.name&#125;！&lt;/h1&gt;;&#125;// 2. Action 处理表单提交export async function action(&#123; request &#125;) &#123;  const formData = await request.formData();  const email = formData.get(&#x27;email&#x27;);    await updateEmail(email);  return redirect(&#x27;/profile&#x27;);&#125;export default function Settings() &#123;  return (    &lt;Form method=&quot;post&quot;&gt;      &lt;input name=&quot;email&quot; type=&quot;email&quot; /&gt;      &lt;button type=&quot;submit&quot;&gt;更新邮箱&lt;/button&gt;    &lt;/Form&gt;  );&#125;// 3. 错误边界export function ErrorBoundary() &#123;  const error = useRouteError();    return (    &lt;div&gt;      &lt;h1&gt;哎呀，出错了！&lt;/h1&gt;      &lt;p&gt;&#123;error.message&#125;&lt;/p&gt;    &lt;/div&gt;  );&#125;

v7 的完整 SSR 示例// app/routes/blog.$slug.jsximport &#123; useLoaderData &#125; from &#x27;react-router-dom&#x27;;// 服务器端数据获取export async function loader(&#123; params &#125;) &#123;  // 这段代码只在服务器运行！  const post = await db.post.findUnique(&#123;    where: &#123; slug: params.slug &#125;  &#125;);    if (!post) &#123;    throw new Response(&#x27;Not Found&#x27;, &#123; status: 404 &#125;);  &#125;    return &#123; post &#125;;&#125;// Meta 标签（SEO 优化）export function meta(&#123; data &#125;) &#123;  return [    &#123; title: data.post.title &#125;,    &#123; name: &#x27;description&#x27;, content: data.post.excerpt &#125;,    &#123; property: &#x27;og:title&#x27;, content: data.post.title &#125;  ];&#125;// 组件export default function BlogPost() &#123;  const &#123; post &#125; = useLoaderData();    return (    &lt;article&gt;      &lt;h1&gt;&#123;post.title&#125;&lt;/h1&gt;      &lt;time&gt;&#123;post.publishedAt&#125;&lt;/time&gt;      &lt;div dangerouslySetInnerHTML=&#123;&#123; __html: post.content &#125;&#125; /&gt;    &lt;/article&gt;  );&#125;// 流式 SSR（React 18 特性）export async function loader() &#123;  return defer(&#123;    critical: await getCriticalData(), // 立即加载    comments: getComments() // 延迟加载，流式传输  &#125;);&#125;export default function Post() &#123;  const &#123; critical, comments &#125; = useLoaderData();    return (    &lt;div&gt;      &lt;h1&gt;&#123;critical.title&#125;&lt;/h1&gt;      &lt;Suspense fallback=&#123;&lt;LoadingComments /&gt;&#125;&gt;        &lt;Await resolve=&#123;comments&#125;&gt;          &#123;(comments) =&gt; &lt;Comments data=&#123;comments&#125; /&gt;&#125;        &lt;/Await&gt;      &lt;/Suspense&gt;    &lt;/div&gt;  );&#125;

第五章：版本迁移指南 —— 从 v5 到 v6&#x2F;v7主要变化对照表


特性
v5
v6&#x2F;v7



路由容器
&lt;Switch&gt;
&lt;Routes&gt;


路由组件
component=&#123;Component&#125;
element=&#123;&lt;Component /&gt;&#125;


嵌套路由
手动拼接路径
自动处理，使用 &lt;Outlet&gt;


导航 Hook
useHistory
useNavigate


路由匹配
需要 exact
默认精确匹配


相对链接
不支持
完全支持


迁移示例// v5 老代码function OldApp() &#123;  const history = useHistory();    return (    &lt;Switch&gt;      &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125; /&gt;      &lt;Route path=&quot;/users/:id&quot; component=&#123;UserDetail&#125; /&gt;    &lt;/Switch&gt;  );&#125;// v6/v7 新代码function NewApp() &#123;  const navigate = useNavigate();    return (    &lt;Routes&gt;      &lt;Route path=&quot;/&quot; element=&#123;&lt;Home /&gt;&#125; /&gt;      &lt;Route path=&quot;/users/:id&quot; element=&#123;&lt;UserDetail /&gt;&#125; /&gt;    &lt;/Routes&gt;  );&#125;// 复杂嵌套路由迁移// v5：需要在每个组件里处理function Users() &#123;  const &#123; path, url &#125; = useRouteMatch();  return (    &lt;Switch&gt;      &lt;Route exact path=&#123;path&#125; component=&#123;UserList&#125; /&gt;      &lt;Route path=&#123;`$&#123;path&#125;/:id`&#125; component=&#123;UserDetail&#125; /&gt;    &lt;/Switch&gt;  );&#125;// v6/v7：集中配置&lt;Route path=&quot;/users&quot; element=&#123;&lt;Users /&gt;&#125;&gt;  &lt;Route index element=&#123;&lt;UserList /&gt;&#125; /&gt;  &lt;Route path=&quot;:id&quot; element=&#123;&lt;UserDetail /&gt;&#125; /&gt;&lt;/Route&gt;

第六章：实战技巧与性能优化1. 路由懒加载// 配合 React.lazy 和 Suspenseconst LazyDashboard = lazy(() =&gt;   import(/* webpackChunkName: &quot;dashboard&quot; */ &#x27;./Dashboard&#x27;));function App() &#123;  return (    &lt;Routes&gt;      &lt;Route         path=&quot;/dashboard/*&quot;         element=&#123;          &lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt;            &lt;LazyDashboard /&gt;          &lt;/Suspense&gt;        &#125;       /&gt;    &lt;/Routes&gt;  );&#125;

2. 路由预加载// 鼠标悬停时预加载function PreloadableLink(&#123; to, children &#125;) &#123;  const handleMouseEnter = () =&gt; &#123;    // 预加载组件    import(`./pages$&#123;to&#125;`);  &#125;;    return (    &lt;Link to=&#123;to&#125; onMouseEnter=&#123;handleMouseEnter&#125;&gt;      &#123;children&#125;    &lt;/Link&gt;  );&#125;

3. 路由过渡动画import &#123; CSSTransition, TransitionGroup &#125; from &#x27;react-transition-group&#x27;;function AnimatedRoutes() &#123;  const location = useLocation();    return (    &lt;TransitionGroup&gt;      &lt;CSSTransition        key=&#123;location.pathname&#125;        timeout=&#123;300&#125;        classNames=&quot;fade&quot;      &gt;        &lt;Routes location=&#123;location&#125;&gt;          &lt;Route path=&quot;/&quot; element=&#123;&lt;Home /&gt;&#125; /&gt;          &lt;Route path=&quot;/about&quot; element=&#123;&lt;About /&gt;&#125; /&gt;        &lt;/Routes&gt;      &lt;/CSSTransition&gt;    &lt;/TransitionGroup&gt;  );&#125;/* CSS */.fade-enter &#123;  opacity: 0;&#125;.fade-enter-active &#123;  opacity: 1;  transition: opacity 300ms;&#125;.fade-exit &#123;  opacity: 1;&#125;.fade-exit-active &#123;  opacity: 0;  transition: opacity 300ms;&#125;

4. 路由级别的状态管理// 使用 location.state 传递临时数据function ProductList() &#123;  const navigate = useNavigate();    const handleEdit = (product) =&gt; &#123;    navigate(&#x27;/edit&#x27;, &#123;       state: &#123; product, from: &#x27;/products&#x27; &#125;     &#125;);  &#125;;&#125;function EditProduct() &#123;  const location = useLocation();  const navigate = useNavigate();  const product = location.state?.product;    const handleSave = async (data) =&gt; &#123;    await saveProduct(data);    // 返回来源页面    navigate(location.state?.from || &#x27;/&#x27;);  &#125;;&#125;

第七章：面试必考题面试官：React Router 的原理是什么？标准答案： React Router 基于浏览器的 History API，通过监听 URL 变化来渲染对应的组件。核心原理：

使用 Context 在组件树中传递路由状态
Route 组件根据当前 URL 匹配 path 来决定是否渲染
Link 组件阻止默认行为，调用 history.pushState 更新 URL
监听 popstate 事件处理浏览器前进后退

面试官：如何实现路由守卫？// v6/v7 的实现方式function RequireAuth(&#123; children &#125;) &#123;  const auth = useAuth();  const location = useLocation();    if (!auth.user) &#123;    // 记录用户想去的页面，登录后跳转    return &lt;Navigate to=&quot;/login&quot; state=&#123;&#123; from: location &#125;&#125; replace /&gt;;  &#125;    return children;&#125;// 使用&lt;Route   path=&quot;/protected&quot;   element=&#123;    &lt;RequireAuth&gt;      &lt;ProtectedPage /&gt;    &lt;/RequireAuth&gt;  &#125; /&gt;

面试官：Hash Router 和 Browser Router 的区别？加分回答：

Hash Router：URL 带 #，不需要服务器配置，不支持 SSR
Browser Router：更美观的 URL，需要服务器配置，支持 SSR
Memory Router：URL 不变化，用于 React Native 或测试
Static Router：用于 SSR，不会改变 URL

面试官：React Router v6 为什么要做 Breaking Changes？高情商回答： v6 的改动虽然很大，但带来了：

更小的包体积（减少约 50%）
更好的 TypeScript 支持
更直观的嵌套路由
相对路径支持
为 SSR 做准备（v7 实现了）

结语：路由的未来从 v5 的稳重，到 v6 的激进，再到 v7 的全栈化，React Router 的进化史就是前端发展的缩影。记住：

v5 还在广泛使用，很多老项目没有升级
v6 是过渡，新项目建议直接上
v7 是未来，SSR 成为标配

最后给秋招的你一些建议：

面试时能讲清楚版本差异会很加分
理解原理比记 API 重要 100 倍
如果面试官问到 v7，说明这是家技术很新的公司
准备一个路由相关的项目亮点，比如”我用路由懒加载优化了 70% 的首屏加载时间”

记住：技术是在不断进化的，保持学习的心态比掌握某个版本的 API 更重要。今天的 v7，可能就是明天的 “legacy code”。

P.S. 如果这篇文章帮到了你，记得收藏起来。毕竟，面试前临时抱佛脚的时候，你会感谢现在认真看完的自己的！
P.P.S. React Router 团队：求求你们，别再搞破坏性更新了，我们学不动了… 😭
]]></content>
      <categories>
        <category>秋招准备</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>秋招</tag>
        <tag>ReactRouter</tag>
      </tags>
  </entry>
  <entry>
    <title>【秋招备战】React状态管理方案：Redux vs MobX</title>
    <url>/2025/08/13/%E3%80%90%E7%A7%8B%E6%8B%9B%E5%A4%87%E6%88%98%E3%80%91React%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88%EF%BC%9ARedux%20vs%20MobX/</url>
    <content><![CDATA[
朋友，听说你在准备秋招？那今天咱们来聊聊前端江湖里的两大门派——Redux 和 MobX。这两位可都是状态管理界的大佬，一个像少林寺的易筋经，招式规矩森严；一个像逍遥派的北冥神功，灵活自在。让我们一起揭开它们的神秘面纱。

第一章：初入江湖——为什么需要状态管理？想象一下，你在开发一个电商网站。用户的购物车数据需要在导航栏、购物车页面、结账页面共享，如果没有状态管理，你就得像传话游戏一样，一层层把数据传下去：
// 没有状态管理的痛苦传话游戏&lt;App cartItems=&#123;cartItems&#125;&gt;  &lt;Header cartItems=&#123;cartItems&#125;&gt;    &lt;CartIcon cartItems=&#123;cartItems&#125;&gt;      &lt;CartCount count=&#123;cartItems.length&#125; /&gt; // 终于到了！累死了...    &lt;/CartIcon&gt;  &lt;/Header&gt;&lt;/App&gt;

这就是传说中的”prop drilling”（属性钻孔），钻着钻着，你就想掀桌子了。
第二章：Redux——规矩森严的少林派Redux 的基本招式Redux 就像一个超级严格的图书管理员，它有三大金科玉律：

单一数据源（Single Source of Truth）：整个应用只有一个 store，就像图书馆只有一个总目录
State 是只读的：你不能直接改书，只能提交申请
使用纯函数修改：修改必须按规矩来，不能搞特殊

来看看 Redux 的基本套路：
// 1. 定义 Action（你的申请单）const ADD_TO_CART = &#x27;ADD_TO_CART&#x27;;const addToCart = (product) =&gt; (&#123;  type: ADD_TO_CART,  payload: product&#125;);// 2. 创建 Reducer（图书管理员的处理规则）const cartReducer = (state = [], action) =&gt; &#123;  switch (action.type) &#123;    case ADD_TO_CART:      // 注意！必须返回新对象，不能直接修改      return [...state, action.payload];    default:      return state;  &#125;&#125;;// 3. 创建 Store（图书馆）import &#123; createStore &#125; from &#x27;redux&#x27;;const store = createStore(cartReducer);// 4. 使用 Storestore.dispatch(addToCart(&#123; id: 1, name: &#x27;秋招面试宝典&#x27;, price: 99 &#125;));console.log(store.getState()); // [&#123; id: 1, name: &#x27;秋招面试宝典&#x27;, price: 99 &#125;]

Redux 的内功心法——实现原理Redux 的核心其实就是一个发布-订阅模式，我来给你”解剖”一下它的内部构造：
// 简化版 Redux 实现（去掉了中间件等复杂功能）function createStore(reducer, initialState) &#123;  let state = initialState;  let listeners = []; // 订阅者名单    // 获取当前状态  const getState = () =&gt; state;    // 订阅变化  const subscribe = (listener) =&gt; &#123;    listeners.push(listener);    // 返回取消订阅的函数（贴心不？）    return () =&gt; &#123;      listeners = listeners.filter(l =&gt; l !== listener);    &#125;;  &#125;;    // 派发 action  const dispatch = (action) =&gt; &#123;    // 通过 reducer 计算新状态    state = reducer(state, action);    // 通知所有订阅者：&quot;兄弟们，数据更新了！&quot;    listeners.forEach(listener =&gt; listener());    return action;  &#125;;    // 初始化 state  dispatch(&#123; type: &#x27;@@INIT&#x27; &#125;);    return &#123; getState, subscribe, dispatch &#125;;&#125;

看到了吗？Redux 就像一个严格的广播电台：

dispatch 一个 action &#x3D; 发送广播信号
reducer 处理 &#x3D; 电台处理信号
通知所有 listeners &#x3D; 广播给所有收音机

Redux 在 React 中的实战在 React 中使用 Redux，需要 react-redux 这个”翻译官”：
// 1. 使用 Provider 包裹应用import &#123; Provider &#125; from &#x27;react-redux&#x27;;function App() &#123;  return (    &lt;Provider store=&#123;store&#125;&gt;      &lt;YourAppComponents /&gt;    &lt;/Provider&gt;  );&#125;// 2. 使用 hooks 连接组件import &#123; useSelector, useDispatch &#125; from &#x27;react-redux&#x27;;function ShoppingCart() &#123;  // useSelector 就像一个监视器，盯着 state 的变化  const cartItems = useSelector(state =&gt; state.cart);  const dispatch = useDispatch();    const handleAddItem = (product) =&gt; &#123;    dispatch(addToCart(product));  &#125;;    return (    &lt;div&gt;      &lt;h2&gt;购物车（&#123;cartItems.length&#125;件商品）&lt;/h2&gt;      &#123;/* ... */&#125;    &lt;/div&gt;  );&#125;

第三章：MobX——自由奔放的逍遥派如果说 Redux 是个严格的图书管理员，那 MobX 就是个贴心的私人助理。它会自动追踪你需要什么，然后在数据变化时自动更新。
MobX 的基本招式import &#123; makeObservable, observable, action, computed &#125; from &#x27;mobx&#x27;;class ShoppingCart &#123;  items = [];    constructor() &#123;    // 告诉 MobX：&quot;帮我盯着这些东西&quot;    makeObservable(this, &#123;      items: observable,      addItem: action,      removeItem: action,      totalPrice: computed    &#125;);  &#125;    // 直接修改，没有那么多规矩  addItem(product) &#123;    this.items.push(product);  &#125;    removeItem(id) &#123;    const index = this.items.findIndex(item =&gt; item.id === id);    if (index &gt; -1) &#123;      this.items.splice(index, 1);    &#125;  &#125;    // 计算属性，自动缓存  get totalPrice() &#123;    return this.items.reduce((sum, item) =&gt; sum + item.price, 0);  &#125;&#125;const cart = new ShoppingCart();

看到了吗？MobX 就像你的贴心小棉袄，你直接改数据就行，它会自动通知该通知的人。
MobX 的内功心法——响应式原理MobX 的魔法主要来自于 ES6 的 Proxy（或者在老版本中用 Object.defineProperty）。让我来揭秘一下：
// 简化版 MobX 原理function makeObservable(target) &#123;  const observers = new Set(); // 观察者集合    // 使用 Proxy 拦截对象操作  return new Proxy(target, &#123;    get(obj, prop) &#123;      // 收集依赖：&quot;哦，有人在读取这个属性&quot;      if (currentObserver) &#123;        observers.add(currentObserver);      &#125;      return obj[prop];    &#125;,        set(obj, prop, value) &#123;      obj[prop] = value;      // 通知观察者：&quot;兄弟们，数据变了！&quot;      observers.forEach(observer =&gt; observer());      return true;    &#125;  &#125;);&#125;// 追踪函数执行时访问了哪些属性let currentObserver = null;function autorun(fn) &#123;  currentObserver = fn;  fn(); // 执行一次，收集依赖  currentObserver = null;&#125;// 使用示例const person = makeObservable(&#123; name: &#x27;小明&#x27;, age: 25 &#125;);autorun(() =&gt; &#123;  console.log(`$&#123;person.name&#125; 今年 $&#123;person.age&#125; 岁`);&#125;);person.age = 26; // 自动触发 console.log

MobX 的精髓就是：

依赖收集：当你读取数据时，MobX 偷偷记下”谁在用这个数据”
自动更新：当数据变化时，MobX 通知所有用到这个数据的地方

这就像你在淘宝收藏了一个商品，降价时自动给你发通知一样贴心！
MobX 在 React 中的实战import &#123; observer &#125; from &#x27;mobx-react-lite&#x27;;// observer 是个高阶组件，让组件&quot;有眼力见&quot;const ShoppingCart = observer(() =&gt; &#123;  // 直接使用，没有 hook，没有 dispatch  const cart = useCart(); // 假设这是你的 cart store    return (    &lt;div&gt;      &lt;h2&gt;购物车（&#123;cart.items.length&#125;件商品）&lt;/h2&gt;      &lt;p&gt;总价：&#123;cart.totalPrice&#125;元&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; cart.addItem(newProduct)&#125;&gt;        添加商品      &lt;/button&gt;    &lt;/div&gt;  );&#125;);

第四章：江湖对决——Redux vs MobX好了，两位大侠的绝学都展示完了，让我们来个正面对决：
学习曲线Redux：就像学开手动挡汽车，一开始各种熄火，但学会了你就是老司机。

Action、Reducer、Store、Middleware… 概念一大堆
必须理解函数式编程思想
代码量多（这也叫 boilerplate）

MobX：像自动挡，上手就能开，但你可能不知道变速箱怎么工作的。

面向对象，符合直觉
装饰器语法很优雅
代码量少

可预测性Redux：
// Redux 的每一步都有迹可循dispatch(action) → reducer → new state → UI update// 时间旅行调试，可以回放每个 action

MobX：
// MobX 的更新是自动的，有时候像黑魔法observable.value = newValue → ??? → UI update// 调试时可能会想：&quot;咦，这咋就更新了？&quot;

性能优化Redux：

需要手动优化（useSelector、reselect 等）
容易产生不必要的渲染
但优化后性能很好

MobX：

自动优化，只更新真正需要更新的组件
细粒度的响应式更新
开箱即用的好性能

使用场景选 Redux 的场景：

大型应用，需要严格的数据流
团队协作，需要统一的规范
需要时间旅行调试
需要持久化、同步等高级功能

选 MobX 的场景：

中小型应用，追求开发效率
有很多派生状态（computed）
团队熟悉面向对象编程
不想写太多样板代码

第五章：实战技巧与注意事项Redux 的坑与技巧
不可变更新的坑：

// ❌ 错误：直接修改state.items.push(newItem);// ✅ 正确：返回新对象return &#123;  ...state,  items: [...state.items, newItem]&#125;;// 💡 技巧：使用 Immer 简化不可变更新import produce from &#x27;immer&#x27;;const reducer = produce((draft, action) =&gt; &#123;  // 现在可以直接修改 draft  draft.items.push(action.payload);&#125;);


异步处理：

// 使用 Redux Thunk 处理异步const fetchUserData = (userId) =&gt; async (dispatch) =&gt; &#123;  dispatch(&#123; type: &#x27;FETCH_START&#x27; &#125;);  try &#123;    const data = await api.getUser(userId);    dispatch(&#123; type: &#x27;FETCH_SUCCESS&#x27;, payload: data &#125;);  &#125; catch (error) &#123;    dispatch(&#123; type: &#x27;FETCH_ERROR&#x27;, payload: error &#125;);  &#125;&#125;;

MobX 的坑与技巧
观察数组和对象：

// ⚠️ 注意：MobX 4/5 需要使用 observable 数组的方法class Store &#123;  @observable items = [];    @action addItem(item) &#123;    // ✅ 这样会触发更新    this.items.push(item);        // ❌ 这样不会触发更新（MobX 4/5）    // this.items[this.items.length] = item;  &#125;&#125;


避免过度使用 computed：

class Store &#123;  @observable users = [];    // ✅ 好的 computed：有复杂计算  @computed get activeUsers() &#123;    return this.users.filter(u =&gt; u.isActive &amp;&amp; u.lastLogin &gt; someDate);  &#125;    // ❌ 不必要的 computed：太简单了  @computed get userCount() &#123;    return this.users.length; // 直接用 users.length 就行  &#125;&#125;

第六章：2024 年的新趋势Redux Toolkit —— Redux 的现代化改造Redux 听到了大家的抱怨，推出了 Redux Toolkit (RTK)：
import &#123; createSlice &#125; from &#x27;@reduxjs/toolkit&#x27;;// 一个 slice 搞定 actions + reducerconst cartSlice = createSlice(&#123;  name: &#x27;cart&#x27;,  initialState: [],  reducers: &#123;    addItem: (state, action) =&gt; &#123;      // 可以直接修改！RTK 内置了 Immer      state.push(action.payload);    &#125;,    removeItem: (state, action) =&gt; &#123;      return state.filter(item =&gt; item.id !== action.payload);    &#125;  &#125;&#125;);export const &#123; addItem, removeItem &#125; = cartSlice.actions;export default cartSlice.reducer;

MobX 6 的新特性MobX 6 带来了更简洁的 API：
import &#123; makeAutoObservable &#125; from &#x27;mobx&#x27;;class Store &#123;  items = [];    constructor() &#123;    // 自动将所有属性和方法变成 observable/action    makeAutoObservable(this);  &#125;    addItem(item) &#123;    this.items.push(item);  &#125;&#125;

第七章：面试高频问题面试官：Redux 的中间件原理是什么？你的回答：中间件就像快递的中转站，action 在到达 reducer 之前会经过中间件处理：
// 中间件的本质是函数组合const middleware = store =&gt; next =&gt; action =&gt; &#123;  console.log(&#x27;dispatching&#x27;, action);  const result = next(action); // 调用下一个中间件  console.log(&#x27;next state&#x27;, store.getState());  return result;&#125;;

面试官：MobX 和 Vue 的响应式有什么区别？你的回答：

Vue 2：使用 Object.defineProperty，需要预定义属性
Vue 3 和 MobX：都使用 Proxy，可以动态添加属性
MobX 是显式声明（makeObservable），Vue 是自动的（data 函数）

结语：没有银弹，只有权衡记住，Redux 和 MobX 都是工具，没有绝对的好坏。就像金庸小说里，降龙十八掌刚猛无比，凌波微步飘逸灵动，关键看你要打什么怪。
给秋招的你一些建议：

两个都要了解，但精通一个就够了
理解原理比会用 API 更重要
项目中遇到状态管理的痛点，才能真正理解这些工具的价值
面试时能讲清楚权衡（trade-off）比死记硬背更加分

最后，祝你秋招顺利，offer 拿到手软！记住，技术只是工具，解决问题的思维才是核心竞争力。

P.S. 如果这篇文章对你有帮助，记得给未来的同事们也分享一下。毕竟，独乐乐不如众乐乐，一起进步才是真的进步！
]]></content>
      <categories>
        <category>秋招准备</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>秋招</tag>
        <tag>Redux</tag>
        <tag>Mobx</tag>
      </tags>
  </entry>
  <entry>
    <title>【秋招备战】 Object.defineProperty vs Proxy</title>
    <url>/2025/08/07/%E3%80%90%E7%A7%8B%E6%8B%9B%E5%A4%87%E6%88%98%E3%80%91%E5%B1%9E%E6%80%A7%E5%8A%AB%E6%8C%81/</url>
    <content><![CDATA[
 如果你曾经好奇 Vue2 和 Vue3 的响应式原理有什么区别，或者在面试中被问到”如何实现数据劫持”时一脸懵逼，那么恭喜你，这篇文章就是你的救星！

📖 开篇：一个对象的自我修养在 JavaScript 的世界里，对象就像是一个个小盒子，我们可以往里面放东西（属性），也可以取东西。但是有一天，产品经理突然说：”我想知道用户什么时候打开盒子，什么时候往里面放东西！”
这时候，Object.defineProperty 和 Proxy 就闪亮登场了——它们就是对象世界的”监控摄像头”。
🎭 第一幕：Object.defineProperty - 老牌特工基本概念Object.defineProperty() 是 ES5 引入的方法，它可以精确地定义或修改对象的属性，并且可以控制属性的行为。就像给对象的某个属性装上了一个”智能锁”。
基础语法Object.defineProperty(obj, prop, descriptor)


obj：要定义属性的对象
prop：要定义或修改的属性名
descriptor：属性描述符对象

属性描述符的两种形态属性描述符分为两种：数据描述符和存取描述符（不能同时使用）。
1. 数据描述符const person = &#123;&#125;;Object.defineProperty(person, &#x27;name&#x27;, &#123;  value: &#x27;张三&#x27;,           // 属性值  writable: true,         // 是否可写（默认 false）  enumerable: true,       // 是否可枚举（默认 false）  configurable: true      // 是否可配置（默认 false）&#125;);console.log(person.name); // 张三person.name = &#x27;李四&#x27;;      // 因为 writable: true，所以可以修改console.log(person.name); // 李四

2. 存取描述符（重点！）这就是实现”数据劫持”的核心：
let internalValue = &#x27;我是内部值&#x27;;const obj = &#123;&#125;;Object.defineProperty(obj, &#x27;magicProp&#x27;, &#123;  enumerable: true,  configurable: true,  get() &#123;    console.log(&#x27;🔍 有人在读取 magicProp！&#x27;);    return internalValue;  &#125;,  set(newValue) &#123;    console.log(`✏️ 有人在设置 magicProp 为: $&#123;newValue&#125;`);    internalValue = newValue;  &#125;&#125;);obj.magicProp;           // 🔍 有人在读取 magicProp！obj.magicProp = &#x27;新值&#x27;;   // ✏️ 有人在设置 magicProp 为: 新值

实战案例：简易版 Vue2 响应式// 模拟 Vue2 的响应式原理function observe(obj) &#123;  Object.keys(obj).forEach(key =&gt; &#123;    let internalValue = obj[key];        Object.defineProperty(obj, key, &#123;      get() &#123;        console.log(`📊 收集依赖: $&#123;key&#125;`);        return internalValue;      &#125;,      set(newValue) &#123;        console.log(`🔄 触发更新: $&#123;key&#125; = $&#123;newValue&#125;`);        internalValue = newValue;        // 这里可以触发视图更新      &#125;    &#125;);  &#125;);&#125;const data = &#123; count: 0, message: &#x27;Hello&#x27; &#125;;observe(data);data.count;        // 📊 收集依赖: countdata.count = 1;    // 🔄 触发更新: count = 1

Object.defineProperty 的局限性
无法监听数组索引的变化

const arr = [1, 2, 3];observe(arr);arr[0] = 999;  // 无法触发 setterarr.push(4);   // 无法监听


必须遍历对象的每个属性

// 如果有嵌套对象，需要递归处理const complexObj = &#123;  user: &#123;    name: &#x27;张三&#x27;,    address: &#123;      city: &#x27;北京&#x27;    &#125;  &#125;&#125;;// 需要递归遍历所有层级


无法监听新增属性

const obj = &#123; a: 1 &#125;;observe(obj);obj.b = 2;  // 新增属性 b 不会被监听

🦸 第二幕：Proxy - 新时代的全能管家基本概念Proxy 是 ES6 引入的新特性，它可以创建一个对象的代理，从而实现对这个对象的基本操作的拦截和自定义。如果说 Object.defineProperty 是给属性装监控，那 Proxy 就是给整个对象配了一个全能管家。
基础语法const proxy = new Proxy(target, handler)


target：要代理的目标对象
handler：一个对象，定义了各种拦截行为

13 种拦截方法Proxy 支持拦截 13 种操作，常用的有：
const handler = &#123;  get(target, property, receiver) &#123;&#125;,      // 读取属性  set(target, property, value, receiver) &#123;&#125;, // 设置属性  has(target, property) &#123;&#125;,                // in 操作符  deleteProperty(target, property) &#123;&#125;,     // delete 操作  ownKeys(target) &#123;&#125;,                      // Object.keys()  // ... 还有其他拦截方法&#125;;

基础示例const person = &#123;  name: &#x27;张三&#x27;,  age: 25&#125;;const personProxy = new Proxy(person, &#123;  get(target, property) &#123;    console.log(`🔍 正在访问属性: $&#123;property&#125;`);    return target[property];  &#125;,  set(target, property, value) &#123;    console.log(`✏️ 正在设置属性: $&#123;property&#125; = $&#123;value&#125;`);    target[property] = value;    return true;  // 表示设置成功  &#125;&#125;);personProxy.name;           // 🔍 正在访问属性: namepersonProxy.age = 26;       // ✏️ 正在设置属性: age = 26personProxy.hobby = &#x27;编程&#x27;;  // ✏️ 正在设置属性: hobby = 编程（新属性也能监听！）

高级应用：数组的完美监听const arr = [1, 2, 3];const arrProxy = new Proxy(arr, &#123;  get(target, property) &#123;    console.log(`访问数组: arr[$&#123;property&#125;]`);    return target[property];  &#125;,  set(target, property, value) &#123;    console.log(`修改数组: arr[$&#123;property&#125;] = $&#123;value&#125;`);    target[property] = value;    return true;  &#125;&#125;);arrProxy[0] = 999;    // 修改数组: arr[0] = 999arrProxy.push(4);     // 访问数组: arr[push]                      // 访问数组: arr[length]                      // 修改数组: arr[3] = 4                      // 修改数组: arr[length] = 4

实战案例：实现一个智能对象// 创建一个&quot;智能&quot;对象，自动验证和转换数据const smartObj = new Proxy(&#123;&#125;, &#123;  set(target, property, value) &#123;    // 自动类型转换    if (property === &#x27;age&#x27;) &#123;      value = Number(value);      if (isNaN(value) || value &lt; 0 || value &gt; 150) &#123;        throw new Error(&#x27;年龄必须是 0-150 之间的数字&#x27;);      &#125;    &#125;        // 自动格式化    if (property === &#x27;phone&#x27;) &#123;      value = value.replace(/[^0-9]/g, &#x27;&#x27;);      if (value.length !== 11) &#123;        throw new Error(&#x27;手机号必须是 11 位&#x27;);      &#125;    &#125;        console.log(`✅ 设置 $&#123;property&#125; = $&#123;value&#125;`);    target[property] = value;    return true;  &#125;&#125;);smartObj.age = &#x27;25&#x27;;        // ✅ 设置 age = 25（自动转数字）smartObj.phone = &#x27;138-0000-0000&#x27;; // ✅ 设置 phone = 13800000000（自动格式化）// smartObj.age = &#x27;一百岁&#x27;;  // 抛出错误！

⚔️ 终极对决：Object.defineProperty vs Proxy


特性
Object.defineProperty
Proxy



兼容性
ES5，兼容 IE9+
ES6，不支持 IE


监听范围
单个属性
整个对象


监听数组索引
❌ 不支持
✅ 支持


监听新增属性
❌ 需要额外处理
✅ 自动支持


监听删除属性
❌ 不支持
✅ 支持


性能
需要递归遍历，初始化慢
懒处理，按需拦截


操作原对象
直接修改原对象
不修改原对象，返回代理


🎯 面试高频考点1. Vue2 vs Vue3 响应式原理// Vue2 风格（简化版）function reactive2(obj) &#123;  Object.keys(obj).forEach(key =&gt; &#123;    let value = obj[key];    Object.defineProperty(obj, key, &#123;      get() &#123;        // 依赖收集        return value;      &#125;,      set(newValue) &#123;        value = newValue;        // 触发更新      &#125;    &#125;);  &#125;);  return obj;&#125;// Vue3 风格（简化版）function reactive3(obj) &#123;  return new Proxy(obj, &#123;    get(target, key) &#123;      // 依赖收集      return target[key];    &#125;,    set(target, key, value) &#123;      target[key] = value;      // 触发更新      return true;    &#125;  &#125;);&#125;

2. 如何实现一个简单的观察者模式？class Observer &#123;  constructor(data) &#123;    this.data = data;    this.callbacks = &#123;&#125;;    this.observe();  &#125;    observe() &#123;    const that = this;    this.proxy = new Proxy(this.data, &#123;      set(target, property, value) &#123;        target[property] = value;        // 触发回调        if (that.callbacks[property]) &#123;          that.callbacks[property].forEach(cb =&gt; cb(value));        &#125;        return true;      &#125;    &#125;);    return this.proxy;  &#125;    subscribe(property, callback) &#123;    if (!this.callbacks[property]) &#123;      this.callbacks[property] = [];    &#125;    this.callbacks[property].push(callback);  &#125;&#125;// 使用const obs = new Observer(&#123; count: 0 &#125;);const data = obs.observe();obs.subscribe(&#x27;count&#x27;, (value) =&gt; &#123;  console.log(`count 变化了: $&#123;value&#125;`);&#125;);data.count = 1;  // count 变化了: 1

🚀 总结：选择的智慧
使用 Object.defineProperty 的场景：
需要兼容旧浏览器（IE9+）
只需要监听已知的、固定的属性
项目已经大量使用且稳定运行


使用 Proxy 的场景：
不需要考虑 IE 兼容性
需要监听数组变化
需要监听动态新增的属性
需要实现更复杂的拦截逻辑
新项目优先选择



💡 最后的小贴士记住这个口诀：

defineProperty 是保安：只能看着指定的几个门（属性）
Proxy 是管家：整个房子（对象）的事都管

面试时如果被问到，记得提到：

两者的本质区别（属性级 vs 对象级）
Vue2 到 Vue3 的升级原因
各自的优缺点和适用场景

现在，你已经掌握了 JavaScript 中两个最强大的”对象监控”技术。下次面试官问你”如何实现数据双向绑定”时，你可以自信地说：”这题我会，而且我还能告诉你两种方法的优缺点！”

Happy Coding! 愿你的秋招之路一帆风顺！ 🎉
]]></content>
      <categories>
        <category>秋招准备</category>
      </categories>
      <tags>
        <tag>秋招</tag>
        <tag>ES</tag>
        <tag>八股</tag>
      </tags>
  </entry>
  <entry>
    <title>【秋招备战】计算机网络</title>
    <url>/2025/07/22/%E3%80%90%E7%A7%8B%E6%8B%9B%E5%A4%87%E6%88%98%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[前言计算机网络作为前端开发中绕不开的基础知识，面试时也特爱问，很多时候都有可能被打一个冷不防。这份文档旨在整理前端面试中高频出现的计算机网络知识点，希望能帮助到正在准备面试的你。
内容基于个人面试经验和学习总结，如有不当之处，欢迎指正交流。  本文不追求面面俱到，而是聚焦于前端面试中的高频考点，力求每个知识点都讲透彻、讲实用。
一、HTTP 协议篇1.1 HTTP 基础
HTTP 是什么？
核心答案： HTTP（超文本传输协议）是应用层协议，基于TCP&#x2F;IP，采用请求-响应模式，无状态。用于客户端和服务器之间传输超文本数据。

HTTP 请求方法详解
核心答案：

GET：获取资源，幂等，可缓存
POST：提交数据，非幂等，不可缓存
PUT：更新整个资源，幂等
DELETE：删除资源，幂等
HEAD：获取响应头，不返回body
OPTIONS：预检请求，询问支持的方法
PATCH：部分更新资源


HTTP 状态码分类及常见状态码
核心答案：

1xx：信息提示（100 Continue）
2xx：成功（200 OK、201 Created、204 No Content）
3xx：重定向（301永久、302临时、304未修改）
4xx：客户端错误（400 Bad Request、401未授权、403禁止、404未找到）
5xx：服务器错误（500内部错误、502网关错误、503服务不可用）


HTTP 报文结构
请求报文：请求行：GET /index.html HTTP/1.1请求头：Host: www.example.com空行请求体：（POST请求的数据）响应报文：状态行：HTTP/1.1 200 OK响应头：Content-Type: text/html空行响应体：&lt;html&gt;...&lt;/html&gt;

1.2 HTTP 缓存机制
强缓存 vs 协商缓存
核心答案：

强缓存：不发请求，直接从缓存取（Cache-Control、Expires）
协商缓存：发请求询问服务器，资源是否更新（ETag&#x2F;If-None-Match、Last-Modified&#x2F;If-Modified-Since）

理解tips：

强缓存像冰箱里的牛奶：看保质期（Cache-Control），没过期直接喝
协商缓存像打电话问妈妈：冰箱里的菜还能吃吗？妈妈说能吃（304）就吃，不能吃就买新的（200）


Cache-Control 详解
// 常用指令Cache-Control: max-age=3600     // 强缓存3600秒Cache-Control: no-cache         // 需要协商缓存Cache-Control: no-store         // 不缓存Cache-Control: private          // 只能浏览器缓存Cache-Control: public           // 可以被代理服务器缓存Cache-Control: must-revalidate  // 过期前可用，过期后必须验证

记忆技巧： “max定时间，no-cache要协商，no-store不存储”

ETag 和 Last-Modified
核心答案：

Last-Modified：文件最后修改时间（精度秒级，可能误判）
ETag：文件内容哈希值（精度高，需要计算）

优先级： ETag &gt; Last-Modified（ETag更准确）
实际场景：
// 第一次请求Response Headers:  Last-Modified: Mon, 10 Jan 2024 10:00:00 GMT  ETag: &quot;abc123&quot;// 第二次请求Request Headers:  If-Modified-Since: Mon, 10 Jan 2024 10:00:00 GMT  If-None-Match: &quot;abc123&quot;// 未修改返回304，修改了返回200+新内容



缓存位置（Memory Cache、Disk Cache等）
核心答案（优先级从高到低）：

Service Worker：可编程控制
Memory Cache：内存缓存，快但量小，关闭Tab就没了
Disk Cache：硬盘缓存，慢但量大，持久化
Push Cache：HTTP&#x2F;2推送缓存，会话级别

记忆口诀： “Service控制权最高，Memory快但活不久，Disk慢但能持久，Push是HTTP&#x2F;2特有”


1.3 HTTP 版本演进
HTTP&#x2F;1.0 vs HTTP&#x2F;1.1
核心答案： HTTP&#x2F;1.1 的改进：

持久连接：Connection: keep-alive（默认开启）
管道化：可以同时发多个请求（但有队头阻塞）
Host头：支持虚拟主机
断点续传：Range头支持
缓存增强：Cache-Control、ETag等

理解tips：

HTTP&#x2F;1.0像打一次电话说一件事就挂
HTTP&#x2F;1.1像打一次电话可以说多件事


HTTP&#x2F;2 的优势（多路复用、服务器推送等）
核心答案：

二进制分帧：将数据分成帧，不再是文本
多路复用：一个TCP连接并行处理多个请求
头部压缩：HPACK算法压缩头部
服务器推送：主动推送资源
流优先级：可以设置请求优先级

理解tips： HTTP&#x2F;1.1像单车道排队通行，HTTP&#x2F;2像多车道高速并行通行

HTTP&#x2F;3 和 QUIC 协议
核心答案：

基于UDP：避免TCP的队头阻塞
0-RTT建连：减少握手延迟
连接迁移：IP变化不断连（手机切换WiFi&#x2F;4G）
改进的拥塞控制：更快的恢复

记忆要点： “HTTP&#x2F;3 &#x3D; HTTP&#x2F;2 + QUIC(UDP)”


1.4 HTTPS 安全通信
HTTP vs HTTPS
核心答案：

HTTP：明文传输，80端口，不安全
HTTPS：HTTP + SSL&#x2F;TLS加密，443端口，安全


HTTPS 加密原理
核心答案（混合加密）：

非对称加密：交换对称密钥（慢但安全）
对称加密：传输数据（快）
数字证书：验证服务器身份
摘要算法：验证数据完整性

理解tips： 像寄贵重物品：先用保险箱（对称加密）装东西，用挂号信（非对称加密）寄保险箱钥匙，快递公司的营业执照（数字证书）证明身份

HTTPS 握手过程：
精简版答案：

Client Hello：客户端发送支持的加密套件
Server Hello：服务器选择加密套件+发送证书
客户端验证证书：验证证书合法性
生成会话密钥：用服务器公钥加密随机数
服务器解密：得到会话密钥
加密通信：使用会话密钥对称加密

中间人攻击：
核心答案： 攻击者在客户端和服务器之间，分别与两者建立连接，窃取或篡改数据。
防御方式：

数字证书验证
HSTS（强制使用HTTPS）
证书锁定（Certificate Pinning）



二、TCP&#x2F;IP 协议篇2.1 TCP 基础
TCP 三次握手详解
核心答案：

SYN：客户端发送SYN&#x3D;1, seq&#x3D;x
SYN+ACK：服务器发送SYN&#x3D;1, ACK&#x3D;1, seq&#x3D;y, ack&#x3D;x+1
ACK：客户端发送ACK&#x3D;1, seq&#x3D;x+1, ack&#x3D;y+1

生动比喻： 像打电话：

“喂，听得到吗？”（SYN）
“听得到，你听得到我吗？”（SYN+ACK）
“我也听得到”（ACK）

为什么需要三次握手？
核心答案：

确认双方收发能力正常
防止已失效的连接请求突然传到服务器
同步双方序列号

两次不行的原因： 无法确认客户端的接收能力，可能造成服务器资源浪费

TCP 四次挥手详解
核心答案：

FIN：客户端发送FIN，进入FIN_WAIT_1
ACK：服务器发送ACK，客户端进入FIN_WAIT_2
FIN：服务器发送FIN，进入LAST_ACK
ACK：客户端发送ACK，进入TIME_WAIT

为什么是四次不是三次？ 服务器收到FIN时可能还有数据要发送，所以ACK和FIN分开发送
TIME_WAIT 状态的作用：
核心答案：

持续2MSL（最大报文生存时间）
作用：
确保最后的ACK能到达
让所有报文在网络中消失，避免影响新连接





2.2 TCP 可靠传输
序列号和确认应答
核心答案：

序列号：给每个字节编号，保证数据顺序
确认应答：ACK&#x3D;期望收到的下一个序列号
累积确认：确认号之前的数据都已收到

理解tips： 像老师点名：1号到了，2号到了…如果说”我要3号”，说明1、2号都到了

超时重传机制
核心答案：

RTO（超时时间）&#x3D; RTT（往返时间）+ 4×RTT偏差
超时加倍：每次超时RTO翻倍（避免网络雪崩）
快速重传：收到3个重复ACK立即重传（不等超时）

记忆要点： “超时要等，快重传收3个重复ACK就传”

流量控制（滑动窗口）
核心答案：

接收窗口：接收方告诉发送方自己还能接收多少数据
发送窗口：发送方根据接收窗口调整发送量
零窗口探测：窗口为0时定期发送探测报文

生动比喻： 像自助餐：服务员（接收方）告诉你盘子还能装多少（窗口大小），装满了就说”等一下”（窗口为0）

拥塞控制
核心答案（四个算法）：

慢开始：指数增长（1,2,4,8…）
拥塞避免：线性增长（到达阈值后）
快重传：3个重复ACK立即重传
快恢复：阈值减半，不重新慢开始

记忆口诀： “慢开始指数增，避免后线性增，快重传3个ACK，快恢复阈值减半”


2.3 TCP vs UDP
两者的区别对比
核心答案：



TCP
UDP



可靠传输
不可靠


面向连接
无连接


字节流
数据报


有序
可能乱序


有流量控制、拥塞控制
无


头部20字节
头部8字节


一对一
支持一对多、多对多


记忆技巧： TCP像打电话（可靠但费事），UDP像发短信（快但不保证送达）

各自的应用场景
TCP适用：

HTTP&#x2F;HTTPS
FTP文件传输
SMTP邮件
SSH远程登录

UDP适用：

DNS查询
视频直播&#x2F;语音通话
游戏实时对战
DHCP


为什么视频直播常用 UDP？
核心答案：

实时性要求高：宁可丢帧也不要卡顿
可以容忍少量丢包：丢几帧人眼察觉不到
不需要重传：重传的旧数据没意义



三、浏览器网络篇3.1 跨域问题
同源策略是什么？
核心答案：

同源：协议+域名+端口都相同
限制：DOM访问、Cookie&#x2F;LocalStorage读取、AJAX请求
不限制：&lt;script&gt;、&lt;img&gt;、&lt;link&gt;标签

记忆要点： “协议域名端口，三同才同源”

跨域的解决方案汇总
核心答案（按常用度排序）：

CORS：服务器设置Access-Control-Allow-Origin
代理服务器：同源服务器转发请求
JSONP：script标签+回调函数
WebSocket：没有同源限制
postMessage：iframe通信


CORS 详解
核心答案：
// 简单请求（GET/POST/HEAD + 简单头）Access-Control-Allow-Origin: *Access-Control-Allow-Credentials: true  // 携带Cookie// 预检请求（复杂请求先发OPTIONS）Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: Content-Type, X-TokenAccess-Control-Max-Age: 86400  // 预检缓存时间

触发预检的条件：

非简单请求方法（PUT&#x2F;DELETE等）
自定义请求头
Content-Type不是简单类型


JSONP 原理及限制
核心答案：
// 原理：动态创建script标签function jsonp(url, callback) &#123;  const script = document.createElement(&#x27;script&#x27;);  window[callback] = function(data) &#123;    console.log(data);    delete window[callback];    document.body.removeChild(script);  &#125;  script.src = `$&#123;url&#125;?callback=$&#123;callback&#125;`;  document.body.appendChild(script);&#125;

限制：

只支持GET请求
可能XSS攻击
错误处理困难



3.2 经典问题：从 URL 到页面展示非常详细的一片回答：https://bytetech.info/articles/6903166461217341454?searchId=2025081516181986474146815928AE395F
3.3 WebSocket
WebSocket vs HTTP
核心答案：



HTTP
WebSocket



半双工
全双工


无状态
有状态


请求-响应模式
持久连接


文本&#x2F;二进制
帧协议


每次请求都有头部
建立后头部开销小



WebSocket 连接过程
核心答案：
// 1. 握手请求（HTTP升级）GET /ws HTTP/1.1Upgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==// 2. 握手响应HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=// 3. 数据传输（使用帧）const ws = new WebSocket(&#x27;ws://localhost:8080&#x27;);ws.onmessage = (e) =&gt; console.log(e.data);ws.send(&#x27;Hello Server&#x27;);

应用场景：

实时聊天
实时推送
协同编辑
实时游戏
股票行情



四、Web 安全篇4.1 XSS 攻击
XSS 类型（反射型、存储型、DOM型）
核心答案：

反射型XSS：URL参数直接输出到页面
存储型XSS：恶意脚本存入数据库
DOM型XSS：修改DOM节点触发

记忆口诀： “反射即时现，存储入库险，DOM改节点”

XSS 防御策略
// 1. 输入过滤（不可靠）// 2. 输出转义（核心）function escape(str) &#123;  return str    .replace(/&amp;/g, &#x27;&amp;amp;&#x27;)    .replace(/&lt;/g, &#x27;&amp;lt;&#x27;)    .replace(/&gt;/g, &#x27;&amp;gt;&#x27;)    .replace(/&quot;/g, &#x27;&amp;quot;&#x27;)    .replace(/&#x27;/g, &#x27;&amp;#x27;&#x27;);&#125;// 3. CSP内容安全策略Content-Security-Policy: default-src &#x27;self&#x27;// 4. HttpOnly Cookie（防止JS读取）Set-Cookie: session=abc; HttpOnly

CSP 内容安全策略
// 限制资源加载来源Content-Security-Policy:   default-src &#x27;self&#x27;;           // 默认同源  script-src &#x27;self&#x27; cdn.com;    // JS来源  style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;; // CSS来源  img-src *;                     // 图片来源  connect-src api.example.com;  // AJAX/WebSocket

4.2 CSRF 攻击
CSRF 攻击原理
核心答案： 跨站请求伪造：利用用户已登录的身份，诱导用户访问恶意网站，恶意网站向目标网站发送请求。
攻击流程：

用户登录银行网站，有了Cookie
用户访问恶意网站
恶意网站发送转账请求到银行
浏览器自动带上Cookie
银行执行转账

生动比喻： 像偷用你的身份证：你登录了银行（有身份证明），骗子网站偷偷拿你的身份证明去办事

CSRF 防御方法
// 1. CSRF Token// 服务器生成token放在表单中&lt;input type=&quot;hidden&quot; name=&quot;csrf_token&quot; value=&quot;random_token&quot;&gt;// 2. 验证Refererif (request.headers.referer !== &#x27;https://mybank.com&#x27;) &#123;  return 403;&#125;// 3. SameSite CookieSet-Cookie: session=abc; SameSite=Strict;  // 完全禁止第三方Set-Cookie: session=abc; SameSite=Lax;     // 部分允许（链接可以）Set-Cookie: session=abc; SameSite=None;    // 都允许（需HTTPS）// 4. 双重Cookie验证// Cookie中和请求参数都带token，服务器对比

记忆要点： “Token验身份，Referer看来源，SameSite限Cookie”


五、性能优化篇5.1 网络层优化
减少 HTTP 请求数
// 1. 资源合并// CSS Sprites、JS/CSS打包// 2. 内联资源// 小图片base64、关键CSS内联// 3. 使用缓存// 强缓存避免请求// 4. 懒加载// 图片懒加载、路由懒加载

使用 HTTP&#x2F;2
核心答案：

多路复用减少连接数
服务器推送关键资源
头部压缩减少传输量
请求优先级优化加载顺序


启用 Gzip 压缩
// Nginx配置gzip on;gzip_types text/plain text/css application/javascript;gzip_min_length 1024;gzip_comp_level 6;  // 压缩级别1-9// 效果：通常能压缩60-80%

使用 CDN
核心答案：

就近访问：用户访问最近节点
负载均衡：分散服务器压力
缓存静态资源：减少源站压力
抗DDoS：分布式架构

记忆要点： “CDN &#x3D; 内容分发网络，让用户就近拿资源”


5.2 资源加载优化
预加载（preload、prefetch）
&lt;!-- preload：当前页面必需，高优先级 --&gt;&lt;link rel=&quot;preload&quot; href=&quot;style.css&quot; as=&quot;style&quot;&gt;&lt;link rel=&quot;preload&quot; href=&quot;font.woff2&quot; as=&quot;font&quot; crossorigin&gt;&lt;!-- prefetch：未来页面需要，低优先级 --&gt;&lt;link rel=&quot;prefetch&quot; href=&quot;next-page.js&quot;&gt;&lt;!-- dns-prefetch：预解析DNS --&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//api.example.com&quot;&gt;&lt;!-- preconnect：预建立连接(DNS+TCP+TLS) --&gt;&lt;link rel=&quot;preconnect&quot; href=&quot;//api.example.com&quot;&gt;

懒加载
// 1. 图片懒加载// Intersection Observer APIconst observer = new IntersectionObserver((entries) =&gt; &#123;  entries.forEach(entry =&gt; &#123;    if (entry.isIntersecting) &#123;      const img = entry.target;      img.src = img.dataset.src;      observer.unobserve(img);    &#125;  &#125;);&#125;);// 2. 路由懒加载const Home = () =&gt; import(&#x27;./views/Home.vue&#x27;);// 3. 组件懒加载const HeavyComponent = React.lazy(() =&gt; import(&#x27;./Heavy&#x27;));



图片优化策略
// 1. 选择合适格式WebP &gt; JPEG/PNG    // 新浏览器JPEG：照片        // 有损压缩PNG：透明图       // 无损压缩SVG：图标矢量图   // 可缩放// 2. 响应式图片&lt;picture&gt;  &lt;source srcset=&quot;image.webp&quot; type=&quot;image/webp&quot;&gt;  &lt;source srcset=&quot;image.jpg&quot; type=&quot;image/jpeg&quot;&gt;  &lt;img src=&quot;image.jpg&quot; alt=&quot;&quot;&gt;&lt;/picture&gt;// 3. 图片尺寸&lt;img srcset=&quot;320w.jpg 320w, 640w.jpg 640w&quot;      sizes=&quot;(max-width: 320px) 320px, 640px&quot;&gt;// 4. 渐进式加载// 先模糊后清晰（如知乎、Medium）

六、实战题目篇（收录各大公司真实面试题及详解）
]]></content>
      <categories>
        <category>秋招准备</category>
      </categories>
      <tags>
        <tag>秋招</tag>
        <tag>计算机网络</tag>
        <tag>面试八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>【秋招准备】面试手撕大集合</title>
    <url>/2025/07/22/%E3%80%90%E7%A7%8B%E6%8B%9B%E5%A4%87%E6%88%98%E3%80%91%E9%9D%A2%E8%AF%95%E6%89%8B%E6%92%95%E5%A4%A7%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[所有遍历数组的方法forEach// 自定义 forEach 函数，添加到 Array 原型链Array.prototype.myForEach = function (callback, thisArg) &#123;    // 类型检查：确保 callback 是一个函数    if (typeof callback !== &#x27;function&#x27;) &#123;        throw new TypeError(&#x27;第一个参数必须是一个函数&#x27;);    &#125;    // 遍历数组，调用 callback 函数    for (let i = 0; i &lt; this.length; i++) &#123;        // 如果数组的当前元素是 undefined 或 null, 则跳过        if (i in this) &#123;//对于数组而言，in运算符用于检查是否有这个索引值            callback.call(thisArg, this[i], i, this);        &#125;    &#125;&#125;;

map// 自定义 Map 函数，添加到 Array 原型链Array.prototype.myMap = function (callback) &#123;    // 类型检查：确保 callback 是一个函数    if (typeof callback !== &#x27;function&#x27;) &#123;        throw new TypeError(&#x27;第一个参数必须是一个函数&#x27;);    &#125;    let res = [];    // 遍历数组，调用 callback 函数    for (let i = 0; i &lt; this.length; i++) &#123;        // 如果数组的当前元素是 undefined 或 null, 则跳过        if (i in this) &#123;            res.push(callback(this[i], i, this));        &#125;    &#125;    return res&#125;;

FilterArray.prototype.my_filter = function (cb) &#123;    let newArr = []    for (var i = 0; i &lt; this.length; i++) &#123;        if (cb(this[i], i, this)) &#123;            newArr.push(this[i])        &#125;    &#125;    return newArr&#125;

every(判断数组中的每一个元素是否都满足某个条件)Array.prototype.my_every = function (cb) &#123;    for (let i = 0; i &lt; this.length; i++) &#123;        if (!cb(this[i], i, this)) &#123;            return false;        &#125;    &#125;    return true;&#125;

some（判断数组中是否存在一个元素满足某个条件）Array.prototype.my_some = function (cb) &#123;    for (let i = 0; i &lt; this.length; i++) &#123;        if (cb(this[i], i, this)) &#123;            return true;        &#125;    &#125;    return false;&#125;

reduceArray.prototype.my_reduce = function (cb, ...args) &#123;    let start, index = 0    if (args.length) &#123;        start = args[0]    &#125; else &#123;        start = this[0];        index = 1    &#125;    for (let i = index; i &lt; this.length; i++) &#123;        start = cb(start, this[i], i, this);    &#125;    return start;&#125;

includesArray.prototype.my_includes = function (item, ...args) &#123;    let index    if (args.length &amp;&amp; !Number.isNaN(Number(args[0])) &amp;&amp; Number(args[0])&gt;0) &#123;        index = Number(args[0])    &#125; else &#123;        index = 0;    &#125;    for (let i = index; i &lt; this.length; i++) &#123;        if (this[i] === item) return true;    &#125;    return false&#125;

spliceArray.prototype.mySplice = function (start, len, ...args) &#123;    let newArr = [], resArr = [];    if (arguments.length === 0) return resArr;    if (typeof len === &#x27;undefined&#x27;) &#123;        len = 0;    &#125;    if (typeof start === &#x27;undefined&#x27;) &#123;        start = 0;    &#125; else if (start &lt; 0) &#123;        start = start + this.length;        start = start &lt; 0 ? 0 : start;    &#125; else if (start &gt;= this.length) &#123;        start = this.length;    &#125;    for (let i = 0; i &lt; this.length; ++i) &#123;        if (i &lt; start || i &gt;= start + len) &#123;            newArr.push(this[i]);        &#125; else &#123;            resArr.push(this[i]);        &#125;        if (i === start || start + i === this.length * 2 - 1) &#123;            newArr.push(...args);        &#125;    &#125;    while (this.length) &#123;        this.pop();    &#125;    this.push(...newArr);    return resArr;&#125;

JS内置方法、对象以及运算符new运算符function myNew (Func, ...arg)&#123;        if (fn.prototype === undefined) throw new TypeError(&#x27;function is not a constructor&#x27;);        let obj = &#123;&#125;  //定义了一个对象。        obj.__proto__ = Func.prototype          //将Func.prototype赋值为对象的__proto__属性,即原型链的概念        let res = Func.call(obj, ...arg) //更改Func的this指向        return res instanceof Object ? res : obj &#125;

手撕curryconst my_curry = (fn, ...args) =&gt;    args.length &gt;= fn.length        ? fn(...args)        : (...args1) =&gt; my_curry(fn, ...args, ...args1);function adder(x, y, z) &#123;    return x + y + z;&#125;const add = my_curry(adder);console.log(add(1, 2, 3));  //6console.log(add(1)(2)(3));  //6console.log(add(1, 2)(3));  //6console.log(add(1)(2, 3));  //6

手写compose函数const compose = (...fns)=&gt;(x)=&gt;fns.reduceRight((v, fn)=&gt;fn(v),x);const doubleAndSuare = compose(double, square);//先翻倍再平方console.log(doubleAndSuare(3));

手撕vue3响应式代理//测试代码class Depend &#123;  constructor() &#123;    this.reactiveFns = new Set()//依赖组  &#125;  // 更好的收集依赖  depend() &#123;    if (activeReactiveFn) this.reactiveFns.add(activeReactiveFn)  &#125;  //对所有依赖进行统一通知处理  notify() &#123;    console.log(this.reactiveFns)    this.reactiveFns.forEach(fn =&gt; &#123;      //遍历依赖处理      if (fn) fn()    &#125;)  &#125;&#125;// 封装响应式函数let activeReactiveFn = nullfunction watchFn(fn) &#123;  activeReactiveFn = fn  fn()  activeReactiveFn = null&#125;// 封装一个获取depend函数const targetMap = new WeakMap()function getDepend(target, key) &#123;  // 1、根据target对象获取map的过程  let map = targetMap.get(target)  if (!map) &#123;    map = new Map()    targetMap.set(target, map)  &#125;  // 2、根据对象属性获取depend依赖  let depend = map.get(key)  if (!depend) &#123;    depend = new Depend()    map.set(key, depend)  &#125;  return depend&#125;//使用Proxy监听对象变化function reactive(obj) &#123;  return new Proxy(obj, &#123;    get: function (target, key, receiver) &#123;      const depend = getDepend(target, key)      depend.depend()      return Reflect.get(target, key, receiver)    &#125;,    set: function (target, key, newValue, receiver) &#123;      Reflect.set(target, key, newValue, receiver)      const depend = getDepend(target, key)      depend.notify()    &#125;  &#125;)&#125;const obj = &#123;  name: &quot;coderwhy&quot;,//depend实例对象  age: 18//depend实例对象&#125;const info = &#123;  name:&quot;小余&quot;,  age:18&#125;//响应式开关媒介const objRef = reactive(&#123;  name: &quot;coderwhy&quot;,  age: 18&#125;)const infoRef = reactive(&#123;  name:&quot;小余&quot;,  age:18&#125;)watchFn(() =&gt; &#123;  console.log(infoRef.name);  &#125;)watchFn(() =&gt; &#123;  console.log(objRef.name);  &#125;)infoRef.name = &#x27;响应式-小余&#x27;objRef.name = &#x27;响应式-coderwhy&#x27;// 小余// coderwhy// Set(1) &#123; [Function (anonymous)] &#125;// 响应式-小余// Set(1) &#123; [Function (anonymous)] &#125;// 响应式-coderwhy

手撕instanceofconst myInstanceOf=(Left,Right)=&gt;&#123;  if(!Left)&#123;    return false  &#125;  while(Left)&#123;    if(Left.__proto__===Right.prototype)&#123;      return true    &#125;else&#123;      Left=Left.__proto__    &#125;  &#125;  return false&#125;//验证console.log(myInstanceOf(&#123;&#125;,Array));  //false

call，bind，applyfunction foo(x,y)&#123;  console.log(this.a,x+y);&#125;const obj=&#123;  a:1&#125;Function.prototype.myCall=function(context,...args)&#123;  if(typeof this !== &#x27;function&#x27;)  return new TypeError(&#x27;is not a function&#x27;)  const fn = Symbol(&#x27;fn&#x27;) //使用Symbol尽可能降低myCall对其他的影响  context[fn] = this  //this指向foo  const res = context[fn](...args)  //解构，调用fn  delete context[fn]  //不要忘了删除obj上的工具函数fn  return res  //将结果返回&#125;//验证foo.myCall(obj,1,2)   //1,3function foo(x,y)&#123;  console.log(this.a,x+y);&#125;const obj=&#123;  a:1&#125;Function.prototype.myApply=function(context,args)&#123;  if(typeof this !== &#x27;function&#x27;)  return new TypeError(&#x27;is not a function&#x27;)  const fn = Symbol(&#x27;fn&#x27;) //使用Symbol尽可能降低myCall对其他的影响  context[fn] = this  //this指向foo  const res = context[fn](...args)  //解构，调用fn  delete context[fn]  //不要忘了删除obj上的工具函数fn  return res  //将结果返回&#125;//验证foo.myApply(obj,1,2)   //1,3function foo(x,y,z)&#123;  this.name=&#x27;zt&#x27;  console.log(this.a,x+y+z);&#125;const obj=&#123;  a:1&#125;Function.prototype.myBind=function(context,...args)&#123;  if(typeof this !== &#x27;function&#x27;)  return new TypeError(&#x27;It is not a function&#x27;);  context = context || window; // 上下文环境  const _this = this; // 当前的函数的上下文this  return function F(...arg) &#123;    //判断返回出去的F有没有被new，有就要把foo给到new出来的对象    if (this instanceof F) &#123;       return new _this(...args, ...arg);    &#125; else &#123;       _this.call(this, ...args, ...arg);    &#125;  &#125;&#125;//验证const bar=foo.myBind(obj,1,2)console.log(new bar(3));   //undefined 6  foo &#123; name: &#x27;zt&#x27; &#125;

值相等function compare(data1, data2) &#123;  if (typeof data1 != typeof data2) &#123;    return false;  &#125;  if (typeof data1 != &quot;object&quot; &amp;&amp; typeof data1 == typeof data2) &#123;    return data1 === data2;  &#125;  if ((!data1 instanceof Array &amp;&amp; data2 instanceof Array) || (data1 instanceof Array &amp;&amp; !data2 instanceof Array)) &#123;    return false;  &#125; else if (data1 instanceof Array  &amp;&amp; data2 instanceof Array) &#123;    if (data1.length == data2.length) &#123;      for (let i = 0; i &lt; data1.length; i++) &#123;        if (!compare(data1[i], data2[i])) &#123;          return false;        &#125;      &#125;    &#125; else &#123;      return false;    &#125;  &#125; else &#123;      if (Object.keys(data1).length == Object.keys(data2).length) &#123;      for (let key in data1) &#123;        if (!data2[key] || !compare(data1[key], data2[key])) &#123;          return false;        &#125;      &#125;    &#125; else &#123;      return false;    &#125;  &#125;  return true;&#125;

深拷贝function isObject(value) &#123;  const valueType = typeof value  return (value !== null) &amp;&amp; (valueType === &quot;object&quot; || valueType === &quot;function&quot;)&#125;function deepClone(originValue) &#123;  // 判断传入的originValue是否是一个对象类型  if (!isObject(originValue)) &#123;    return originValue  &#125;  const newObject = &#123;&#125;  for (const key in originValue) &#123;    newObject[key] = deepClone(originValue[key])  &#125;  //返回通过递归深层遍历赋值后，全新的数据对象  return newObject&#125;

实现Object.create()创建一个空对象，定义其原型对象并设置其枚举属性
// proto 可以是object 或者functionObject.myCreate = function (proto, defineProperties)&#123;    if((typeof proto === &#x27;object&#x27; &amp;&amp; proto !== null) || typeof proto === &#x27;function&#x27;)&#123;        let obj = &#123;&#125;;        // obj.__proto__ = proto;        Object.setPrototypeOf(obj, proto);        Object.defineProperty(obj, defineProperties);        return obj;    &#125;else &#123;        throw new TypeError(&#x27;类型错误&#x27;);    &#125;&#125;

实现Object.assign（浅拷贝）function myAssign(target,...objs)&#123;    if(target === null || target === undefined)&#123;        throw new TypeError(&quot;can not convert null or undefined to object&quot;)    &#125;    let res = Object(target)    objs.forEach(obj =&gt; &#123;        &#x27;use strict&#x27;        if(obj != null &amp;&amp; obj != undefined)&#123;            for(let key in obj)&#123;                //hasOwnProperty用来判断一个属性是定义在对象本身而不是继承自原型链的                if(Object.prototype.hasOwnProperty.call(obj,key))&#123;                    res[key] = obj[key]                &#125;            &#125;        &#125;    &#125;)    return res&#125;Object.defineProperty(Object,&#x27;myAssign&#x27;,&#123;    value: myAssign,    writable: true,    configurable: true,    enumerable: false&#125;)

trim方法function myTrim(str) &#123;  const reg = /^\s+|\s+$/g;  return str.replace(reg, &#x27;&#x27;);&#125;

模板字符串const render = (template, data) =&gt; &#123;    const reg = /\$\&#123;(.*?)\&#125;/g;    template = template.replace(reg, (match, key) =&gt; &#123;        let keys = key.trim().split(&#x27;.&#x27;);        return keys.reduce((obj, k) =&gt; obj?.[k], data) || &#x27;&#x27;;    &#125;)    return template;&#125;

sleep函数function sleep(ms) &#123;    return new Promise((resolve) =&gt; &#123;        setTimeout(() =&gt; &#123;            console.log(&#x27;sleep...&#x27;)            resolve()        &#125;, ms);    &#125;)&#125;async function test()&#123;    console.log(&#x27;1&#x27;);    await sleep(400)    console.log(&#x27;2&#x27;)&#125;test();

利用setTimeout实现setIntervalfunction coustomSetInterval(callback, time) &#123;    let intervalId = null;    function loop() &#123;        intervalId = setTimeout(() =&gt; &#123;            callback();            loop();        &#125;, time)    &#125;    loop();    return () =&gt; clearTimeout(intervalId)&#125;const interval = coustomSetInterval(() =&gt; &#123;    console.log(&#x27;想你了&#x27;)&#125;, 1000)setTimeout(() =&gt; &#123;    interval()&#125;, 5000)

🚀 Promise 源码实现完全指南 - 从零手写 Promise
🎯 阅读本节你将收获：

深入理解 Promise 内部运行机制
手写一个符合 Promise&#x2F;A+ 规范的 Promise
掌握面试中 Promise 相关的核心考点
理解 async&#x2F;await 的实现原理


📌 开篇：为什么要手写 Promise？在面试中，Promise 相关的题目可以说是必考题。但很多同学只会用，不知道其内部原理。今天我们就一起来揭开 Promise 的神秘面纱，手写一个完整的 Promise！
一、Promise 基础架构 - 搭建地基 🏗️1.1 最简单的 Promise 结构我们先从最简单的结构开始，就像盖房子要先打地基：
class MyPromise &#123;    constructor(executor) &#123;        // executor 是使用者传入的函数，形如 (resolve, reject) =&gt; &#123;&#125;                // 定义 resolve 函数        const resolve = (value) =&gt; &#123;            console.log(&#x27;调用了 resolve，值为：&#x27;, value);        &#125;                // 定义 reject 函数        const reject = (reason) =&gt; &#123;            console.log(&#x27;调用了 reject，原因为：&#x27;, reason);        &#125;                // 立即执行 executor        executor(resolve, reject);    &#125;&#125;// 测试一下new MyPromise((resolve, reject) =&gt; &#123;    resolve(&#x27;成功啦！&#x27;);&#125;);

1.2 Promise 的三种状态 - 状态机 🚦Promise 就像一个有三种状态的交通灯：

🟡 pending（等待态）：初始状态，既不是成功，也不是失败
🟢 fulfilled（成功态）：操作成功完成
🔴 rejected（失败态）：操作失败

重要特性：

状态只能从 pending → fulfilled 或 pending → rejected
状态一旦改变，就永远不会再变（这就是为什么叫 “Promise” - 承诺）

让我们加上状态管理：
class MyPromise &#123;    constructor(executor) &#123;        // 初始状态为 pending        this.status = &#x27;pending&#x27;;        // 成功的值        this.value = undefined;        // 失败的原因        this.reason = undefined;                // resolve 函数：将状态从 pending 改为 fulfilled        const resolve = (value) =&gt; &#123;            // 只有在 pending 状态才能改变状态（保证状态只改变一次）            if (this.status === &#x27;pending&#x27;) &#123;                this.status = &#x27;fulfilled&#x27;;                this.value = value;            &#125;        &#125;                // reject 函数：将状态从 pending 改为 rejected        const reject = (reason) =&gt; &#123;            if (this.status === &#x27;pending&#x27;) &#123;                this.status = &#x27;rejected&#x27;;                this.reason = reason;            &#125;        &#125;                // 立即执行 executor，并传入 resolve 和 reject        try &#123;            executor(resolve, reject);        &#125; catch (error) &#123;            // 如果执行器抛出异常，Promise 应该被拒绝            reject(error);        &#125;    &#125;&#125;

二、实现 then 方法 - Promise 的灵魂 ✨2.1 then 方法的基本实现then 方法是 Promise 的核心，它用来注册当 Promise 状态改变时的回调函数。
class MyPromise &#123;    // ... 前面的代码    then(onFulfilled, onRejected) &#123;        // 如果状态是 fulfilled，执行成功回调        if (this.status === &#x27;fulfilled&#x27;) &#123;            onFulfilled(this.value);        &#125;                // 如果状态是 rejected，执行失败回调        if (this.status === &#x27;rejected&#x27;) &#123;            onRejected(this.reason);        &#125;    &#125;&#125;// 测试同步情况const promise = new MyPromise((resolve, reject) =&gt; &#123;    resolve(&#x27;成功！&#x27;);&#125;);promise.then(    value =&gt; console.log(&#x27;成功:&#x27;, value),    reason =&gt; console.log(&#x27;失败:&#x27;, reason));

2.2 处理异步情况 - 发布订阅模式 📢上面的代码有个问题：如果 executor 中有异步操作怎么办？
const promise = new MyPromise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;        resolve(&#x27;异步成功！&#x27;);    &#125;, 1000);&#125;);// 此时状态还是 pending，then 方法不会执行任何回调！promise.then(value =&gt; console.log(value));

解决方案：使用发布订阅模式，先把回调存起来，等状态改变时再执行：
class MyPromise &#123;    constructor(executor) &#123;        this.status = &#x27;pending&#x27;;        this.value = undefined;        this.reason = undefined;                // 存储成功回调的数组        this.onFulfilledCallbacks = [];        // 存储失败回调的数组        this.onRejectedCallbacks = [];                const resolve = (value) =&gt; &#123;            if (this.status === &#x27;pending&#x27;) &#123;                this.status = &#x27;fulfilled&#x27;;                this.value = value;                // 状态改变时，执行所有的成功回调                this.onFulfilledCallbacks.forEach(fn =&gt; fn());            &#125;        &#125;                const reject = (reason) =&gt; &#123;            if (this.status === &#x27;pending&#x27;) &#123;                this.status = &#x27;rejected&#x27;;                this.reason = reason;                // 状态改变时，执行所有的失败回调                this.onRejectedCallbacks.forEach(fn =&gt; fn());            &#125;        &#125;                try &#123;            executor(resolve, reject);        &#125; catch (error) &#123;            reject(error);        &#125;    &#125;        then(onFulfilled, onRejected) &#123;        if (this.status === &#x27;fulfilled&#x27;) &#123;            onFulfilled(this.value);        &#125;                if (this.status === &#x27;rejected&#x27;) &#123;            onRejected(this.reason);        &#125;                // 如果是 pending 状态，将回调存储起来        if (this.status === &#x27;pending&#x27;) &#123;            this.onFulfilledCallbacks.push(() =&gt; &#123;                onFulfilled(this.value);            &#125;);            this.onRejectedCallbacks.push(() =&gt; &#123;                onRejected(this.reason);            &#125;);        &#125;    &#125;&#125;

2.3 链式调用的实现 - then 返回 Promise 🔗Promise 最强大的特性之一就是链式调用。要实现链式调用，then 方法必须返回一个新的 Promise：
then(onFulfilled, onRejected) &#123;    // then 方法返回一个新的 Promise    return new MyPromise((resolve, reject) =&gt; &#123;        // 封装一个执行函数，统一处理成功和失败的情况        const fulfilledMicrotask = () =&gt; &#123;            // 使用 queueMicrotask 创建微任务，保证异步执行            queueMicrotask(() =&gt; &#123;                try &#123;                    const x = onFulfilled(this.value);                    // 处理返回值（详见下一节）                    resolvePromise(promise2, x, resolve, reject);                &#125; catch (error) &#123;                    reject(error);                &#125;            &#125;);        &#125;;                const rejectedMicrotask = () =&gt; &#123;            queueMicrotask(() =&gt; &#123;                try &#123;                    const x = onRejected(this.reason);                    resolvePromise(promise2, x, resolve, reject);                &#125; catch (error) &#123;                    reject(error);                &#125;            &#125;);        &#125;;                if (this.status === &#x27;fulfilled&#x27;) &#123;            fulfilledMicrotask();        &#125; else if (this.status === &#x27;rejected&#x27;) &#123;            rejectedMicrotask();        &#125; else if (this.status === &#x27;pending&#x27;) &#123;            this.onFulfilledCallbacks.push(fulfilledMicrotask);            this.onRejectedCallbacks.push(rejectedMicrotask);        &#125;    &#125;);&#125;

2.4 处理 then 的返回值 - resolvePromise 🎯这是实现 Promise 最复杂的部分，需要处理各种情况：
function resolvePromise(promise2, x, resolve, reject) &#123;    // 如果 x === promise2，会造成循环引用    if (x === promise2) &#123;        return reject(new TypeError(&#x27;Chaining cycle detected&#x27;));    &#125;        // 如果 x 是 Promise 实例    if (x instanceof MyPromise) &#123;        // 等待 x 的状态改变，然后递归处理        x.then(            value =&gt; resolvePromise(promise2, value, resolve, reject),            reason =&gt; reject(reason)        );        return;    &#125;        // 如果 x 是对象或函数（可能是 thenable）    if (x !== null &amp;&amp; (typeof x === &#x27;object&#x27; || typeof x === &#x27;function&#x27;)) &#123;        let then;        try &#123;            then = x.then;        &#125; catch (error) &#123;            return reject(error);        &#125;                // 如果 then 是函数，认为 x 是 thenable        if (typeof then === &#x27;function&#x27;) &#123;            let called = false; // 防止多次调用            try &#123;                then.call(                    x,                    value =&gt; &#123;                        if (called) return;                        called = true;                        resolvePromise(promise2, value, resolve, reject);                    &#125;,                    reason =&gt; &#123;                        if (called) return;                        called = true;                        reject(reason);                    &#125;                );            &#125; catch (error) &#123;                if (called) return;                reject(error);            &#125;        &#125; else &#123;            // 如果 then 不是函数，直接 resolve            resolve(x);        &#125;    &#125; else &#123;        // 如果 x 是普通值，直接 resolve        resolve(x);    &#125;&#125;

三、实现 Promise 的静态方法 🛠️3.1 Promise.resolve 和 Promise.rejectclass MyPromise &#123;    // 快速创建一个成功的 Promise    static resolve(value) &#123;        // 如果 value 已经是 Promise，直接返回        if (value instanceof MyPromise) &#123;            return value;        &#125;                return new MyPromise(resolve =&gt; resolve(value));    &#125;        // 快速创建一个失败的 Promise    static reject(reason) &#123;        return new MyPromise((resolve, reject) =&gt; reject(reason));    &#125;&#125;

3.2 Promise.all - 一个都不能少 🎯Promise.all 接收一个 Promise 数组，只有全部成功才成功，有一个失败就失败：
static all(promises) &#123;    return new MyPromise((resolve, reject) =&gt; &#123;        const results = [];        let completedCount = 0;                // 处理空数组的情况        if (promises.length === 0) &#123;            resolve(results);            return;        &#125;                promises.forEach((promise, index) =&gt; &#123;            // 将非 Promise 值转换为 Promise            MyPromise.resolve(promise).then(                value =&gt; &#123;                    results[index] = value;                    completedCount++;                                        // 所有 Promise 都成功了                    if (completedCount === promises.length) &#123;                        resolve(results);                    &#125;                &#125;,                reason =&gt; &#123;                    // 有一个失败就直接 reject                    reject(reason);                &#125;            );        &#125;);    &#125;);&#125;

3.3 Promise.race - 谁快用谁 🏃static race(promises) &#123;    return new MyPromise((resolve, reject) =&gt; &#123;        // 空数组永远 pending        if (promises.length === 0) return;                promises.forEach(promise =&gt; &#123;            // 谁先完成就用谁的结果            MyPromise.resolve(promise).then(resolve, reject);        &#125;);    &#125;);&#125;

3.4 Promise.allSettled - 等待所有结果 📊不管成功还是失败，等所有 Promise 都有结果：
static allSettled(promises) &#123;    return new MyPromise((resolve) =&gt; &#123;        const results = [];        let settledCount = 0;                if (promises.length === 0) &#123;            resolve(results);            return;        &#125;                promises.forEach((promise, index) =&gt; &#123;            MyPromise.resolve(promise).then(                value =&gt; &#123;                    results[index] = &#123; status: &#x27;fulfilled&#x27;, value &#125;;                    settledCount++;                    if (settledCount === promises.length) &#123;                        resolve(results);                    &#125;                &#125;,                reason =&gt; &#123;                    results[index] = &#123; status: &#x27;rejected&#x27;, reason &#125;;                    settledCount++;                    if (settledCount === promises.length) &#123;                        resolve(results);                    &#125;                &#125;            );        &#125;);    &#125;);&#125;

3.5 Promise.any - 一个成功就够了 ✅static any(promises) &#123;    return new MyPromise((resolve, reject) =&gt; &#123;        const errors = [];        let rejectedCount = 0;                if (promises.length === 0) &#123;            reject(new AggregateError([], &#x27;All promises were rejected&#x27;));            return;        &#125;                promises.forEach((promise, index) =&gt; &#123;            MyPromise.resolve(promise).then(                value =&gt; &#123;                    // 有一个成功就 resolve                    resolve(value);                &#125;,                reason =&gt; &#123;                    errors[index] = reason;                    rejectedCount++;                                        // 全部失败才 reject                    if (rejectedCount === promises.length) &#123;                        reject(new AggregateError(errors, &#x27;All promises were rejected&#x27;));                    &#125;                &#125;            );        &#125;);    &#125;);&#125;

四、实现 catch 和 finally 🎣4.1 catch - 错误处理catch(onRejected) &#123;    // catch 就是 then 的语法糖    return this.then(null, onRejected);&#125;

4.2 finally - 无论如何都要执行finally(callback) &#123;    return this.then(        // 成功时执行 callback，但传递原来的值        value =&gt; MyPromise.resolve(callback()).then(() =&gt; value),        // 失败时执行 callback，但传递原来的错误        reason =&gt; MyPromise.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)    );&#125;

五、async&#x2F;await 的实现原理 🔮5.1 理解 async&#x2F;awaitasync/await 本质上是 Generator + Promise 的语法糖。让我们看看它是如何工作的：
// async 函数async function fetchData() &#123;    const user = await getUser();    const posts = await getPosts(user.id);    return posts;&#125;// 等价于function fetchData() &#123;    return spawn(function* () &#123;        const user = yield getUser();        const posts = yield getPosts(user.id);        return posts;    &#125;);&#125;

5.2 实现自动执行器function spawn(genFunc) &#123;    return new Promise((resolve, reject) =&gt; &#123;        const gen = genFunc();                function step(nextFunc) &#123;            let next;            try &#123;                next = nextFunc();            &#125; catch (error) &#123;                return reject(error);            &#125;                        // Generator 函数执行完毕            if (next.done) &#123;                return resolve(next.value);            &#125;                        // 将 yield 的值包装成 Promise，然后递归执行            Promise.resolve(next.value).then(                value =&gt; step(() =&gt; gen.next(value)),                error =&gt; step(() =&gt; gen.throw(error))            );        &#125;                // 开始执行        step(() =&gt; gen.next());    &#125;);&#125;

5.3 一个更简单的实现function asyncToGenerator(generatorFunc) &#123;    return function (...args) &#123;        const gen = generatorFunc.apply(this, args);                return new Promise((resolve, reject) =&gt; &#123;            function step(key, arg) &#123;                let generatorResult;                                try &#123;                    generatorResult = gen[key](arg);                &#125; catch (error) &#123;                    return reject(error);                &#125;                                const &#123; value, done &#125; = generatorResult;                                if (done) &#123;                    return resolve(value);                &#125; else &#123;                    return Promise.resolve(value).then(                        val =&gt; step(&#x27;next&#x27;, val),                        err =&gt; step(&#x27;throw&#x27;, err)                    );                &#125;            &#125;                        step(&#x27;next&#x27;);        &#125;);    &#125;;&#125;// 使用示例const getData = asyncToGenerator(function* () &#123;    const data1 = yield fetch(&#x27;/api/1&#x27;);    const data2 = yield fetch(&#x27;/api/2&#x27;);    return [data1, data2];&#125;);getData().then(result =&gt; console.log(result));

🎯 面试高频考点总结
Promise 的状态机制：三种状态，只能单向改变，一旦改变不可逆
then 的链式调用：then 返回新的 Promise，根据回调函数的返回值决定新 Promise 的状态
微任务队列：Promise 的回调在微任务队列中执行
错误处理：catch 能捕获前面所有 then 中的错误
Promise.all vs Promise.race：一个要全部成功，一个要最快完成
async&#x2F;await 原理：Generator + 自动执行器 + Promise

模板渲染引擎&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;模板渲染示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;// 渲染引擎function renderTemplate(template, data) &#123;    // 处理条件判断    template = template.replace(/&#123;&#123;\s*#if\s*(\w+)\s*&#125;&#125;([\s\S]*?)&#123;&#123;\s*\/if\s*&#125;&#125;/g, function (_, condition, content) &#123;        return data[condition] ? content : &#x27;&#x27;;    &#125;);    // 处理循环    template = template.replace(/&#123;&#123;\s*#each\s*(\w+)\s*&#125;&#125;([\s\S]*?)&#123;&#123;\s*\/each\s*&#125;&#125;/g, function (_, arrayKey, content) &#123;        let result = &#x27;&#x27;;        let array = data[arrayKey];        if (Array.isArray(array)) &#123;            array.forEach((item, index) =&gt; &#123;                // 创建一个独立作用域，避免冲突                let temp = content;                // 替换模板内的 &#123;&#123; this &#125;&#125; 为循环项                temp = temp.replace(/&#123;&#123;\s*this\s*&#125;&#125;/g, function () &#123;                    return item;                &#125;);                // 如果是对象，处理它的属性                temp = temp.replace(/&#123;&#123;\s*this\.(\w+)\s*&#125;&#125;/g, function (_, prop) &#123;                    return item[prop] || &#x27;&#x27;;                &#125;);                // 替换循环索引（如果需要）                temp = temp.replace(/&#123;&#123;\s*index\s*&#125;&#125;/g, index);                // 将处理后的结果添加到最终结果中                result += temp;            &#125;);        &#125;        return result;    &#125;);    // 替换变量，一定要放到最后！！    template = template.replace(/\&#123;\&#123;(.*?)\&#125;\&#125;/g, (match, key) =&gt; &#123;        let keys = key.trim().split(&#x27;.&#x27;);        return keys.reduce((obj, k) =&gt; obj?.[k], data) || &#x27;&#x27;;    &#125;)    return template;&#125;// 定义数据const data = &#123;    name: &quot;张三&quot;,    age: 25,    isEmployed: true,    occupation: &quot;工程师&quot;,    hobbies: [&quot;阅读&quot;, &quot;编程&quot;, &quot;旅游&quot;],    friends: [        &#123; name: &quot;李四&quot;, age: 26 &#125;,        &#123; name: &quot;王五&quot;, age: 24 &#125;    ]&#125;;// 定义模板const template = `    &lt;h1&gt;个人信息&lt;/h1&gt;    &lt;p&gt;姓名: &#123;&#123; name &#125;&#125;&lt;/p&gt;    &lt;p&gt;年龄: &#123;&#123; age &#125;&#125;&lt;/p&gt;    &lt;p&gt;职业: &#123;&#123; occupation &#125;&#125;&lt;/p&gt;    &#123;&#123;#if isEmployed&#125;&#125;        &lt;p&gt;当前状态: 在职&lt;/p&gt;    &#123;&#123;/if&#125;&#125;    &lt;h2&gt;兴趣爱好&lt;/h2&gt;    &lt;ul&gt;        &#123;&#123;#each hobbies&#125;&#125;            &lt;li&gt;&#123;&#123; this &#125;&#125;&lt;/li&gt;        &#123;&#123;/each&#125;&#125;    &lt;/ul&gt;    &lt;h2&gt;朋友列表&lt;/h2&gt;    &lt;ul&gt;        &#123;&#123;#each friends&#125;&#125;            &lt;li&gt;&#123;&#123; this.name &#125;&#125; - &#123;&#123; this.age &#125;&#125; 岁&lt;/li&gt;        &#123;&#123;/each&#125;&#125;    &lt;/ul&gt;`;// 渲染模板并插入 HTMLdocument.getElementById(&#x27;app&#x27;).innerHTML = renderTemplate(template, data);

防抖截流const debounce = (fn, ms, Immediate = false) =&gt; &#123;    // Immediate选择是否立即执行    let timer = null;    return function (...thisArgs) &#123;        if (timer) &#123;            clearTimeout(timer)        &#125;        if (Immediate) &#123;            let flag = !timer            flag &amp;&amp; fn.apply(this, thisArgs)            timer = setTimeout(() =&gt; &#123;                timer = null            &#125;, ms)        &#125; else &#123;            timer = setTimeout(() =&gt; &#123;                fn.apply(this, thisArgs)                timer = null            &#125;, ms)        &#125;    &#125;&#125;const throttle = (fn, ms) =&gt; &#123;    let timer = null;    return function (...thisArgs) &#123;        if (!timer) &#123;            fn.apply(this, thisArgs);            timer = setTimeout(() =&gt; &#123;                timer = null;            &#125;, ms);        &#125;    &#125;&#125;

技巧数组去重let arr = [1, 0, 2, 3, 4, 5, 2, 3, 4];//indexOf去重function removeRepeat(arr) &#123;  let res = [];  for (let i of arr) &#123;    if (res.indexOf(i) == -1) &#123;      res.push(i);    &#125;  &#125;  return res;&#125;// set 去重function removeRepeat(arr) &#123;  let res = new Set(arr);  return Array.from(res);&#125;// for循环去重function removeRepeat(arr) &#123;  for (let i = 0; i &lt; arr.length; i++) &#123;    for (let j = i + 1; j &lt; arr.length; j++) &#123;      if (arr[i] == arr[j]) &#123;        arr.splice(j, 1);        j--;      &#125;    &#125;  &#125;  return arr;&#125;// filter 去重function removeRepeat(arr) &#123;  return arr.filter((item, index) =&gt; &#123;    return arr.indexOf(item) == index;  &#125;);&#125;// includes 去重function removeRepeat(arr) &#123;  let res = [];  for (let i of arr) &#123;    if (!res.includes(i)) &#123;      res.push(i);    &#125;  &#125;  return res;&#125;let res = removeRepeat(arr);console.log(res);

快排和归并Array.prototype.quicksort = function (l, r) &#123;    if (l &gt;= r) return this;    let key = this[l];    let i = l - 1, j = r + 1;    while (i &lt; j) &#123;        do i++; while (this[i] &lt; key);        do j--; while (this[j] &gt; key);        if (i &lt; j) [this[i], this[j]] = [this[j], this[i]];    &#125;    this.quicksort(l, j);    this.quicksort(j + 1, r);    return this;&#125;let arr = [5,8,3,6,4,2];console.log(arr.quicksort(0, arr.length-1));Array.prototype.mergesort = function (temp, l, r) &#123;    if (l &gt;= r) return this;    let mid = l + r &gt;&gt; 1;    this.mergesort(temp, l, mid);    this.mergesort(temp, mid + 1, r);    let i = l, j = mid + 1, k = 0;    while (i &lt;= mid &amp;&amp; j &lt;= r) &#123;        if (this[i] &lt;= this[j]) temp[k++] = this[i++];        else temp[k++] = this[j++];    &#125;    while (i &lt;= mid) temp[k++] = this[i++];    while (j &lt;= r) temp[k++] = this[j++];    for (let m = 0, n = l; n &lt;= r; m++, n++) &#123;        this[n] = temp[m];    &#125;    return this;&#125;let arr = [7, 1, 0, 3, 0, 5, 6, 4];console.log(arr.mergesort(Array(arr.length).fill(0), 0, arr.length - 1));

下划线和驼峰相互转换//方式一：操作字符串数组function transformStr2Hump1(str) &#123;    if(str == null) &#123;        return &quot;&quot;;    &#125;    var strArr = str.split(&#x27;-&#x27;);    for(var i = 1; i &lt; strArr.length; i++) &#123;        strArr[i] = strArr[i].charAt(0).toUpperCase() + strArr[i].substring(1);    &#125;    return strArr.join(&#x27;&#x27;);&#125;//方式二：操作字符数组function transformStr2Hump2(str) &#123;    if(str == null) &#123;        return &quot;&quot;;    &#125;    var strArr  =str.split(&#x27;&#x27;);    for(var i = 0; i &lt; strArr.length; i++) &#123;        if(strArr[i] == &quot;-&quot;)&#123;            //删除-            strArr.splice(i, 1);            //将该处改为大写            if(i &lt; strArr.length) &#123;                strArr[i] = strArr[i].toUpperCase();            &#125;        &#125;    &#125;    return strArr.join(&quot;&quot;);&#125;//方式三：利用正则function transformStr2Hump3(str) &#123;    if(str == null) &#123;        return &quot;&quot;;    &#125;    var reg = /-(\w)/g;//匹配字母或数字或下划线或汉字    return str.replace(reg, function($0, $1) &#123;        return $1.toUpperCase();    &#125;)&#125;

懒加载
首先，不要将图片地址放到src属性中，而是放到其它属性(data-original)中。
页面加载完成后，根据scrollTop判断图片是否在用户的视野内，如果在，则将data-original属性中的值取出存放到src属性中。
在滚动事件中重复判断图片是否进入视野，如果进入，则将data-original属性中的值取出存放到src属性中。


 elementNode.getAttribute(name)：方法通过名称获取属性的值。
 elementNode.setAttribute(name, value)：方法创建或改变某个新属性。
 elementNode.removeAttribute(name)：方法通过名称删除属性的值。

//懒加载代码实现var viewHeight = document.documentElement.clientHeight;//可视化区域的高度function lazyload () &#123;    //获取所有要进行懒加载的图片    let eles = document.querySelectorAll(&#x27;img[data-original][lazyload]&#x27;);//获取属性名中有data-original的    Array.prototype.forEach.call(eles, function(item, index) &#123;        let rect;        if(item.dataset.original === &#x27;&#x27;) &#123;            return;        &#125;        rect = item.getBoundingClientRect();        //图片一进入可视区，动态加载        if(rect.bottom &gt;= 0 &amp;&amp; rect.top &lt; viewHeight) &#123;            !function () &#123;                let img = new Image();                img.src = item.dataset.original;                img.onload = function () &#123;                    item.src = img.src;                &#125;                item.removeAttribute(&#x27;data-original&#x27;);                item.removeAttribute(&#x27;lazyload&#x27;);            &#125;();        &#125;    &#125;)&#125;lazyload();document.addEventListener(&#x27;scroll&#x27;, lazyload);

数组扁平化//传入参数 决定扁平化的阶数Array.prototype._flat = function (n) &#123;    let result = [];    let num = n;    for (let item of this) &#123;        // 如果是数组        if (Array.isArray(item)) &#123;            n--;            //   没有扁平化的空间 直接推入            if (n &lt; 0) &#123;                result.push(item);            &#125;            // 继续扁平化 并将n传入 决定item这一个数组中的扁平化            else &#123;                result.push(...item._flat(n));            &#125;        &#125;        // 不是数组直接推入        else &#123;            result.push(item);        &#125;        // 每次循环 重置n 为传入的参数 因为每一项都需要扁平化 需要进行判断        n = num;    &#125;    return result;&#125;;let arr = [1, 2, [3, 4], [5, 6, [7, 8]]];let res = arr._flat(1);console.log(res); // [ 1, 2, 3, 4, 5, 6, [ 7, 8 ] ]

计算属性请不要为所有函数添加缓存！
const computed = (func, content) =&gt; &#123;    let cache = Object.create(null);    content = content || this;    return (...key) =&gt; &#123;        console.log(cache)        if (!cache[key]) &#123;            cache[key] = func.apply(content, key);        &#125;        return cache[key];    &#125;&#125;

有并发限制的Promise调度器class Scheduler&#123;    constructor(limit)&#123;        this.limit = limit;        this.running = 0;        this.queue = [];    &#125;    createTask(callback, duration)&#123;        return ()=&gt;&#123;            return new Promise((resolve, reject)=&gt;&#123;                setTimeout(()=&gt;&#123;                    callback();                    resolve();                &#125;,duration);            &#125;);        &#125;;    &#125;        add(callback, duration)&#123;        const task = this.createTask(callback, duration);        this.queue.push(task);    &#125;        start()&#123;        for(let i=0;i&lt;this.limit;++i)&#123;            this.schedule();        &#125;    &#125;    schedule()&#123;        if(this.queue.length === 0 || this.running &gt;= this.limit)return;        this.running++;        const task = this.queue.shift();                task().then(()=&gt;&#123;            this.running--;            schedule();        &#125;);    &#125;&#125;

网络请求和跨域解决方案原生ajaxfunction sendajax() &#123;    // 1、 初始化xhr对象    const xhr = new XMLHttpRequest();    //  2、 建立连接 设置请求方法和url    xhr.open(&quot;get&quot;, &quot;./data.json&quot;);    //   3、发送请求    xhr.send();    //   4、状态改变时 进行回调    xhr.onreadystatechange = function () &#123;        // readyState 有0-4 五个值        // 0 代表 未初始化 1 代表 初始化成功 2 代表发送请求        // 3 代表返回了部分数据 4 代表返回了全部数据        if (xhr.readyState == 4) &#123;            if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123;                //   进行成功的操作                console.log(xhr.responseText);            &#125;        &#125;    &#125;;&#125;sendajax();

JSONP跨域首先在客户端注册一个callback，然后把callback的名字传给服务器。此时，服务器先生成json数据，然后以JavaScript的语法方式，生成function，function的名字就是传递上来带参数的jsonp，最后将json数据直接以入参的方式，放置在function中，这样子就生成JavaScript语法文档，返回给客户端。客户端浏览器，通过解析，并执行返回JavaScript文档，此时数据作为参数，传入到客户端预先定义好的callback函数中，简单地说，就是利用script标签没有跨域限制地漏洞来达到第三方通讯的目的（href、src 都不受同源策略的限制。）
优点：

它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制，JSONP可以跨越同源策略；
它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；

缺点:

它只支持GET请求而不支持POST等其它类型的HTTP请求
它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。
jsonp在调用失败的时候不会返回各种HTTP状态码。
需要后端配合

function jsonp(&#123;url,params,cb&#125;)&#123;        return new Promise((resolve, reject)=&gt;&#123;                window[cb] = function(data)&#123;                        console.log(data)                        resolve(data);                        document.body.removeChild(script);                &#125;//window对象上设置show方法                params= &#123;...params,cb&#125;                let arrs = [];                for (let key in params)&#123;                        arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`)                &#125;                let script = document.createElement(&#x27;script&#x27;);                script.src = `$&#123;url&#125;?$&#123;arrs.join(&#x27;&amp;&#x27;)&#125;`;                script.onerror = () =&gt; reject(&#x27;加载失败&#x27;)                 document.body.appendChild(script);                &#125;)&#125;jsonp(&#123;        url:&quot;http://localhost:3000/users&quot;,        params:&#123;name:&quot;jin&quot;,age:12&#125;,        cb:&#x27;show&#x27;&#125;).then(data=&gt;&#123;        console.log(data)&#125;)

后端：
let express = require(&#x27;express&#x27;);let app = express();app.get(&#x27;/users&#x27;, function(req, res, next) &#123;        // 模拟的数据        let &#123;name,age,cb&#125; = req.query        let data = `&quot;$&#123;name&#125;现在$&#123;age&#125;岁&quot;`        res.send(`$&#123;cb&#125;($&#123;data&#125;)`);// show(data)&#125;);app.listen(3000)

cors跨域同源策略是不允许接收响应而不是不允许发送请求，所以可以通过在响应头中设置某些字段来允许满足条件的请求跨域，比如设置 Access-Control-Allow-Origin 字段允许来自某个源的请求跨域，比如设置 Access-Control-Allow-Methods 字段允许’GET’或者’POST’方式的请求跨域
后端：
let express = require(&#x27;express&#x27;);let app = express();app.all(&#x27;*&#x27;, function (req, res, next) &#123;  let origin = req.headers.origin        //设置哪个源可以访问我  res.header(&quot;Access-Control-Allow-Origin&quot;,origin);        // 允许携带哪个头访问我  res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;name&quot;);        // 允许哪个方法访问我  res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;POST&quot;);        // 允许携带cookie  res.set(&quot;Access-Control-Allow-Credentials&quot;, true);        // 预检的存活时间  res.header(&quot;Access-Control-Max-Age&quot;, 6);        // 允许前端获取哪个头        res.header(&quot;Access-Control-Expose-Headers&quot;, &quot;name&quot;);        // 请求头的格式  res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);          next();&#125;);app.post(&#x27;/getData&#x27;, function(req, res, next) &#123;        console.log(req.headers)        res.send(&quot;你拿不到数据了！&quot;);&#125;);app.listen(4000)


非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。
非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。
浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 代码修改一下：
// 在请求头的设置中加上if(req.method ===&#x27;OPTIONS&#x27;)&#123;    res.end();//OPTIONS请求不做任何处理&#125;


postMessage跨域「window.postMessage()」 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 https），端口号（443 为 https 的默认值），以及主机 (两个页面的模数 [Document.domain]设置为相同的值) 时，这两个脚本才能相互通信。「window.postMessage()」 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。
用途
1.页面和其打开的新窗口的数据传递
2.多窗口之间消息传递
3.页面与嵌套的 iframe 消息传递
实现
a.html
&lt;iframe src=&quot;http://localhost:4000/b.html&quot; frameborder=&quot;0&quot; id=&quot;frame&quot; onload=&quot;load()&quot;&gt;&lt;/iframe&gt;&lt;script&gt;    function load()&#123;        let frame = document.getElementById(&#x27;frame&#x27;);        frame.contentWindow.postMessage(&#x27;你好&#x27;,&#x27;http://localhost:4000/&#x27;);        //接收        window.onmessage= function(e)&#123;            console.log(e.data)        &#125;    &#125;&lt;/script&gt;

b.html
window.onmessage = function(e)&#123;    console.log(e.data);    //发送    e.source.postMessage(&#x27;hello&#x27;,e.origin)&#125;

本地代理跨域proxy其实就是因为浏览器同源协议无法请求非同源的地址，但是服务器直接没有同源协议，利用将本地请求转到本地服务器进行代理转发，从而绕过了同源协议的限制，通过代理的实现可以解决跨域的问题
通过设置一个 node 后端作为中间层，前端发送的请求首先到达这个中间层，然后再由中间层将请求转发到目标服务器。响应过程也是如此，服务器先响应给中间层，中间层再将响应数据发送回前端。
这个中间层就起到了一个代理的作用。这样，浏览器看到的是同源请求，从而绕过了CORS限制。
假设前端现在要将请求发送给 http://192.168.1.63:3000 这个后端，就可以先由本机的 3001 端口作一个代理
&lt;!-- 前端 --&gt;&lt;body&gt;    &lt;script&gt;        const xhr = new XMLHttpRequest()        xhr.open(&#x27;GET&#x27;, &#x27;https://localhost:3001&#x27;)        xhr.send()        xhr.onreadystatechange = function() &#123;            if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123;                console.log(xhr.responseText)            &#125;        &#125;    &lt;/script&gt;&lt;/body&gt;

本机后端
// 后端const http = require(&#x27;http&#x27;)// 监听本机3001端口，有新请求时调用回调函数http.createServer((req, res)  =&gt; &#123;    // 设置响应头，以允许前端应用访问响应内容    res.writeHead(200, &#123;        &#x27;Access-Control-Allow-Origin&#x27;: &#x27;*&#x27;    &#125;)    // 转发请求到目标服务器，并处理响应    http.request(&#123;        host: &#x27;192.168.1.63&#x27;,        port: 3000,        path: &#x27;/&#x27;,        method: &#x27;GET&#x27;,        headers: &#123;&#125;    &#125;, proxyRes =&gt; &#123;        proxyRes.on(&#x27;data&#x27;, chunk =&gt; &#123;            res.end(chunk.toString())        &#125;)    &#125;).end()    &#125;).listen(3001)

各脚手架的proxy配置：Webpack (4.x)在webpack中可以配置proxy来快速获得接口代理的能力。
const path = require(&quot;path&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123;  entry: &#123;    index: &quot;./index.js&quot;  &#125;,  output: &#123;    filename: &quot;bundle.js&quot;,    path: path.resolve(__dirname, &quot;dist&quot;)  &#125;,  devServer: &#123;    port: 8000,    proxy: &#123;      &quot;/api&quot;: &#123;        target: &quot;http://localhost:8080&quot;      &#125;    &#125;  &#125;,  plugins: [    new HtmlWebpackPlugin(&#123;      filename: &quot;index.html&quot;,      template: &quot;webpack.html&quot;    &#125;)  ]&#125;;

Vue-cli 2.x// config/index.js...proxyTable: &#123;  &#x27;/api&#x27;: &#123;     target: &#x27;http://localhost:8080&#x27;,  &#125;&#125;,...

Vue-cli 3.x// vue.config.js 如果没有就新建module.exports = &#123;  devServer: &#123;    port: 8000,    proxy: &#123;      &quot;/api&quot;: &#123;        target: &quot;http://localhost:8080&quot;      &#125;    &#125;  &#125;&#125;;

viteimport &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import styleImport, &#123; VantResolve &#125; from &#x27;vite-plugin-style-import&#x27;;// https://vitejs.dev/config/export default defineConfig(&#123;  plugins: [    vue(),    styleImport(&#123;      resolves: [VantResolve()],    &#125;),],    server: &#123; //主要是加上这段代码      host: &#x27;127.0.0.1&#x27;,      port: 3000,      proxy: &#123;        &#x27;/api&#x27;: &#123;          target: &#x27;http://127.0.0.1:8888&#x27;,        //实际请求地址          changeOrigin: true,          rewrite: (path) =&gt; path.replace(/^\/api/, &#x27;&#x27;)        &#125;,      &#125;    &#125;&#125;)

nginx反向代理跨域反向代理与本地代理相反。本地代理是客户端搞定的，反向代理就是服务端搞定的
反向代理的是在服务端内部完成。
是服务端（数据应用）向服务端（网页应用）发送数据， 服务端向客户端发送数据 其本质是在服务端（网页应用）通过配置Access-Control-Allow-Origin * 来解决跨域问题。相当于对后端接口进行了统一的cors配置
Access-Control-Allow-Origin: * 值表明，该资源可以被任意外源访问。
    #通过配置nginx文件既可        events&#123;&#125;http&#123;    include       mime.types;    default_type  application/octet-stream;    server&#123;        listen 80;        server_name 127.0.0.1;        root D:/nginx-1.26.1/dist;        index index.html;        location / &#123;                  location /api &#123;                proxy_pass http://127.0.0.1:8080/;                proxy_set_header Host $host;                proxy_set_header X-Real-IP $remote_addr;                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;                proxy_set_header X-Forwarded-Proto $scheme;                # 解决跨域问题                add_header Access-Control-Allow-Origin *;                add_header Access-Control-Allow-Methods &quot;GET, POST, OPTIONS, HEAD, PUT, DELETE&quot;;                add_header Access-Control-Allow-Headers &quot;Origin, X-Requested-With, Content-Type, Accept, Authorization, User-Agent, DNT&quot;;                add_header Access-Control-Max-Age 86400;                            &#125;        &#125;    &#125;&#125;

设计模式单例模式// 单例模式示例代码class Singleton &#123;  constructor() &#123;    if (!Singleton.instance) &#123;      Singleton.instance = this;    &#125;    return Singleton.instance;  &#125;  createInstance() &#123;    const object = &#123; name: &quot;example&quot; &#125;;    return object;  &#125;  getInstance() &#123;    if (!Singleton.instance) &#123;      Singleton.instance = this.createInstance();    &#125;    return Singleton.instance;  &#125;&#125;// 使用示例const instance1 = new Singleton();const instance2 = new Singleton();console.log(instance1 === instance2); // true

工厂模式class Product &#123;  constructor(name) &#123;    this.name = name;  &#125;  getName() &#123;    return this.name;  &#125;&#125;class ProductFactory &#123;  static createProduct(name) &#123;    return new Product(name);  &#125;&#125;// 使用示例const product = ProductFactory.createProduct(&quot;Example Product&quot;);console.log(product.getName()); // &quot;Example Product&quot;

观察者模式class Subject &#123;  constructor() &#123;    this.observers = [];  &#125;  addObserver(observer) &#123;    this.observers.push(observer);  &#125;  removeObserver(observer) &#123;    const index = this.observers.indexOf(observer);    if (index !== -1) &#123;      this.observers.splice(index, 1);    &#125;  &#125;  notify(data) &#123;    this.observers.forEach(observer =&gt; observer.update(data));  &#125;&#125;class Observer &#123;  update(data) &#123;    console.log(`Received data: $&#123;data&#125;`);  &#125;&#125;// 使用示例const subject = new Subject();const observer1 = new Observer();const observer2 = new Observer();subject.addObserver(observer1);subject.addObserver(observer2);subject.notify(&quot;Hello World!&quot;);

装饰器模式interface Component &#123;  operation(): void;&#125;class ConcreteComponent implements Component &#123;  public operation(): void &#123;    console.log(&quot;ConcreteComponent: operation.&quot;);  &#125;&#125;class Decorator implements Component &#123;  protected component: Component;  constructor(component: Component) &#123;    this.component = component;  &#125;  public operation(): void &#123;    console.log(&quot;Decorator: operation.&quot;);    this.component.operation();  &#125;&#125;class ConcreteDecoratorA extends Decorator &#123;  public operation(): void &#123;    super.operation();    console.log(&quot;ConcreteDecoratorA: operation.&quot;);  &#125;&#125;class ConcreteDecoratorB extends Decorator &#123;  public operation(): void &#123;    super.operation();    console.log(&quot;ConcreteDecoratorB: operation.&quot;);  &#125;&#125;// 使用示例const concreteComponent = new ConcreteComponent();const concreteDecoratorA = new ConcreteDecoratorA(concreteComponent);const concreteDecoratorB = new ConcreteDecoratorB(concreteDecoratorA);concreteDecoratorB.operation();

代理模式const target = &#123;  method() &#123;    console.log(&quot;Target method.&quot;);  &#125;&#125;;const proxy = new Proxy(target, &#123;  get(target, prop) &#123;    console.log(`Called $&#123;prop&#125; method.`);    return target[prop];  &#125;&#125;);// 使用示例proxy.method(); // &quot;Called method method. Target method.&quot;

适配器模式class Adaptee &#123;  specificRequest() &#123;    return &quot;适配者中的业务代码被调用&quot;;  &#125;&#125;class Target &#123;  constructor() &#123;    this.adaptee = new Adaptee();  &#125;  request() &#123;    let info = this.adaptee.specificRequest();    return `$&#123;info&#125; - 转换器 - 适配器代码被调用`;  &#125;&#125;// 使用示例let target = new Target();target.request(); // &quot;适配者中的业务代码被调用 - 转换器 - 适配器代码被调用&quot;

MVC模式class Model &#123;  constructor() &#123;    this.data = &#123;      name: &quot;example&quot;,      age: 18,      gender: &quot;male&quot;    &#125;;  &#125;  setData(key, value) &#123;    this.data[key] = value;  &#125;  getData() &#123;    return this.data;  &#125;&#125;class View &#123;  constructor() &#123;    this.container = document.createElement(&quot;div&quot;);  &#125;  render(data) &#123;    const &#123; name, age, gender &#125; = data;    this.container.innerHTML = `      &lt;p&gt;Name: $&#123;name&#125;&lt;/p&gt;      &lt;p&gt;Age: $&#123;age&#125;&lt;/p&gt;      &lt;p&gt;Gender: $&#123;gender&#125;&lt;/p&gt;    `;    document.body.appendChild(this.container);  &#125;&#125;class Controller &#123;  constructor(model, view) &#123;    this.model = model;    this.view = view;    this.view.render(this.model.getData());  &#125;  setData(key, value) &#123;    this.model.setData(key, value);    this.view.render(this.model.getData());  &#125;&#125;// 使用示例const model = new Model();const view = new View();const controller = new Controller(model, view);controller.setData(&quot;age&quot;, 20);

策略模式表单验证情景：
// 验证策略const validationStrategies = &#123;  required: &#123;    validate: (value) =&gt; value !== &#x27;&#x27;,    message: &#x27;该字段不能为空&#x27;  &#125;,    minLength: &#123;    validate: (value, length) =&gt; value.length &gt;= length,    message: (length) =&gt; `最少需要$&#123;length&#125;个字符`  &#125;,    email: &#123;    validate: (value) =&gt; /^\S+@\S+\.\S+$/.test(value),    message: &#x27;请输入有效的邮箱地址&#x27;  &#125;,    phone: &#123;    validate: (value) =&gt; /^1[3-9]\d&#123;9&#125;$/.test(value),    message: &#x27;请输入有效的手机号&#x27;  &#125;,    custom: &#123;    validate: (value, validator) =&gt; validator(value),    message: &#x27;自定义验证失败&#x27;  &#125;&#125;;// 表单验证器class FormValidator &#123;  constructor() &#123;    this.rules = [];  &#125;    // 添加验证规则  addRule(field, strategy, ...params) &#123;    this.rules.push(&#123;      field,      strategy,      params    &#125;);  &#125;    // 执行验证  validate(formData) &#123;    const errors = [];        for (const rule of this.rules) &#123;      const &#123; field, strategy, params &#125; = rule;      const value = formData[field];      const validationStrategy = validationStrategies[strategy];            if (!validationStrategy.validate(value, ...params)) &#123;        errors.push(&#123;          field,          message: typeof validationStrategy.message === &#x27;function&#x27;             ? validationStrategy.message(...params)            : validationStrategy.message        &#125;);      &#125;    &#125;        return &#123;      isValid: errors.length === 0,      errors    &#125;;  &#125;&#125;// 使用示例const validator = new FormValidator();validator.addRule(&#x27;username&#x27;, &#x27;required&#x27;);validator.addRule(&#x27;username&#x27;, &#x27;minLength&#x27;, 3);validator.addRule(&#x27;email&#x27;, &#x27;required&#x27;);validator.addRule(&#x27;email&#x27;, &#x27;email&#x27;);validator.addRule(&#x27;phone&#x27;, &#x27;phone&#x27;);const formData = &#123;  username: &#x27;ab&#x27;,  email: &#x27;invalid-email&#x27;,  phone: &#x27;12345678901&#x27;&#125;;const result = validator.validate(formData);console.log(result);// &#123;//   isValid: false,//   errors: [//     &#123; field: &#x27;username&#x27;, message: &#x27;最少需要3个字符&#x27; &#125;,//     &#123; field: &#x27;email&#x27;, message: &#x27;请输入有效的邮箱地址&#x27; &#125;,//     &#123; field: &#x27;phone&#x27;, message: &#x27;请输入有效的手机号&#x27; &#125;//   ]// &#125;

]]></content>
      <categories>
        <category>秋招准备</category>
      </categories>
      <tags>
        <tag>秋招</tag>
        <tag>ES</tag>
        <tag>面试题</tag>
        <tag>前端手撕</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】详解魔鬼细节的二分查找</title>
    <url>/2025/08/25/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E8%AF%A6%E8%A7%A3%E9%AD%94%E9%AC%BC%E7%BB%86%E8%8A%82%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[前言：二分查找被誉为”最简单却最难写对”的算法——这个1946年首次发表的算法直到1962年才出现第一个完全正确的实现，连Java标准库都隐藏了9年的溢出bug。掌握二分查找不仅是算法基础，更是培养严谨编程思维的关键。本文将从理论到实践，从基础到进阶，带你彻底征服这个经典算法。
研究表明，90%的专业程序员在几小时内无法写出完全正确的二分查找。但别担心，通过系统学习其核心原理、边界处理技巧和常见陷阱，你将能够在面试和实际开发中游刃有余地运用这一强大工具。二分查找以其优雅的O(log n)时间复杂度，在大数据处理、数据库索引、系统优化等领域发挥着不可替代的作用。
算法核心原理与数学本质分治思想的完美体现二分查找基于分治策略的数学原理：每次将搜索空间分割为两个大小相等的子空间，通过比较中间元素来决定搜索方向。其本质是有序性利用——充分利用数据的有序特性进行智能决策，每次比较都能消除一半的搜索空间。
数学表达式为：mid = ⌊(i + j) / 2⌋，经过k次分割后，数组大小从N降至N/2^k = 1，这就是为什么时间复杂度为**O(log N)**的根本原因。
思维模型构建将二分查找理解为一个完美二叉决策树：

根节点：比较中间元素
左子树：处理较小元素的子数组
右子树：处理较大元素的子数组
树的高度：log N

这个决策树模型帮助我们理解为什么二分查找能达到理论最优的时间复杂度——从信息论角度，搜索n个元素需要log₂n位信息，每次比较提供1位信息。
复杂度分析详解时间复杂度：

最佳情况：O(1) - 目标恰好在中间位置
平均情况：O(log N) - 约需要log N次比较
最坏情况：O(log N) - 目标在首尾或不存在

空间复杂度：

迭代实现：O(1) - 只使用常数个变量
递归实现：O(log N) - 递归调用栈深度

边界处理的终极技巧循环条件选择策略二分查找有两种主流实现方式，选择正确的循环条件是关键：
方案一：闭区间 [left, right]（推荐）
def binary_search_closed(arr, target):    left, right = 0, len(arr) - 1  # 闭区间边界        while left &lt;= right:  # 闭区间条件        mid = left + (right - left) // 2                if arr[mid] == target:            return mid        elif arr[mid] &lt; target:            left = mid + 1    # 排除mid，向右搜索        else:            right = mid - 1   # 排除mid，向左搜索        return -1

方案二：左闭右开 [left, right)
def binary_search_half_open(arr, target):    left, right = 0, len(arr)  # 半开区间边界        while left &lt; right:  # 半开区间条件        mid = left + (right - left) // 2                if arr[mid] == target:            return mid        elif arr[mid] &lt; target:            left = mid + 1    # 排除mid        else:            right = mid       # 保留mid可能性        return -1 if left &gt;= len(arr) or arr[left] != target else left

实用记忆口诀区间选择口诀：”闭区间用小于等于，开区间只用小于号；闭区间边界要加减，开区间右边不用减”
防溢出口诀：”先减后除再加，溢出风险全拿下”
边界更新口诀：”基础查找找到就返，边界查找继续钻；找左边界向左挤，找右边界向右移”
边界处理的三种场景场景一：基础查找
# 找到目标就返回if arr[mid] == target:    return mid

场景二：左边界查找（第一个出现位置）
# 找到目标后继续向左搜索if arr[mid] == target:    right = mid - 1  # 关键：继续向左

场景三：右边界查找（最后一个出现位置）
# 找到目标后继续向右搜索if arr[mid] == target:    left = mid + 1   # 关键：继续向右

常见变体问题与解决模板五种核心变体类型1. 查找第一个出现位置
def find_first_occurrence(arr, target):    left, right = 0, len(arr) - 1    result = -1        while left &lt;= right:        mid = left + (right - left) // 2                if arr[mid] == target:            result = mid            right = mid - 1  # 继续在左半部分搜索        elif arr[mid] &lt; target:            left = mid + 1        else:            right = mid - 1        return result

2. 查找最后一个出现位置
def find_last_occurrence(arr, target):    left, right = 0, len(arr) - 1    result = -1        while left &lt;= right:        mid = left + (right - left) // 2                if arr[mid] == target:            result = mid            left = mid + 1   # 继续在右半部分搜索        elif arr[mid] &lt; target:            left = mid + 1        else:            right = mid - 1        return result

3. 查找插入位置（Lower Bound）
def bisect_left(arr, target):    left, right = 0, len(arr)        while left &lt; right:        mid = (left + right) // 2                if arr[mid] &lt; target:            left = mid + 1        else:            right = mid        return left

4. 旋转数组中的查找
def search_rotated(arr, target):    left, right = 0, len(arr) - 1        while left &lt;= right:        mid = (left + right) // 2                if arr[mid] == target:            return mid                    # 判断左半部分是否有序        if arr[left] &lt;= arr[mid]:              if arr[left] &lt;= target &lt; arr[mid]:                right = mid - 1            else:                left = mid + 1        else:  # 右半部分有序            if arr[mid] &lt; target &lt;= arr[right]:                left = mid + 1            else:                right = mid - 1        return -1

5. 万能模板（适用于复杂条件判断）
def binary_search_template(left, right, condition):    &quot;&quot;&quot;    通用二分查找模板    condition: 判断函数，返回True/False    &quot;&quot;&quot;    while left &lt; right:        mid = left + (right - left) // 2                if condition(mid):            right = mid      # 答案在[left, mid]        else:            left = mid + 1   # 答案在[mid+1, right]        return left  # left是满足条件的最小值

实现细节的核心技巧mid计算防溢出❌ 危险写法：
mid = (left + right) // 2  # 可能整数溢出

✅ 安全写法：
mid = left + (right - left) // 2  # 永远不会溢出

循环条件与边界更新的一致性


循环条件
初始化
边界更新
使用场景



left &lt;= right
right = len(arr) - 1
left = mid + 1, right = mid - 1
基础查找，直观易懂


left &lt; right
right = len(arr)
left = mid + 1, right = mid
边界查找，避免死循环


三种边界更新策略1. 排除式更新（基础查找）
if arr[mid] &lt; target:    left = mid + 1   # 排除mid及其左侧else:    right = mid - 1  # 排除mid及其右侧

2. 保留式更新（左边界查找）
if arr[mid] &gt;= target:    right = mid      # 保留mid可能性else:    left = mid + 1   # 排除mid及其左侧

3. 推进式更新（右边界查找）
if arr[mid] &lt;= target:    left = mid + 1   # 继续向右推进else:    right = mid - 1  # 向左收缩

应用场景与问题分类数值计算应用二分法求方程根
def bisection_method(func, a, b, epsilon=1e-6):    &quot;&quot;&quot;使用二分法求解方程 func(x) = 0 的根&quot;&quot;&quot;    while abs(b - a) &gt; epsilon:        mid = (a + b) / 2        if func(mid) == 0:            return mid        elif func(a) * func(mid) &lt; 0:            b = mid        else:            a = mid    return (a + b) / 2

计算数值的n次方根
def nth_root_binary_search(x, n, precision=1e-6):    if x &lt; 0 and n % 2 == 0:        return None        low = 0 if x &gt;= 1 else x    high = x if x &gt;= 1 else 1        while high - low &gt; precision:        mid = (low + high) / 2        mid_power = mid ** n                if abs(mid_power - x) &lt; precision:            return mid        elif mid_power &lt; x:            low = mid        else:            high = mid        return (low + high) / 2

二分答案问题识别特征：

问题要求”最大值的最小值”或”最小值的最大值”
给定一个值，能快速判断是否满足条件
答案空间具有单调性

经典模板
def binary_search_on_answer(check_function, low, high):    result = -1        while low &lt;= high:        mid = (low + high) // 2                if check_function(mid):            result = mid            high = mid - 1  # 寻找更小的满足条件的值        else:            low = mid + 1        return result

应用实例：分配问题
def min_eating_speed(piles, H):    &quot;&quot;&quot;香蕉分配问题：H小时内吃完所有香蕉的最小速度&quot;&quot;&quot;    def can_finish(speed):        time_needed = 0        for pile in piles:            time_needed += (pile + speed - 1) // speed        return time_needed &lt;= H        left, right = 1, max(piles)        while left &lt; right:        mid = left + (right - left) // 2                if can_finish(mid):            right = mid        else:            left = mid + 1        return left

实际工程应用数据库索引：B树和B+树的查找操作 版本控制：Git bisect定位问题提交 系统调试：参数调优和性能阈值查找 游戏开发：碰撞检测和空间划分 金融交易：期权定价中的数值计算
常见错误与调试秘籍四大经典陷阱陷阱一：整数溢出
# ❌ 错误：left + right 可能超过整数最大值mid = (left + right) // 2# ✅ 正确：使用防溢出公式mid = left + (right - left) // 2

陷阱二：无限循环
# ❌ 错误：当left=0, right=1时会死循环while left &lt; right:    mid = (left + right) // 2    if condition(mid):        right = mid    else:        left = mid  # 危险！永远是0# ✅ 正确：确保搜索空间缩小else:    left = mid + 1  # 关键：必须+1

陷阱三：边界检查遗漏
# ❌ 错误：没有验证返回值有效性return left# ✅ 正确：添加边界检查if left &gt;= len(arr) or arr[left] != target:    return -1return left

陷阱四：Off-by-One错误
# 确保初始化与循环条件匹配# 闭区间：right = len(arr) - 1, 条件：left &lt;= right# 开区间：right = len(arr), 条件：left &lt; right

FINDABLE测试法则使用这个口诀覆盖所有测试用例：

First&#x2F;Final: 目标在数组首尾
Identical: 包含重复元素
Non-existent: 目标不存在
Delete: 全部相同元素
Alone: 单个元素数组
Binary: 两个元素数组
Large: 大规模数组
Empty: 空数组

调试检查清单调试二分查找时，按以下顺序检查：

 循环条件与区间定义是否一致？
 mid计算是否使用防溢出公式？
 边界更新逻辑是否正确（+1&#x2F;-1）？
 返回值是否进行边界检查？
 是否测试了所有边界情况？

可视化调试技巧def visualize_binary_search(array, target):    left, right = 0, len(array) - 1    step = 0        print(f&quot;搜索 &#123;target&#125; 在数组 &#123;array&#125; 中&quot;)    print(&quot;-&quot; * 50)        while left &lt;= right:        step += 1        mid = left + (right - left) // 2                # 创建可视化表示        visual = &quot;&quot;        for i in range(len(array)):            if i == mid:                visual += f&quot;[&#123;array[i]&#125;]&quot;  # 当前中点            elif left &lt;= i &lt;= right:                visual += f&quot; &#123;array[i]&#125; &quot;   # 搜索范围内            else:                visual += f&quot;(&#123;array[i]&#125;)&quot;   # 已排除区域                print(f&quot;步骤 &#123;step&#125;: &#123;visual&#125;&quot;)        print(f&quot;       Left: &#123;left&#125;, Mid: &#123;mid&#125;, Right: &#123;right&#125;&quot;)        print(f&quot;       比较 &#123;array[mid]&#125; 与 &#123;target&#125;&quot;)                if array[mid] == target:            print(f&quot;       找到了！索引: &#123;mid&#125;&quot;)            return mid        elif array[mid] &lt; target:            print(f&quot;       &#123;array[mid]&#125; &lt; &#123;target&#125;, 搜索右半部分&quot;)            left = mid + 1        else:            print(f&quot;       &#123;array[mid]&#125; &gt; &#123;target&#125;, 搜索左半部分&quot;)            right = mid - 1        print()        print(&quot;未找到目标！&quot;)    return -1

通用思维框架二分查找解题四步法第一步：确定搜索空间

明确left和right的初始值
选择闭区间还是半开区间

第二步：设计循环条件

闭区间用left &lt;= right
半开区间用left &lt; right

第三步：实现判断逻辑

基础查找：找到就返回
边界查找：找到后继续搜索
条件查找：转化为True&#x2F;False判断

第四步：正确更新边界

确保每次都能缩小搜索空间
避免无限循环和边界错误

万能模板选择指南简单查找：使用闭区间模板
def simple_binary_search(arr, target):    left, right = 0, len(arr) - 1        while left &lt;= right:        mid = left + (right - left) // 2                if arr[mid] == target:            return mid        elif arr[mid] &lt; target:            left = mid + 1        else:            right = mid - 1        return -1

边界查找：使用统一边界模板
def find_boundary(arr, target, find_first=True):    left, right = 0, len(arr) - 1    result = -1        while left &lt;= right:        mid = left + (right - left) // 2                if arr[mid] == target:            result = mid            if find_first:                right = mid - 1            else:                left = mid + 1        elif arr[mid] &lt; target:            left = mid + 1        else:            right = mid - 1        return result

复杂条件：使用通用模板
def universal_binary_search(condition_func, low, high):    while low &lt; high:        mid = low + (high - low) // 2                if condition_func(mid):            high = mid        else:            low = mid + 1        return low

结论二分查找算法以其优雅的数学原理和卓越的时间效率，成为每个程序员必须掌握的核心算法。关键在于理解其分治思想本质，掌握边界处理技巧，并通过大量实践来培养直觉。
通过本文的系统学习，你已经掌握了：从理论基础到实践技巧，从基础实现到高级应用，从常见陷阱到调试方法的完整知识体系。记住最重要的原则：细节决定成败，二分查找的魅力正在于这些精妙的边界处理和实现技巧。
在实际应用中，始终遵循”理解胜过记忆”的原则，重点掌握搜索区间不变性的核心概念，选择一种实现风格并坚持使用，通过充分测试来确保代码的正确性。随着大数据时代的到来，二分查找在数据库索引、系统优化、机器学习等领域的价值将愈发凸显，熟练掌握这一算法将为你的编程生涯打下坚实的基础。
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
</search>
