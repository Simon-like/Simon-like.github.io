<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>React渲染时机完全指南：从一个电商组件的优化说起</title>
    <url>/2025/07/24/%E3%80%90%E4%BB%8E%E9%A1%B9%E7%9B%AE%E5%88%B0%E6%8A%80%E6%9C%AF%E3%80%91React%E6%B8%B2%E6%9F%93%E6%97%B6%E6%9C%BA%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[前言作为前端开发者，我们每天都在和 React 打交道，但你真的了解 React 的渲染时机吗？

为什么有时候获取 DOM 元素的高度是 0？
为什么设置的动画效果没有生效？
为什么页面会出现闪烁？
useEffect 和 useLayoutEffect 到底该用哪个？
requestAnimationFrame 在 React 中有什么用？

在这篇文章中，我将通过一个真实的电商项目案例去搞懂 React 的渲染时机。
一、从一个真实的电商场景说起1.1 业务背景在电商项目中，商品分类筛选是一个非常常见的功能。想象一下淘宝或京东的商品列表页，顶部通常会有这样的筛选器：
手机通讯 &gt; 手机 &gt; 华为 | 小米 | OPPO | vivo | 苹果 | 三星 | 荣耀 | realme | 一加 | 魅族...

当分类项特别多时，我们需要：

默认只显示 2 行，多余的折叠起来
提供展开&#x2F;收起按钮
支持平滑的展开&#x2F;收起动画
切换一级分类时，二级分类需要重置

1.2 组件效果演示

(gif效果太差了。。。。)
1.3 核心技术挑战看似简单的需求，实现起来却遇到了不少挑战：

高度计算问题：如何准确获取内容的完整高度？
动画流畅性：如何实现平滑的高度过渡动画？
状态切换问题：切换分类时如何避免不必要的动画？
响应式适配：如何在不同屏幕尺寸下保持良好体验？

这些问题的核心都指向一个关键点：我们需要在正确的时机执行正确的操作。
二、React 渲染机制深度解析2.1 React 的工作流程在深入代码之前，我们先来理解 React 的完整工作流程：
graph TB
    A[用户交互/Props变化] --> B[触发状态更新]
    B --> C[React 调度更新]
    C --> D[Render Phase渲染阶段]
    D --> E[Reconciliation协调过程]
    E --> F[生成 Fiber 树]
    F --> G[Commit Phase提交阶段]
    G --> H[更新 DOM]
    H --> I[执行 useLayoutEffect]
    I --> J[浏览器绘制]
    J --> K[执行 useEffect]
    K --> L[用户看到更新]
    
    style D fill:#f9f,stroke:#333,stroke-width:2px
    style G fill:#9ff,stroke:#333,stroke-width:2px
    style J fill:#ff9,stroke:#333,stroke-width:2px

2.2 三个关键阶段阶段一：Render Phase（渲染阶段）
特点：可中断、可恢复、可并发
任务：调用组件函数，生成新的虚拟 DOM 树
限制：不能执行副作用（side effects）

// 这个阶段执行的代码function MyComponent(&#123; data &#125;) &#123;  // ✅ 纯计算  const processedData = useMemo(() =&gt; processData(data), [data]);    // ❌ 不要在这里执行副作用  // document.title = &#x27;New Title&#x27;; // 错误！    return &lt;div&gt;&#123;processedData&#125;&lt;/div&gt;;&#125;

阶段二：Commit Phase（提交阶段）
特点：同步执行，不可中断
任务：将变更应用到真实 DOM
时机：useLayoutEffect 在此阶段执行

function MyComponent() &#123;  useLayoutEffect(() =&gt; &#123;    // 这里 DOM 已更新，但浏览器还未绘制    // 适合进行 DOM 测量或紧急的样式调整    const height = ref.current.scrollHeight;    console.log(&#x27;真实高度:&#x27;, height);  &#125;);&#125;

阶段三：Browser Paint（浏览器绘制）
特点：浏览器的工作，React 不参与
任务：计算布局、绘制像素
时机：useEffect 在此之后执行

2.3 时序对比图让我们通过一个详细的时序图来对比不同 Hook 的执行时机：
sequenceDiagram
    participant User as 用户
    participant React as React
    participant DOM as DOM
    participant Browser as 浏览器
    participant Effect as useEffect
    participant LayoutEffect as useLayoutEffect
    
    User->>React: 点击按钮
    React->>React: setState 更新状态
    
    rect rgb(255, 230, 230)
        Note over React: Render Phase 开始
        React->>React: 调用组件函数
        React->>React: 生成虚拟 DOM
        React->>React: Diff 算法对比
        Note over React: Render Phase 结束
    end
    
    rect rgb(230, 255, 230)
        Note over React,DOM: Commit Phase 开始
        React->>DOM: 更新真实 DOM
        DOM-->>React: DOM 更新完成
        React->>LayoutEffect: 同步执行 useLayoutEffect
        LayoutEffect-->>React: 执行完成
        Note over React,DOM: Commit Phase 结束
    end
    
    rect rgb(230, 230, 255)
        Note over Browser: Paint Phase 开始
        DOM->>Browser: 触发重排/重绘
        Browser->>Browser: 计算布局
        Browser->>Browser: 绘制像素
        Browser->>User: 显示更新后的界面
        Note over Browser: Paint Phase 结束
    end
    
    Browser->>Effect: 异步执行 useEffect
    Effect-->>React: 执行完成

三、代码实战：剖析折叠组件的实现现在让我们来看看实际的代码实现，我会逐步解析每个关键部分。
3.1 组件整体结构首先，让我们了解组件的整体结构：
// 主组件：SecondCategoryBoxconst SecondCategoryBox = (&#123;  categoryList,        // 分类数据  defaultCategoryIds,  // 默认选中项  maxVisibleRows,      // 最大可见行数  onCategoryChange     // 选中项变化回调&#125;) =&gt; &#123;  // 状态管理  const [activeIDList, setActiveIDList] = useState([]);    // 使用自定义 Hook 管理折叠逻辑  const &#123; containerRef, isExpanded, showToggleButton, setIsExpanded &#125; = useCollapse(&#123;    maxVisibleRows,    dependencies: [categoryList]  &#125;);    // 渲染逻辑...&#125;;

3.2 核心难点一：精确的高度计算这是整个组件最核心的部分。我们需要：

获取内容的完整高度（展开时的高度）
计算折叠时应该显示的高度
决定是否需要显示展开&#x2F;收起按钮

const calculateHeightsWithScale = useCallback(() =&gt; &#123;  if (!containerRef.current) return;    const container = containerRef.current;    // 步骤1：临时解除高度限制  const originalHeight = container.style.height;  const originalOverflow = container.style.overflow;    container.style.height = &#x27;auto&#x27;;  container.style.overflow = &#x27;visible&#x27;;    // 步骤2：测量真实高度  // 注意：这里必须等待浏览器完成布局计算  const fullHeight = container.scrollHeight;    // 步骤3：计算折叠高度  const visibleHeight = rowHeight * maxVisibleRows + gap * (maxVisibleRows - 1);    // 步骤4：恢复原始样式  container.style.height = originalHeight;  container.style.overflow = originalOverflow;    // 步骤5：更新状态  setHeights(&#123; full: fullHeight, visible: visibleHeight &#125;);  setShowToggleButton(fullHeight &gt; visibleHeight);&#125;, [maxVisibleRows, rowHeight, gap]);

关键问题：什么时候调用这个函数？
3.3 核心难点二：选择正确的执行时机这就涉及到我们要深入讨论的 React 渲染时机问题。让我们看看不同方案的对比：
方案一：使用 useEffect（❌ 会闪烁）useEffect(() =&gt; &#123;  calculateHeightsWithScale();&#125;, [categoryList]);

问题分析：
graph LR
    A[分类数据变化] --> B[组件重新渲染]
    B --> C[DOM 更新]
    C --> D[浏览器绘制]
    D --> E[用户看到错误高度]
    E --> F[useEffect 执行]
    F --> G[计算并设置正确高度]
    G --> H[再次渲染]
    H --> I[用户看到正确高度]
    
    style E fill:#ffcccc
    style I fill:#ccffcc

用户会先看到错误的高度，然后突然跳到正确高度——这就是”闪烁”！
方案二：使用 useLayoutEffect（⚠️ 可能阻塞渲染）useLayoutEffect(() =&gt; &#123;  calculateHeightsWithScale();&#125;, [categoryList]);

优点：在浏览器绘制前执行，避免闪烁 缺点：同步执行，可能阻塞渲染，影响性能
方案三：使用 requestAnimationFrame（✅ 最佳方案）useEffect(() =&gt; &#123;  requestAnimationFrame(() =&gt; &#123;    calculateHeightsWithScale();  &#125;);&#125;, [categoryList]);

为什么这是最佳方案？
graph TB
    A[useEffect 执行] --> B[注册 RAF 回调]
    B --> C[浏览器完成当前帧绘制]
    C --> D[布局信息已确定]
    D --> E[RAF 回调执行]
    E --> F[准确获取高度]
    F --> G[更新组件状态]
    
    style D fill:#ccffcc
    style F fill:#ccffcc

requestAnimationFrame 确保：

不阻塞当前的渲染
在下一帧开始前执行
此时布局计算已完成，可以准确获取尺寸

3.4 核心难点三：优雅地处理动画当用户切换一级分类时，我们需要重置二级分类，但不希望用户看到收起动画：
useEffect(() =&gt; &#123;  if (firstUpdate) &#123;    // 首次加载，使用默认选中项    setActiveIDList(defaultCategoryIds);    setFirstUpdate(false);  &#125; else &#123;    // 切换分类时的处理        // 步骤1：立即禁用 CSS 过渡    setEnableTransition(false);        // 步骤2：重置所有状态    setIsExpanded(false);    setActiveIDList([]);        // 步骤3：在下一帧恢复过渡效果    requestAnimationFrame(() =&gt; &#123;      setEnableTransition(true);    &#125;);  &#125;&#125;, [categoryList]);

时序分析：
sequenceDiagram
    participant User as 用户
    participant Component as 组件
    participant CSS as CSS动画
    participant Browser as 浏览器
    
    User->>Component: 切换一级分类
    Component->>Component: categoryList 变化
    Component->>CSS: 禁用 transition
    Component->>Component: 重置状态（高度变为折叠状态）
    Note over CSS: 无动画，瞬间变化
    Component->>Browser: 请求下一帧
    Browser-->>Component: 下一帧开始
    Component->>CSS: 启用 transition
    Note over CSS: 后续交互有动画

3.5 性能优化：响应式设计组件还实现了一个巧妙的响应式系统：
const calculateScale = useCallback(() =&gt; &#123;  const currentWidth = window.innerWidth;  const scale = currentWidth / baseWidth;    // 限制缩放范围，避免极端情况  const clampedScale = Math.max(0.8, Math.min(1.5, scale));    return &#123;    scale: clampedScale,    rowHeight: Math.round(baseRowHeight * clampedScale),    gap: Math.round(baseGap * clampedScale)  &#125;;&#125;, [baseWidth, baseRowHeight, baseGap]);

这确保了组件在不同设备上都有合适的显示效果。
四、深入理解 useEffect 和 useLayoutEffect4.1 本质区别// useEffect：在浏览器完成绘制后异步执行useEffect(() =&gt; &#123;  console.log(&#x27;1. DOM 已更新&#x27;);  console.log(&#x27;2. 浏览器已绘制&#x27;);  console.log(&#x27;3. 用户已看到变化&#x27;);  console.log(&#x27;4. 现在执行不会阻塞渲染&#x27;);&#125;);// useLayoutEffect：在浏览器绘制前同步执行useLayoutEffect(() =&gt; &#123;  console.log(&#x27;1. DOM 已更新&#x27;);  console.log(&#x27;2. 浏览器还未绘制&#x27;);  console.log(&#x27;3. 用户还看不到变化&#x27;);  console.log(&#x27;4. 可以在这里调整样式避免闪烁&#x27;);&#125;);

4.2 使用场景对比graph TB
    A[需要执行副作用] --> B{是否影响视觉呈现?}
    
    B -->|是| C{是否需要 DOM 测量?}
    B -->|否| D[使用 useEffect]
    
    C -->|是| E{测量是否紧急?}
    C -->|否| F[使用 useLayoutEffect]
    
    E -->|是| G[useLayoutEffect]
    E -->|否| H[useEffect + RAF]
    
    D --> I[数据获取事件订阅日志上报]
    F --> J[阻止闪烁同步滚动焦点管理]
    G --> K[关键布局计算动画初始状态]
    H --> L[非关键测量性能优化]
    
    style B fill:#ffffcc
    style C fill:#ffffcc
    style E fill:#ffffcc

4.3 实际案例对比让我们通过几个实际例子来加深理解：
案例1：工具提示定位function Tooltip(&#123; children, content &#125;) &#123;  const [position, setPosition] = useState(&#123; top: 0, left: 0 &#125;);  const triggerRef = useRef();  const tooltipRef = useRef();    // ✅ 使用 useLayoutEffect 避免工具提示闪烁  useLayoutEffect(() =&gt; &#123;    if (triggerRef.current &amp;&amp; tooltipRef.current) &#123;      const triggerRect = triggerRef.current.getBoundingClientRect();      const tooltipRect = tooltipRef.current.getBoundingClientRect();            setPosition(&#123;        top: triggerRect.top - tooltipRect.height - 8,        left: triggerRect.left + (triggerRect.width - tooltipRect.width) / 2      &#125;);    &#125;  &#125;, []);    return (    &lt;&gt;      &lt;span ref=&#123;triggerRef&#125;&gt;&#123;children&#125;&lt;/span&gt;      &lt;div         ref=&#123;tooltipRef&#125;        className=&quot;tooltip&quot;        style=&#123;&#123; position: &#x27;fixed&#x27;, ...position &#125;&#125;      &gt;        &#123;content&#125;      &lt;/div&gt;    &lt;/&gt;  );&#125;

案例2：滚动位置恢复function ScrollRestore(&#123; location &#125;) &#123;  // ✅ 使用 useLayoutEffect 立即恢复滚动位置  useLayoutEffect(() =&gt; &#123;    const savedPosition = sessionStorage.getItem(`scroll-$&#123;location&#125;`);    if (savedPosition) &#123;      window.scrollTo(0, parseInt(savedPosition));    &#125;  &#125;, [location]);    // ✅ 使用 useEffect 保存滚动位置（非紧急）  useEffect(() =&gt; &#123;    const handleScroll = () =&gt; &#123;      sessionStorage.setItem(`scroll-$&#123;location&#125;`, window.scrollY);    &#125;;        window.addEventListener(&#x27;scroll&#x27;, handleScroll);    return () =&gt; window.removeEventListener(&#x27;scroll&#x27;, handleScroll);  &#125;, [location]);&#125;

案例3：动画序列function AnimatedList(&#123; items &#125;) &#123;  const [visibleItems, setVisibleItems] = useState([]);    // ❌ 错误：在 useLayoutEffect 中做复杂计算  // useLayoutEffect(() =&gt; &#123;  //   items.forEach((item, index) =&gt; &#123;  //     setTimeout(() =&gt; &#123;  //       setVisibleItems(prev =&gt; [...prev, item]);  //     &#125;, index * 100);  //   &#125;);  // &#125;, [items]);    // ✅ 正确：使用 useEffect + RAF  useEffect(() =&gt; &#123;    let frameId;    let index = 0;        const animate = () =&gt; &#123;      if (index &lt; items.length) &#123;        setVisibleItems(prev =&gt; [...prev, items[index]]);        index++;        frameId = requestAnimationFrame(animate);      &#125;    &#125;;        frameId = requestAnimationFrame(animate);        return () =&gt; &#123;      if (frameId) &#123;        cancelAnimationFrame(frameId);      &#125;    &#125;;  &#125;, [items]);&#125;

五、requestAnimationFrame 的高级应用5.1 什么是 requestAnimationFrame？requestAnimationFrame（简称 RAF）是浏览器提供的一个 API，用于在下一次重绘之前执行动画。它的执行时机非常特殊：
graph LR
    A[帧开始] --> B[处理用户输入]
    B --> C[JS 执行]
    C --> D[RAF 回调]
    D --> E[样式计算]
    E --> F[布局]
    F --> G[绘制]
    G --> H[合成]
    H --> I[帧结束]
    
    style D fill:#ffcccc

5.2 在 React 中的应用场景场景1：确保布局完成后测量function useMeasure() &#123;  const ref = useRef();  const [bounds, setBounds] = useState(&#123;&#125;);    useEffect(() =&gt; &#123;    if (!ref.current) return;        // 确保在布局稳定后测量    const measure = () =&gt; &#123;      requestAnimationFrame(() =&gt; &#123;        if (ref.current) &#123;          setBounds(ref.current.getBoundingClientRect());        &#125;      &#125;);    &#125;;        measure();    window.addEventListener(&#x27;resize&#x27;, measure);        return () =&gt; window.removeEventListener(&#x27;resize&#x27;, measure);  &#125;, []);    return [ref, bounds];&#125;

场景2：批量 DOM 操作function batchDOMUpdates(updates) &#123;  requestAnimationFrame(() =&gt; &#123;    // 在一个帧内完成所有 DOM 操作    updates.forEach(update =&gt; update());        // 强制浏览器立即计算样式（如果需要读取）    // 注意：这会触发强制同步布局，谨慎使用    if (needsRead) &#123;      document.body.offsetHeight; // 强制重排    &#125;  &#125;);&#125;

场景3：平滑动画function useAnimation(duration = 300) &#123;  const [progress, setProgress] = useState(0);  const frameRef = useRef();  const startTimeRef = useRef();    const start = useCallback(() =&gt; &#123;    startTimeRef.current = performance.now();        const animate = (currentTime) =&gt; &#123;      const elapsed = currentTime - startTimeRef.current;      const progress = Math.min(elapsed / duration, 1);            setProgress(progress);            if (progress &lt; 1) &#123;        frameRef.current = requestAnimationFrame(animate);      &#125;    &#125;;        frameRef.current = requestAnimationFrame(animate);  &#125;, [duration]);    useEffect(() =&gt; &#123;    return () =&gt; &#123;      if (frameRef.current) &#123;        cancelAnimationFrame(frameRef.current);      &#125;    &#125;;  &#125;, []);    return [progress, start];&#125;

5.3 RAF vs setTimeout&#x2F;setInterval// ❌ 不推荐：可能导致掉帧或不流畅useEffect(() =&gt; &#123;  const timer = setInterval(() =&gt; &#123;    setPosition(prev =&gt; prev + 1);  &#125;, 16); // 约 60fps    return () =&gt; clearInterval(timer);&#125;, []);// ✅ 推荐：与浏览器刷新率同步useEffect(() =&gt; &#123;  let frameId;    const animate = () =&gt; &#123;    setPosition(prev =&gt; prev + 1);    frameId = requestAnimationFrame(animate);  &#125;;    frameId = requestAnimationFrame(animate);    return () =&gt; cancelAnimationFrame(frameId);&#125;, []);

六、常见问题与最佳实践6.1 常见错误及解决方案错误1：在渲染阶段读取 DOM// ❌ 错误function BadComponent() &#123;  const ref = useRef();  // 这里 ref.current 可能是 null  const height = ref.current?.offsetHeight || 0;    return &lt;div ref=&#123;ref&#125;&gt;Content&lt;/div&gt;;&#125;// ✅ 正确function GoodComponent() &#123;  const ref = useRef();  const [height, setHeight] = useState(0);    useEffect(() =&gt; &#123;    if (ref.current) &#123;      setHeight(ref.current.offsetHeight);    &#125;  &#125;, []);    return &lt;div ref=&#123;ref&#125;&gt;Content&lt;/div&gt;;&#125;

错误2：过度使用 useLayoutEffect// ❌ 错误：非视觉相关操作useLayoutEffect(() =&gt; &#123;  // 数据获取不应该阻塞渲染  fetch(&#x27;/api/data&#x27;).then(setData);&#125;, []);// ✅ 正确useEffect(() =&gt; &#123;  fetch(&#x27;/api/data&#x27;).then(setData);&#125;, []);

错误3：忽视清理函数// ❌ 错误：内存泄漏useEffect(() =&gt; &#123;  const timer = setInterval(() =&gt; &#123;    console.log(&#x27;tick&#x27;);  &#125;, 1000);  // 忘记清理！&#125;, []);// ✅ 正确useEffect(() =&gt; &#123;  const timer = setInterval(() =&gt; &#123;    console.log(&#x27;tick&#x27;);  &#125;, 1000);    return () =&gt; clearInterval(timer);&#125;, []);

6.2 性能优化建议1. 避免不必要的布局计算// ❌ 性能差：每次渲染都计算function BadComponent(&#123; items &#125;) &#123;  const heights = items.map(item =&gt; &#123;    const element = document.getElementById(item.id);    return element?.offsetHeight || 0;  &#125;);&#125;// ✅ 性能好：只在必要时计算function GoodComponent(&#123; items &#125;) &#123;  const [heights, setHeights] = useState([]);    useEffect(() =&gt; &#123;    requestAnimationFrame(() =&gt; &#123;      const newHeights = items.map(item =&gt; &#123;        const element = document.getElementById(item.id);        return element?.offsetHeight || 0;      &#125;);      setHeights(newHeights);    &#125;);  &#125;, [items]);&#125;

2. 批量更新 DOM// ✅ 批量读取和写入function BatchUpdate(&#123; items &#125;) &#123;  useLayoutEffect(() =&gt; &#123;    // 第一阶段：批量读取    const measurements = items.map(item =&gt; (&#123;      id: item.id,      height: document.getElementById(item.id)?.offsetHeight || 0    &#125;));        // 第二阶段：批量写入    measurements.forEach((&#123; id, height &#125;) =&gt; &#123;      const element = document.getElementById(id);      if (element) &#123;        element.style.transform = `translateY($&#123;height&#125;px)`;      &#125;    &#125;);  &#125;, [items]);&#125;

3. 使用 CSS 代替 JS 动画// ❌ JS 动画（性能较差）const [height, setHeight] = useState(0);useEffect(() =&gt; &#123;  let current = 0;  const timer = setInterval(() =&gt; &#123;    current += 5;    setHeight(current);    if (current &gt;= 100) clearInterval(timer);  &#125;, 16);&#125;, []);// ✅ CSS 动画（性能更好）const [expanded, setExpanded] = useState(false);return (  &lt;div     className=&#123;`container $&#123;expanded ? &#x27;expanded&#x27; : &#x27;&#x27;&#125;`&#125;    style=&#123;&#123;      transition: &#x27;height 0.3s ease-out&#x27;,      height: expanded ? &#x27;100px&#x27; : &#x27;0px&#x27;    &#125;&#125;  /&gt;);

6.3 调试技巧1. 可视化渲染时机function useRenderLog(name) &#123;  console.log(`$&#123;name&#125; rendering`);    useLayoutEffect(() =&gt; &#123;    console.log(`$&#123;name&#125; layout effect`);  &#125;);    useEffect(() =&gt; &#123;    console.log(`$&#123;name&#125; effect`);        requestAnimationFrame(() =&gt; &#123;      console.log(`$&#123;name&#125; next frame`);    &#125;);  &#125;);&#125;

2. 性能监控function usePerformanceMonitor(name) &#123;  const renderStart = performance.now();    useLayoutEffect(() =&gt; &#123;    const layoutEffectTime = performance.now();    console.log(`$&#123;name&#125; to layout effect: $&#123;layoutEffectTime - renderStart&#125;ms`);  &#125;);    useEffect(() =&gt; &#123;    const effectTime = performance.now();    console.log(`$&#123;name&#125; to effect: $&#123;effectTime - renderStart&#125;ms`);        requestAnimationFrame(() =&gt; &#123;      const frameTime = performance.now();      console.log(`$&#123;name&#125; to next frame: $&#123;frameTime - renderStart&#125;ms`);    &#125;);  &#125;);&#125;

七、React 18 并发特性与渲染时机7.1 并发渲染的影响React 18 引入的并发特性改变了一些渲染行为：
import &#123; startTransition, useDeferredValue, useId &#125; from &#x27;react&#x27;;function ConcurrentComponent(&#123; searchTerm, items &#125;) &#123;  // 延迟非紧急更新  const deferredSearchTerm = useDeferredValue(searchTerm);    // 标记低优先级更新  const handleExpensiveUpdate = () =&gt; &#123;    startTransition(() =&gt; &#123;      // 这个更新可以被中断      setExpensiveState(calculateExpensiveValue());    &#125;);  &#125;;    // 紧急更新仍然同步处理  const handleUrgentUpdate = () =&gt; &#123;    setUrgentState(value); // 立即响应  &#125;;&#125;

7.2 并发渲染下的 useEffect在并发模式下，组件可能会多次渲染但只提交一次：
graph TB
    A[开始渲染] --> B{高优先级更新?}
    B -->|是| C[中断当前渲染]
    B -->|否| D[继续渲染]
    C --> E[处理高优先级]
    E --> F[重新开始低优先级]
    D --> G[提交到 DOM]
    F --> D
    G --> H[执行 Effects]
    
    style C fill:#ffcccc
    style E fill:#ffcccc

7.3 实践建议function SearchResults(&#123; query &#125;) &#123;  const [results, setResults] = useState([]);  const [isSearching, setIsSearching] = useState(false);    // 使用 useDeferredValue 优化搜索体验  const deferredQuery = useDeferredValue(query);    // 紧急：显示加载状态  useEffect(() =&gt; &#123;    setIsSearching(query !== deferredQuery);  &#125;, [query, deferredQuery]);    // 非紧急：执行搜索  useEffect(() =&gt; &#123;    let cancelled = false;        async function doSearch() &#123;      const data = await searchAPI(deferredQuery);      if (!cancelled) &#123;        startTransition(() =&gt; &#123;          setResults(data);        &#125;);      &#125;    &#125;        doSearch();        return () =&gt; &#123;      cancelled = true;    &#125;;  &#125;, [deferredQuery]);    return (    &lt;div&gt;      &#123;isSearching &amp;&amp; &lt;Spinner /&gt;&#125;      &lt;ResultsList results=&#123;results&#125; /&gt;    &lt;/div&gt;  );&#125;

八、实战总结：回到我们的折叠组件现在，让我们用学到的知识重新审视最初的折叠组件，看看它是如何解决各种渲染时机问题的：
8.1 问题与解决方案对照


问题
解决方案
原理



获取准确的内容高度
useEffect + RAF
确保布局计算完成


切换分类时的动画闪烁
禁用&#x2F;启用 transition
精确控制 CSS 动画时机


响应式适配
动态计算缩放比例
避免频繁的 DOM 操作


首次加载的默认状态
firstUpdate 标记
区分初始化和更新


8.2 完整的渲染流程sequenceDiagram
    participant U as 用户
    participant C as 组件
    participant D as DOM
    participant B as 浏览器
    
    Note over U,B: 场景1：组件首次加载
    U->>C: 页面加载
    C->>C: 初始化状态
    C->>D: 渲染 DOM
    C->>C: useEffect 执行
    C->>B: RAF 注册回调
    B->>C: 下一帧执行测量
    C->>C: 设置正确高度
    C->>D: 更新 DOM
    B->>U: 显示完整内容
    
    Note over U,B: 场景2：用户点击展开
    U->>C: 点击展开按钮
    C->>C: setIsExpanded(true)
    C->>D: 更新高度样式
    Note over D,B: CSS transition 生效
    B->>U: 平滑展开动画
    
    Note over U,B: 场景3：切换分类
    U->>C: 选择新分类
    C->>C: 禁用 transition
    C->>C: 重置状态
    C->>D: 立即更新（无动画）
    C->>B: RAF 注册回调
    B->>C: 下一帧恢复 transition
    Note over C,B: 后续交互恢复动画

8.3 关键代码片段回顾// 1. 自定义 Hook 封装复杂逻辑export const useCollapse = (options) =&gt; &#123;  const &#123; maxVisibleRows = 2, dependencies = [] &#125; = options;  const containerRef = useRef();  const [isExpanded, setIsExpanded] = useState(false);  const [showToggleButton, setShowToggleButton] = useState(false);    // 2. 使用 RAF 确保准确测量  useEffect(() =&gt; &#123;    requestAnimationFrame(() =&gt; calculateHeightsWithScale());  &#125;, dependencies);    // 3. 返回必要的状态和引用  return &#123;    containerRef,    isExpanded,    showToggleButton,    setIsExpanded,    containerStyle: &#123;      height: !showToggleButton ? &#x27;auto&#x27; :               isExpanded ? heights.full : heights.visible,      overflow: &#x27;hidden&#x27;,      transition: &#x27;height 0.3s ease-in-out&#x27;    &#125;  &#125;;&#125;;

九、写在最后通过这个真实的电商项目案例，我们深入探讨了 React 的渲染时机问题。让我们再次总结一下核心要点：
9.1 核心原则
理解时机：知道代码在 React 生命周期的哪个阶段执行
选对工具：useEffect、useLayoutEffect、RAF 各有适用场景
避免闪烁：需要立即生效的视觉变化用 useLayoutEffect
性能优先：非紧急操作放在 useEffect 中异步执行
精确控制：使用 RAF 在正确的时机进行 DOM 测量

9.2 决策流程图graph TD
    A[需要副作用?] -->|是| B[影响视觉?]
    A -->|否| Z[纯组件逻辑]
    
    B -->|是| C[需要 DOM 测量?]
    B -->|否| D[useEffect]
    
    C -->|是| E[测量紧急?]
    C -->|否| F[useLayoutEffect]
    
    E -->|是| G[useLayoutEffect]
    E -->|否| H[useEffect + RAF]
    
    D --> I[异步操作数据获取事件订阅]
    F --> J[防止闪烁滚动恢复]
    G --> K[关键测量初始定位]
    H --> L[性能优化非关键测量]
    
    style A fill:#f9f,stroke:#333,stroke-width:4px
    style B fill:#bbf,stroke:#333,stroke-width:2px
    style C fill:#bbf,stroke:#333,stroke-width:2px
    style E fill:#bbf,stroke:#333,stroke-width:2px

9.3 从理论到实践理解 React 的渲染时机不仅仅是理论知识，更是解决实际问题的关键。当你遇到以下问题时，请想起这篇文章：

页面闪烁 → 检查是否应该使用 useLayoutEffect
获取的尺寸为 0 → 使用 RAF 确保布局完成
动画卡顿 → 考虑使用 CSS 动画或 RAF
性能问题 → 将非紧急操作移到 useEffect

十、参考资料
React 官方文档 - Hooks Reference
React 源码解析 - Fiber 架构
Web 性能优化 - requestAnimationFrame
React 18 Working Group
浏览器渲染原理


如果这篇文章对你有帮助，欢迎点赞、收藏和分享。有任何问题或不同见解，也欢迎在评论区讨论！
]]></content>
      <categories>
        <category>从项目到技术</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>项目案例</tag>
        <tag>性能优化</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>【概念解析】前端开发中的polypill</title>
    <url>/2025/07/22/%E3%80%90%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%9E%90%E3%80%91%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84Polyfill/</url>
    <content><![CDATA[什么是 Polyfill？Polyfill 是一段代码（通常是 JavaScript），用来为旧浏览器提供它没有原生支持的较新的功能。
名字的由来 🎨“Polyfill” 这个词来源于一种建筑材料 Polyfilla（一种用于填补墙面裂缝的腻子），形象地表示”填补浏览器功能的空缺”。
为什么需要 Polyfill？// 🌰 例子：旧浏览器不支持 Array.includesconst fruits = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;orange&#x27;];// 新浏览器可以直接使用console.log(fruits.includes(&#x27;banana&#x27;)); // true// 旧浏览器会报错：fruits.includes is not a function

常见的 Polyfill 示例1. Array.includes Polyfill// 检查是否已经存在if (!Array.prototype.includes) &#123;  Array.prototype.includes = function(searchElement, fromIndex) &#123;    // 严格模式    &#x27;use strict&#x27;;        const O = Object(this);    const len = parseInt(O.length) || 0;        if (len === 0) return false;        const n = parseInt(fromIndex) || 0;    let k = Math.max(n &gt;= 0 ? n : len + n, 0);        while (k &lt; len) &#123;      if (searchElement === O[k]) return true;      k++;    &#125;        return false;  &#125;;&#125;

2. Promise Polyfill// 简化版 Promise polyfillif (typeof Promise === &#x27;undefined&#x27;) &#123;  window.Promise = function(executor) &#123;    // Promise 实现代码...  &#125;;&#125;

3. Object.assign Polyfillif (!Object.assign) &#123;  Object.assign = function(target) &#123;    &#x27;use strict&#x27;;        if (target == null) &#123;      throw new TypeError(&#x27;Cannot convert undefined or null to object&#x27;);    &#125;        const output = Object(target);        for (let index = 1; index &lt; arguments.length; index++) &#123;      const source = arguments[index];      if (source != null) &#123;        for (const key in source) &#123;          if (Object.prototype.hasOwnProperty.call(source, key)) &#123;            output[key] = source[key];          &#125;        &#125;      &#125;    &#125;        return output;  &#125;;&#125;

4. String.padStart Polyfillif (!String.prototype.padStart) &#123;  String.prototype.padStart = function(targetLength, padString) &#123;    targetLength = targetLength &gt;&gt; 0; // 转为整数    padString = String(padString || &#x27; &#x27;);        if (this.length &gt;= targetLength) &#123;      return String(this);    &#125;        targetLength = targetLength - this.length;    if (targetLength &gt; padString.length) &#123;      padString += padString.repeat(targetLength / padString.length);    &#125;        return padString.slice(0, targetLength) + String(this);  &#125;;&#125;

Polyfill vs 其他概念1. Polyfill vs Transpile（转译）// Polyfill：运行时补充缺失的 APIArray.prototype.find = Array.prototype.find || function() &#123; /* ... */ &#125;;// Transpile：编译时转换语法（如 Babel）// ES6 箭头函数const add = (a, b) =&gt; a + b;// 转译后var add = function(a, b) &#123; return a + b; &#125;;

2. Polyfill vs Shim
Polyfill：实现标准 API，行为与规范一致
Shim：可能有自己的 API，不一定遵循标准

如何使用 Polyfill？1. 手动引入&lt;!-- 引入特定的 polyfill --&gt;&lt;script src=&quot;https://polyfill.io/v3/polyfill.min.js?features=Promise,Array.from&quot;&gt;&lt;/script&gt;

2. 使用 core-js// 安装npm install core-js// 使用import &#x27;core-js/features/array/includes&#x27;;import &#x27;core-js/features/promise&#x27;;

3. 使用 @babel&#x2F;polyfill（已废弃）// 新的推荐方式npm install core-js regenerator-runtime// babel.config.jsmodule.exports = &#123;  presets: [    [&#x27;@babel/preset-env&#x27;, &#123;      useBuiltIns: &#x27;usage&#x27;,      corejs: 3    &#125;]  ]&#125;;

最佳实践1. 按需加载// 只在需要时加载 polyfillif (!window.Promise) &#123;  // 动态加载 Promise polyfill  loadScript(&#x27;promise-polyfill.js&#x27;);&#125;

2. 使用 polyfill.io 服务&lt;!-- 根据用户浏览器自动返回需要的 polyfill --&gt;&lt;script src=&quot;https://polyfill.io/v3/polyfill.min.js&quot;&gt;&lt;/script&gt;

3. 特性检测// 使用特性检测而不是浏览器检测function loadPolyfills() &#123;  const polyfills = [];    if (!window.Promise) &#123;    polyfills.push(import(&#x27;promise-polyfill&#x27;));  &#125;    if (!Array.prototype.includes) &#123;    polyfills.push(import(&#x27;array-includes-polyfill&#x27;));  &#125;    return Promise.all(polyfills);&#125;// 加载完 polyfill 后再启动应用loadPolyfills().then(() =&gt; &#123;  // 启动应用  startApp();&#125;);

常用的 Polyfill 库
core-js - 最全面的 polyfill 库
polyfill.io - 自动化 polyfill 服务
es5-shim&#x2F;es6-shim - ES5&#x2F;ES6 polyfill
fetch-polyfill - Fetch API polyfill
intersection-observer - IntersectionObserver polyfill

注意事项 ⚠️
性能影响：Polyfill 会增加代码体积
选择性加载：只加载需要的 polyfill
版本兼容：确保 polyfill 支持目标浏览器
原生优先：优先使用原生实现

// 好的做法：先检测再添加if (!Array.prototype.flat) &#123;  // 添加 polyfill&#125;// 避免：直接覆盖Array.prototype.flat = function() &#123; /* ... */ &#125;;

总之，Polyfill 是前端开发中实现向后兼容的重要手段，让我们能够在旧浏览器中使用新特性！
]]></content>
      <categories>
        <category>前端知识小册</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
        <tag>概念解析</tag>
      </tags>
  </entry>
  <entry>
    <title>【建站日志】Simon成功搬家</title>
    <url>/2025/06/12/%E3%80%90%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97%E3%80%91Simon%E5%B7%B2%E7%9D%80%E9%99%86/</url>
    <content><![CDATA[之前用Wordpress建的网站突然炸了T_T，只好搬家到Hexo这边来，虽然之前就想换成ssg静态网站就是了。毕竟Wordpress博客系统上传文章太便秘了，完全用不惯他的文本编辑器，还是MD大法好啊！
]]></content>
      <tags>
        <tag>建站日志</tag>
        <tag>生活记录</tag>
      </tags>
  </entry>
  <entry>
    <title>【秋招备战】 Object.defineProperty vs Proxy</title>
    <url>/2025/08/07/%E3%80%90%E7%A7%8B%E6%8B%9B%E5%A4%87%E6%88%98%E3%80%91%E5%B1%9E%E6%80%A7%E5%8A%AB%E6%8C%81/</url>
    <content><![CDATA[
 如果你曾经好奇 Vue2 和 Vue3 的响应式原理有什么区别，或者在面试中被问到”如何实现数据劫持”时一脸懵逼，那么恭喜你，这篇文章就是你的救星！

📖 开篇：一个对象的自我修养在 JavaScript 的世界里，对象就像是一个个小盒子，我们可以往里面放东西（属性），也可以取东西。但是有一天，产品经理突然说：”我想知道用户什么时候打开盒子，什么时候往里面放东西！”
这时候，Object.defineProperty 和 Proxy 就闪亮登场了——它们就是对象世界的”监控摄像头”。
🎭 第一幕：Object.defineProperty - 老牌特工基本概念Object.defineProperty() 是 ES5 引入的方法，它可以精确地定义或修改对象的属性，并且可以控制属性的行为。就像给对象的某个属性装上了一个”智能锁”。
基础语法Object.defineProperty(obj, prop, descriptor)


obj：要定义属性的对象
prop：要定义或修改的属性名
descriptor：属性描述符对象

属性描述符的两种形态属性描述符分为两种：数据描述符和存取描述符（不能同时使用）。
1. 数据描述符const person = &#123;&#125;;Object.defineProperty(person, &#x27;name&#x27;, &#123;  value: &#x27;张三&#x27;,           // 属性值  writable: true,         // 是否可写（默认 false）  enumerable: true,       // 是否可枚举（默认 false）  configurable: true      // 是否可配置（默认 false）&#125;);console.log(person.name); // 张三person.name = &#x27;李四&#x27;;      // 因为 writable: true，所以可以修改console.log(person.name); // 李四

2. 存取描述符（重点！）这就是实现”数据劫持”的核心：
let internalValue = &#x27;我是内部值&#x27;;const obj = &#123;&#125;;Object.defineProperty(obj, &#x27;magicProp&#x27;, &#123;  enumerable: true,  configurable: true,  get() &#123;    console.log(&#x27;🔍 有人在读取 magicProp！&#x27;);    return internalValue;  &#125;,  set(newValue) &#123;    console.log(`✏️ 有人在设置 magicProp 为: $&#123;newValue&#125;`);    internalValue = newValue;  &#125;&#125;);obj.magicProp;           // 🔍 有人在读取 magicProp！obj.magicProp = &#x27;新值&#x27;;   // ✏️ 有人在设置 magicProp 为: 新值

实战案例：简易版 Vue2 响应式// 模拟 Vue2 的响应式原理function observe(obj) &#123;  Object.keys(obj).forEach(key =&gt; &#123;    let internalValue = obj[key];        Object.defineProperty(obj, key, &#123;      get() &#123;        console.log(`📊 收集依赖: $&#123;key&#125;`);        return internalValue;      &#125;,      set(newValue) &#123;        console.log(`🔄 触发更新: $&#123;key&#125; = $&#123;newValue&#125;`);        internalValue = newValue;        // 这里可以触发视图更新      &#125;    &#125;);  &#125;);&#125;const data = &#123; count: 0, message: &#x27;Hello&#x27; &#125;;observe(data);data.count;        // 📊 收集依赖: countdata.count = 1;    // 🔄 触发更新: count = 1

Object.defineProperty 的局限性
无法监听数组索引的变化

const arr = [1, 2, 3];observe(arr);arr[0] = 999;  // 无法触发 setterarr.push(4);   // 无法监听


必须遍历对象的每个属性

// 如果有嵌套对象，需要递归处理const complexObj = &#123;  user: &#123;    name: &#x27;张三&#x27;,    address: &#123;      city: &#x27;北京&#x27;    &#125;  &#125;&#125;;// 需要递归遍历所有层级


无法监听新增属性

const obj = &#123; a: 1 &#125;;observe(obj);obj.b = 2;  // 新增属性 b 不会被监听

🦸 第二幕：Proxy - 新时代的全能管家基本概念Proxy 是 ES6 引入的新特性，它可以创建一个对象的代理，从而实现对这个对象的基本操作的拦截和自定义。如果说 Object.defineProperty 是给属性装监控，那 Proxy 就是给整个对象配了一个全能管家。
基础语法const proxy = new Proxy(target, handler)


target：要代理的目标对象
handler：一个对象，定义了各种拦截行为

13 种拦截方法Proxy 支持拦截 13 种操作，常用的有：
const handler = &#123;  get(target, property, receiver) &#123;&#125;,      // 读取属性  set(target, property, value, receiver) &#123;&#125;, // 设置属性  has(target, property) &#123;&#125;,                // in 操作符  deleteProperty(target, property) &#123;&#125;,     // delete 操作  ownKeys(target) &#123;&#125;,                      // Object.keys()  // ... 还有其他拦截方法&#125;;

基础示例const person = &#123;  name: &#x27;张三&#x27;,  age: 25&#125;;const personProxy = new Proxy(person, &#123;  get(target, property) &#123;    console.log(`🔍 正在访问属性: $&#123;property&#125;`);    return target[property];  &#125;,  set(target, property, value) &#123;    console.log(`✏️ 正在设置属性: $&#123;property&#125; = $&#123;value&#125;`);    target[property] = value;    return true;  // 表示设置成功  &#125;&#125;);personProxy.name;           // 🔍 正在访问属性: namepersonProxy.age = 26;       // ✏️ 正在设置属性: age = 26personProxy.hobby = &#x27;编程&#x27;;  // ✏️ 正在设置属性: hobby = 编程（新属性也能监听！）

高级应用：数组的完美监听const arr = [1, 2, 3];const arrProxy = new Proxy(arr, &#123;  get(target, property) &#123;    console.log(`访问数组: arr[$&#123;property&#125;]`);    return target[property];  &#125;,  set(target, property, value) &#123;    console.log(`修改数组: arr[$&#123;property&#125;] = $&#123;value&#125;`);    target[property] = value;    return true;  &#125;&#125;);arrProxy[0] = 999;    // 修改数组: arr[0] = 999arrProxy.push(4);     // 访问数组: arr[push]                      // 访问数组: arr[length]                      // 修改数组: arr[3] = 4                      // 修改数组: arr[length] = 4

实战案例：实现一个智能对象// 创建一个&quot;智能&quot;对象，自动验证和转换数据const smartObj = new Proxy(&#123;&#125;, &#123;  set(target, property, value) &#123;    // 自动类型转换    if (property === &#x27;age&#x27;) &#123;      value = Number(value);      if (isNaN(value) || value &lt; 0 || value &gt; 150) &#123;        throw new Error(&#x27;年龄必须是 0-150 之间的数字&#x27;);      &#125;    &#125;        // 自动格式化    if (property === &#x27;phone&#x27;) &#123;      value = value.replace(/[^0-9]/g, &#x27;&#x27;);      if (value.length !== 11) &#123;        throw new Error(&#x27;手机号必须是 11 位&#x27;);      &#125;    &#125;        console.log(`✅ 设置 $&#123;property&#125; = $&#123;value&#125;`);    target[property] = value;    return true;  &#125;&#125;);smartObj.age = &#x27;25&#x27;;        // ✅ 设置 age = 25（自动转数字）smartObj.phone = &#x27;138-0000-0000&#x27;; // ✅ 设置 phone = 13800000000（自动格式化）// smartObj.age = &#x27;一百岁&#x27;;  // 抛出错误！

⚔️ 终极对决：Object.defineProperty vs Proxy


特性
Object.defineProperty
Proxy



兼容性
ES5，兼容 IE9+
ES6，不支持 IE


监听范围
单个属性
整个对象


监听数组索引
❌ 不支持
✅ 支持


监听新增属性
❌ 需要额外处理
✅ 自动支持


监听删除属性
❌ 不支持
✅ 支持


性能
需要递归遍历，初始化慢
懒处理，按需拦截


操作原对象
直接修改原对象
不修改原对象，返回代理


🎯 面试高频考点1. Vue2 vs Vue3 响应式原理// Vue2 风格（简化版）function reactive2(obj) &#123;  Object.keys(obj).forEach(key =&gt; &#123;    let value = obj[key];    Object.defineProperty(obj, key, &#123;      get() &#123;        // 依赖收集        return value;      &#125;,      set(newValue) &#123;        value = newValue;        // 触发更新      &#125;    &#125;);  &#125;);  return obj;&#125;// Vue3 风格（简化版）function reactive3(obj) &#123;  return new Proxy(obj, &#123;    get(target, key) &#123;      // 依赖收集      return target[key];    &#125;,    set(target, key, value) &#123;      target[key] = value;      // 触发更新      return true;    &#125;  &#125;);&#125;

2. 如何实现一个简单的观察者模式？class Observer &#123;  constructor(data) &#123;    this.data = data;    this.callbacks = &#123;&#125;;    this.observe();  &#125;    observe() &#123;    const that = this;    this.proxy = new Proxy(this.data, &#123;      set(target, property, value) &#123;        target[property] = value;        // 触发回调        if (that.callbacks[property]) &#123;          that.callbacks[property].forEach(cb =&gt; cb(value));        &#125;        return true;      &#125;    &#125;);    return this.proxy;  &#125;    subscribe(property, callback) &#123;    if (!this.callbacks[property]) &#123;      this.callbacks[property] = [];    &#125;    this.callbacks[property].push(callback);  &#125;&#125;// 使用const obs = new Observer(&#123; count: 0 &#125;);const data = obs.observe();obs.subscribe(&#x27;count&#x27;, (value) =&gt; &#123;  console.log(`count 变化了: $&#123;value&#125;`);&#125;);data.count = 1;  // count 变化了: 1

🚀 总结：选择的智慧
使用 Object.defineProperty 的场景：
需要兼容旧浏览器（IE9+）
只需要监听已知的、固定的属性
项目已经大量使用且稳定运行


使用 Proxy 的场景：
不需要考虑 IE 兼容性
需要监听数组变化
需要监听动态新增的属性
需要实现更复杂的拦截逻辑
新项目优先选择



💡 最后的小贴士记住这个口诀：

defineProperty 是保安：只能看着指定的几个门（属性）
Proxy 是管家：整个房子（对象）的事都管

面试时如果被问到，记得提到：

两者的本质区别（属性级 vs 对象级）
Vue2 到 Vue3 的升级原因
各自的优缺点和适用场景

现在，你已经掌握了 JavaScript 中两个最强大的”对象监控”技术。下次面试官问你”如何实现数据双向绑定”时，你可以自信地说：”这题我会，而且我还能告诉你两种方法的优缺点！”

Happy Coding! 愿你的秋招之路一帆风顺！ 🎉
]]></content>
      <categories>
        <category>秋招准备</category>
      </categories>
      <tags>
        <tag>秋招</tag>
        <tag>八股</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>【秋招备战】JavaScript 集合类型深度解析</title>
    <url>/2025/08/05/%E3%80%90%E7%A7%8B%E6%8B%9B%E5%A4%87%E6%88%98%E3%80%91JavaScript%20%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[在 JavaScript 的世界里，除了我们熟悉的对象（Object）和数组（Array），ES6 还引入了四种新的集合类型：Map、Set、WeakMap 和 WeakSet。这些数据结构不仅丰富了我们的工具箱，更是在现代前端框架的底层实现中扮演着重要角色。今天，让我们深入探讨这些集合类型的特性、使用场景，以及它们在 React 和 Vue 源码中的精妙应用。
一、Map：更强大的键值对集合基本概念Map 是一个键值对的集合，与普通对象最大的区别在于：Map 的键可以是任意类型，而不仅仅是字符串或 Symbol。
const map = new Map();// 基本用法map.set(&#x27;name&#x27;, &#x27;JavaScript&#x27;);map.set(42, &#x27;The Answer&#x27;);map.set(true, &#x27;Boolean key&#x27;);// 对象作为键const objKey = &#123; id: 1 &#125;;map.set(objKey, &#x27;Object as key&#x27;);// 函数作为键const funcKey = () =&gt; &#123;&#125;;map.set(funcKey, &#x27;Function as key&#x27;);console.log(map.get(objKey)); // &#x27;Object as key&#x27;console.log(map.size); // 5

Map 的核心特性
键的唯一性：Map 中的键是唯一的，重复设置会覆盖之前的值
保持插入顺序：Map 会记住键值对的插入顺序
可迭代：Map 实现了迭代器协议

const map = new Map([  [&#x27;first&#x27;, 1],  [&#x27;second&#x27;, 2],  [&#x27;third&#x27;, 3]]);// 遍历方法for (const [key, value] of map) &#123;  console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// 获取所有键console.log([...map.keys()]); // [&#x27;first&#x27;, &#x27;second&#x27;, &#x27;third&#x27;]// 获取所有值console.log([...map.values()]); // [1, 2, 3]// 获取所有键值对console.log([...map.entries()]); // [[&#x27;first&#x27;, 1], [&#x27;second&#x27;, 2], [&#x27;third&#x27;, 3]]

Map vs Object 的性能对比// 性能测试：频繁增删操作const testSize = 100000;// Object 测试console.time(&#x27;Object&#x27;);const obj = &#123;&#125;;for (let i = 0; i &lt; testSize; i++) &#123;  obj[`key$&#123;i&#125;`] = i;  delete obj[`key$&#123;i&#125;`];&#125;console.timeEnd(&#x27;Object&#x27;);// Map 测试console.time(&#x27;Map&#x27;);const map = new Map();for (let i = 0; i &lt; testSize; i++) &#123;  map.set(`key$&#123;i&#125;`, i);  map.delete(`key$&#123;i&#125;`);&#125;console.timeEnd(&#x27;Map&#x27;);// Object: 40.439ms// Map: 15.457ms// Map 在频繁增删操作时性能更优

实际应用场景// 缓存管理class LRUCache &#123;  constructor(capacity) &#123;    this.capacity = capacity;    this.cache = new Map();  &#125;  get(key) &#123;    if (!this.cache.has(key)) return -1;        // 将访问的元素移到最后（最新）    const value = this.cache.get(key);    this.cache.delete(key);    this.cache.set(key, value);    return value;  &#125;  put(key, value) &#123;    if (this.cache.has(key)) &#123;      this.cache.delete(key);    &#125;        this.cache.set(key, value);        // 超出容量，删除最旧的（第一个）    if (this.cache.size &gt; this.capacity) &#123;      const firstKey = this.cache.keys().next().value;      this.cache.delete(firstKey);    &#125;  &#125;&#125;

二、Set：独特值的集合基本概念Set 是一个值的集合，其中每个值都是唯一的，不会重复。
const set = new Set();// 添加值set.add(1);set.add(2);set.add(2); // 重复值不会被添加set.add(&#x27;2&#x27;); // 字符串&#x27;2&#x27;和数字2是不同的console.log(set.size); // 3console.log(set.has(2)); // true// 数组去重const numbers = [1, 2, 2, 3, 4, 4, 5];const uniqueNumbers = [...new Set(numbers)];console.log(uniqueNumbers); // [1, 2, 3, 4, 5]

Set 的高级应用// 1. 数组操作const setA = new Set([1, 2, 3, 4]);const setB = new Set([3, 4, 5, 6]);// 并集const union = new Set([...setA, ...setB]);console.log([...union]); // [1, 2, 3, 4, 5, 6]// 交集const intersection = new Set([...setA].filter(x =&gt; setB.has(x)));console.log([...intersection]); // [3, 4]// 差集const difference = new Set([...setA].filter(x =&gt; !setB.has(x)));console.log([...difference]); // [1, 2]// 2. 对象去重const users = [  &#123; id: 1, name: &#x27;Alice&#x27; &#125;,  &#123; id: 2, name: &#x27;Bob&#x27; &#125;,  &#123; id: 1, name: &#x27;Alice&#x27; &#125;,  &#123; id: 3, name: &#x27;Charlie&#x27; &#125;];const uniqueUsers = Array.from(  new Map(users.map(user =&gt; [user.id, user])).values());console.log(uniqueUsers); // 去重后的用户数组

性能优势// Set 的 has 方法性能测试const arr = Array.from(&#123; length: 10000 &#125;, (_, i) =&gt; i);const set = new Set(arr);console.time(&#x27;Array includes&#x27;);for (let i = 0; i &lt; 1000; i++) &#123;  arr.includes(9999);&#125;console.timeEnd(&#x27;Array includes&#x27;);console.time(&#x27;Set has&#x27;);for (let i = 0; i &lt; 1000; i++) &#123;  set.has(9999);&#125;console.timeEnd(&#x27;Set has&#x27;);// Set.has() 的时间复杂度是 O(1)，而 Array.includes() 是 O(n)

三、WeakMap：弱引用的键值对集合核心特性WeakMap 与 Map 类似，但有几个关键区别：

键必须是对象（不能是原始值）
键是弱引用的，不会阻止垃圾回收
不可迭代，没有 size 属性

const wm = new WeakMap();// 只能使用对象作为键const obj1 = &#123; name: &#x27;object1&#x27; &#125;;const obj2 = &#123; name: &#x27;object2&#x27; &#125;;wm.set(obj1, &#x27;value1&#x27;);wm.set(obj2, &#x27;value2&#x27;);console.log(wm.get(obj1)); // &#x27;value1&#x27;// 不能使用原始值作为键// wm.set(&#x27;string&#x27;, &#x27;value&#x27;); // TypeError// 弱引用特性let obj3 = &#123; name: &#x27;object3&#x27; &#125;;wm.set(obj3, &#x27;value3&#x27;);obj3 = null; // obj3 可以被垃圾回收，对应的 WeakMap 条目也会被清除

WeakMap 的实际应用// 1. 私有属性实现const privateData = new WeakMap();class Person &#123;  constructor(name, age) &#123;    privateData.set(this, &#123; name, age &#125;);  &#125;  getName() &#123;    return privateData.get(this).name;  &#125;  getAge() &#123;    return privateData.get(this).age;  &#125;&#125;const person = new Person(&#x27;Alice&#x27;, 30);console.log(person.getName()); // &#x27;Alice&#x27;console.log(person.name); // undefined// 2. DOM 元素关联数据const elementData = new WeakMap();function attachData(element, data) &#123;  elementData.set(element, data);&#125;function getData(element) &#123;  return elementData.get(element);&#125;// 使用const button = document.querySelector(&#x27;#myButton&#x27;);attachData(button, &#123; clickCount: 0 &#125;);button.addEventListener(&#x27;click&#x27;, () =&gt; &#123;  const data = getData(button);  data.clickCount++;  console.log(`Clicked $&#123;data.clickCount&#125; times`);&#125;);

内存管理优势// 使用 Map 可能造成内存泄漏const cache = new Map();function processData(obj) &#123;  if (cache.has(obj)) &#123;    return cache.get(obj);  &#125;    const result = expensiveOperation(obj);  cache.set(obj, result); // obj 被 Map 引用，无法被垃圾回收  return result;&#125;// 使用 WeakMap 避免内存泄漏const weakCache = new WeakMap();function processDataSafe(obj) &#123;  if (weakCache.has(obj)) &#123;    return weakCache.get(obj);  &#125;    const result = expensiveOperation(obj);  weakCache.set(obj, result); // obj 可以被正常垃圾回收  return result;&#125;

四、WeakSet：弱引用的值集合基本特性WeakSet 与 Set 类似，但具有以下特点：

只能存储对象
对象是弱引用的
不可迭代

const ws = new WeakSet();const obj1 = &#123; id: 1 &#125;;const obj2 = &#123; id: 2 &#125;;ws.add(obj1);ws.add(obj2);console.log(ws.has(obj1)); // true// 不能添加原始值// ws.add(1); // TypeError// 防止重复添加ws.add(obj1); // 不会报错，但也不会重复添加

实际应用场景// 1. 标记对象状态const disabledElements = new WeakSet();function disableElement(element) &#123;  disabledElements.add(element);  element.classList.add(&#x27;disabled&#x27;);&#125;function enableElement(element) &#123;  disabledElements.delete(element);  element.classList.remove(&#x27;disabled&#x27;);&#125;function isDisabled(element) &#123;  return disabledElements.has(element);&#125;// 2. 防止递归调用const processing = new WeakSet();function processObject(obj) &#123;  if (processing.has(obj)) &#123;    console.log(&#x27;Already processing this object&#x27;);    return;  &#125;    processing.add(obj);    try &#123;    // 处理对象    console.log(&#x27;Processing:&#x27;, obj);        // 如果对象有子对象，递归处理    if (obj.children) &#123;      obj.children.forEach(child =&gt; processObject(child));    &#125;  &#125; finally &#123;    processing.delete(obj);  &#125;&#125;

五、在 React 中的应用React Fiber 中的 WeakMap 使用React 的 Fiber 架构中使用 WeakMap 来存储组件相关的信息：
// React 源码简化示例const fiberNodeMap = new WeakMap();function createFiberNode(element) &#123;  const fiber = &#123;    type: element.type,    props: element.props,    // ... 其他 fiber 属性  &#125;;    // 将 DOM 元素与 Fiber 节点关联  if (element.dom) &#123;    fiberNodeMap.set(element.dom, fiber);  &#125;    return fiber;&#125;function getFiberFromDOM(domElement) &#123;  return fiberNodeMap.get(domElement);&#125;

React Hooks 中的 Map 应用// React Hooks 实现原理简化let currentComponent = null;const hooksMap = new Map();function useState(initialState) &#123;  const component = currentComponent;    if (!hooksMap.has(component)) &#123;    hooksMap.set(component, []);  &#125;    const hooks = hooksMap.get(component);  const hookIndex = hooks.length;    if (hooks[hookIndex] === undefined) &#123;    hooks[hookIndex] = &#123;      state: initialState,      setState: (newState) =&gt; &#123;        hooks[hookIndex].state = newState;        reRender(component);      &#125;    &#125;;  &#125;    return [hooks[hookIndex].state, hooks[hookIndex].setState];&#125;

六、在 Vue 中的应用Vue 3 响应式系统中的 WeakMapVue 3 的响应式系统大量使用了 WeakMap 来存储依赖关系：
// Vue 3 响应式原理简化const targetMap = new WeakMap();function track(target, key) &#123;  let depsMap = targetMap.get(target);  if (!depsMap) &#123;    targetMap.set(target, (depsMap = new Map()));  &#125;    let dep = depsMap.get(key);  if (!dep) &#123;    depsMap.set(key, (dep = new Set()));  &#125;    dep.add(activeEffect);&#125;function trigger(target, key) &#123;  const depsMap = targetMap.get(target);  if (!depsMap) return;    const dep = depsMap.get(key);  if (!dep) return;    dep.forEach(effect =&gt; effect());&#125;// 创建响应式对象function reactive(target) &#123;  return new Proxy(target, &#123;    get(target, key, receiver) &#123;      track(target, key);      return Reflect.get(target, key, receiver);    &#125;,    set(target, key, value, receiver) &#123;      const result = Reflect.set(target, key, value, receiver);      trigger(target, key);      return result;    &#125;  &#125;);&#125;

Vue 组件实例管理// Vue 组件实例缓存const instanceMap = new WeakMap();class VueComponent &#123;  constructor(options) &#123;    this.options = options;        // 将组件实例与其 DOM 元素关联    if (options.el) &#123;      instanceMap.set(options.el, this);    &#125;  &#125;    static getInstance(element) &#123;    return instanceMap.get(element);  &#125;&#125;// KeepAlive 组件的缓存实现const cache = new Map();const keys = new Set();function pruneCache(keepAliveInstance, filter) &#123;  cache.forEach((entry, key) =&gt; &#123;    const name = getComponentName(entry.componentInstance);    if (name &amp;&amp; !filter(name)) &#123;      pruneCacheEntry(key);    &#125;  &#125;);&#125;function pruneCacheEntry(key) &#123;  const cached = cache.get(key);  if (cached) &#123;    cached.componentInstance.$destroy();  &#125;  cache.delete(key);  keys.delete(key);&#125;

七、性能优化最佳实践选择合适的数据结构// 场景1：需要频繁检查元素是否存在// ❌ 不推荐：使用数组const permissions = [&#x27;read&#x27;, &#x27;write&#x27;, &#x27;delete&#x27;];if (permissions.includes(&#x27;write&#x27;)) &#123; &#125; // O(n)// ✅ 推荐：使用 Setconst permissionSet = new Set([&#x27;read&#x27;, &#x27;write&#x27;, &#x27;delete&#x27;]);if (permissionSet.has(&#x27;write&#x27;)) &#123; &#125; // O(1)// 场景2：需要关联 DOM 元素和数据// ❌ 不推荐：使用 Map（可能造成内存泄漏）const elementDataMap = new Map();// ✅ 推荐：使用 WeakMapconst elementDataWeakMap = new WeakMap();// 场景3：需要有序的键值对// ✅ Map 保持插入顺序const orderedMap = new Map([  [&#x27;first&#x27;, 1],  [&#x27;second&#x27;, 2],  [&#x27;third&#x27;, 3]]);

内存管理注意事项// 避免内存泄漏的模式class EventManager &#123;  constructor() &#123;    // 使用 WeakMap 存储事件监听器    this.listeners = new WeakMap();  &#125;    addEventListener(element, event, handler) &#123;    if (!this.listeners.has(element)) &#123;      this.listeners.set(element, new Map());    &#125;        const elementListeners = this.listeners.get(element);    if (!elementListeners.has(event)) &#123;      elementListeners.set(event, new Set());    &#125;        elementListeners.get(event).add(handler);    element.addEventListener(event, handler);  &#125;    removeEventListener(element, event, handler) &#123;    const elementListeners = this.listeners.get(element);    if (!elementListeners) return;        const eventHandlers = elementListeners.get(event);    if (!eventHandlers) return;        eventHandlers.delete(handler);    element.removeEventListener(event, handler);        // 清理空的集合    if (eventHandlers.size === 0) &#123;      elementListeners.delete(event);    &#125;    if (elementListeners.size === 0) &#123;      this.listeners.delete(element);    &#125;  &#125;&#125;

八、总结与建议何时使用 Map&#x2F;Set
Map：当你需要键值对集合，且键可能是对象或需要保持插入顺序时
Set：当你需要存储唯一值，或进行集合运算（并集、交集、差集）时

何时使用 WeakMap&#x2F;WeakSet
WeakMap：当你需要将数据与对象关联，且不想阻止对象被垃圾回收时
WeakSet：当你需要标记对象，或创建对象的弱引用集合时

性能考虑
查找性能：Map&#x2F;Set 的查找是 O(1)，而数组是 O(n)
内存管理：WeakMap&#x2F;WeakSet 有助于防止内存泄漏
迭代性能：Map&#x2F;Set 可以直接迭代，性能优于对象的 Object.keys()

这四种集合类型极大地丰富了 JavaScript 的数据结构选择，合理使用它们不仅能让代码更简洁、更具表现力，还能在性能和内存管理方面带来显著的提升。在现代前端框架的开发中，它们更是不可或缺的基础设施。
]]></content>
      <categories>
        <category>秋招准备</category>
      </categories>
      <tags>
        <tag>秋招</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>【秋招备战】计算机网络</title>
    <url>/2025/07/22/%E3%80%90%E7%A7%8B%E6%8B%9B%E5%A4%87%E6%88%98%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[前言计算机网络作为前端开发中绕不开的基础知识，面试时也特爱问，很多时候都有可能被打一个冷不防。这份文档旨在整理前端面试中高频出现的计算机网络知识点，希望能帮助到正在准备面试的你。
内容基于个人面试经验和学习总结，如有不当之处，欢迎指正交流。  本文不追求面面俱到，而是聚焦于前端面试中的高频考点，力求每个知识点都讲透彻、讲实用。
一、HTTP 协议篇1.1 HTTP 基础
HTTP 是什么？
HTTP 请求方法详解
HTTP 状态码分类及常见状态码
HTTP 报文结构

1.2 HTTP 缓存机制
强缓存 vs 协商缓存
Cache-Control 详解
ETag 和 Last-Modified
缓存位置（Memory Cache、Disk Cache等）

1.3 HTTP 版本演进
HTTP&#x2F;1.0 vs HTTP&#x2F;1.1
HTTP&#x2F;2 的优势（多路复用、服务器推送等）
HTTP&#x2F;3 和 QUIC 协议

1.4 HTTPS 安全通信
HTTP vs HTTPS
HTTPS 加密原理
证书验证过程
中间人攻击

二、TCP&#x2F;IP 协议篇2.1 TCP 基础
TCP 三次握手详解
TCP 四次挥手详解
为什么需要三次握手？两次行不行？
TIME_WAIT 状态的作用

2.2 TCP 可靠传输
序列号和确认应答
超时重传机制
流量控制（滑动窗口）
拥塞控制

2.3 TCP vs UDP
两者的区别对比
各自的应用场景
为什么视频直播常用 UDP？

三、浏览器网络篇3.1 跨域问题
同源策略是什么？
跨域的解决方案汇总
CORS 详解
JSONP 原理及限制
其他跨域方案

3.2 经典问题：从 URL 到页面展示
DNS 解析过程
建立 TCP 连接
发送 HTTP 请求
服务器处理请求
浏览器渲染页面

3.3 WebSocket
WebSocket vs HTTP
WebSocket 连接过程
应用场景

四、Web 安全篇4.1 XSS 攻击
XSS 类型（反射型、存储型、DOM型）
XSS 防御策略
CSP 内容安全策略

4.2 CSRF 攻击
CSRF 攻击原理
CSRF 防御方法
SameSite Cookie

4.3 其他安全问题
SQL 注入
点击劫持
中间人攻击

五、性能优化篇5.1 网络层优化
减少 HTTP 请求数
使用 HTTP&#x2F;2
启用 Gzip 压缩
使用 CDN

5.2 资源加载优化
预加载（preload、prefetch）
懒加载
图片优化策略

六、实战题目篇（收录各大公司真实面试题及详解）
]]></content>
      <categories>
        <category>秋招准备</category>
      </categories>
      <tags>
        <tag>秋招</tag>
        <tag>计算机网络</tag>
        <tag>面试八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>【秋招准备】面试手撕大集合</title>
    <url>/2025/07/22/%E3%80%90%E7%A7%8B%E6%8B%9B%E5%A4%87%E6%88%98%E3%80%91%E9%9D%A2%E8%AF%95%E6%89%8B%E6%92%95%E5%A4%A7%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[所有遍历数组的方法forEach// 自定义 forEach 函数，添加到 Array 原型链Array.prototype.myForEach = function (callback, thisArg) &#123;    // 类型检查：确保 callback 是一个函数    if (typeof callback !== &#x27;function&#x27;) &#123;        throw new TypeError(&#x27;第一个参数必须是一个函数&#x27;);    &#125;    // 遍历数组，调用 callback 函数    for (let i = 0; i &lt; this.length; i++) &#123;        // 如果数组的当前元素是 undefined 或 null, 则跳过        if (i in this) &#123;//对于数组而言，in运算符用于检查是否有这个索引值            callback.call(thisArg, this[i], i, this);        &#125;    &#125;&#125;;

map// 自定义 Map 函数，添加到 Array 原型链Array.prototype.myMap = function (callback) &#123;    // 类型检查：确保 callback 是一个函数    if (typeof callback !== &#x27;function&#x27;) &#123;        throw new TypeError(&#x27;第一个参数必须是一个函数&#x27;);    &#125;    let res = [];    // 遍历数组，调用 callback 函数    for (let i = 0; i &lt; this.length; i++) &#123;        // 如果数组的当前元素是 undefined 或 null, 则跳过        if (i in this) &#123;            res.push(callback(this[i], i, this));        &#125;    &#125;    return res&#125;;

FilterArray.prototype.my_filter = function (cb) &#123;    let newArr = []    for (var i = 0; i &lt; this.length; i++) &#123;        if (cb(this[i], i, this)) &#123;            newArr.push(this[i])        &#125;    &#125;    return newArr&#125;

every(判断数组中的每一个元素是否都满足某个条件)Array.prototype.my_every = function (cb) &#123;    for (let i = 0; i &lt; this.length; i++) &#123;        if (!cb(this[i], i, this)) &#123;            return false;        &#125;    &#125;    return true;&#125;

some（判断数组中是否存在一个元素满足某个条件）Array.prototype.my_some = function (cb) &#123;    for (let i = 0; i &lt; this.length; i++) &#123;        if (cb(this[i], i, this)) &#123;            return true;        &#125;    &#125;    return false;&#125;

reduceArray.prototype.my_reduce = function (cb, ...args) &#123;    let start, index = 0    if (args.length) &#123;        start = args[0]    &#125; else &#123;        start = this[0];        index = 1    &#125;    for (let i = index; i &lt; this.length; i++) &#123;        start = cb(start, this[i], i, this);    &#125;    return start;&#125;

includesArray.prototype.my_includes = function (item, ...args) &#123;    let index    if (args.length &amp;&amp; !Number.isNaN(Number(args[0])) &amp;&amp; Number(args[0])&gt;0) &#123;        index = Number(args[0])    &#125; else &#123;        index = 0;    &#125;    for (let i = index; i &lt; this.length; i++) &#123;        if (this[i] === item) return true;    &#125;    return false&#125;

spliceArray.prototype.mySplice = function (start, len, ...args) &#123;    let newArr = [], resArr = [];    if (arguments.length === 0) return resArr;    if (typeof len === &#x27;undefined&#x27;) &#123;        len = 0;    &#125;    if (typeof start === &#x27;undefined&#x27;) &#123;        start = 0;    &#125; else if (start &lt; 0) &#123;        start = start + this.length;        start = start &lt; 0 ? 0 : start;    &#125; else if (start &gt;= this.length) &#123;        start = this.length;    &#125;    for (let i = 0; i &lt; this.length; ++i) &#123;        if (i &lt; start || i &gt;= start + len) &#123;            newArr.push(this[i]);        &#125; else &#123;            resArr.push(this[i]);        &#125;        if (i === start || start + i === this.length * 2 - 1) &#123;            newArr.push(...args);        &#125;    &#125;    while (this.length) &#123;        this.pop();    &#125;    this.push(...newArr);    return resArr;&#125;

JS内置方法、对象以及运算符new运算符function myNew (Func, ...arg)&#123;        if (fn.prototype === undefined) throw new TypeError(&#x27;function is not a constructor&#x27;);        let obj = &#123;&#125;  //定义了一个对象。        obj.__proto__ = Func.prototype          //将Func.prototype赋值为对象的__proto__属性,即原型链的概念        let res = Func.call(obj, ...arg) //更改Func的this指向        return res instanceof Object ? res : obj &#125;

手撕curryconst my_curry = (fn, ...args) =&gt;    args.length &gt;= fn.length        ? fn(...args)        : (...args1) =&gt; my_curry(fn, ...args, ...args1);function adder(x, y, z) &#123;    return x + y + z;&#125;const add = my_curry(adder);console.log(add(1, 2, 3));  //6console.log(add(1)(2)(3));  //6console.log(add(1, 2)(3));  //6console.log(add(1)(2, 3));  //6

手写compose函数const compose = (...fns)=&gt;(x)=&gt;fns.reduceRight((v, fn)=&gt;fn(v),x);const doubleAndSuare = compose(double, square);//先翻倍再平方console.log(doubleAndSuare(3));

手撕vue3响应式代理//测试代码class Depend &#123;  constructor() &#123;    this.reactiveFns = new Set()//依赖组  &#125;  // 更好的收集依赖  depend() &#123;    if (activeReactiveFn) this.reactiveFns.add(activeReactiveFn)  &#125;  //对所有依赖进行统一通知处理  notify() &#123;    console.log(this.reactiveFns)    this.reactiveFns.forEach(fn =&gt; &#123;      //遍历依赖处理      if (fn) fn()    &#125;)  &#125;&#125;// 封装响应式函数let activeReactiveFn = nullfunction watchFn(fn) &#123;  activeReactiveFn = fn  fn()  activeReactiveFn = null&#125;// 封装一个获取depend函数const targetMap = new WeakMap()function getDepend(target, key) &#123;  // 1、根据target对象获取map的过程  let map = targetMap.get(target)  if (!map) &#123;    map = new Map()    targetMap.set(target, map)  &#125;  // 2、根据对象属性获取depend依赖  let depend = map.get(key)  if (!depend) &#123;    depend = new Depend()    map.set(key, depend)  &#125;  return depend&#125;//使用Proxy监听对象变化function reactive(obj) &#123;  return new Proxy(obj, &#123;    get: function (target, key, receiver) &#123;      const depend = getDepend(target, key)      depend.depend()      return Reflect.get(target, key, receiver)    &#125;,    set: function (target, key, newValue, receiver) &#123;      Reflect.set(target, key, newValue, receiver)      const depend = getDepend(target, key)      depend.notify()    &#125;  &#125;)&#125;const obj = &#123;  name: &quot;coderwhy&quot;,//depend实例对象  age: 18//depend实例对象&#125;const info = &#123;  name:&quot;小余&quot;,  age:18&#125;//响应式开关媒介const objRef = reactive(&#123;  name: &quot;coderwhy&quot;,  age: 18&#125;)const infoRef = reactive(&#123;  name:&quot;小余&quot;,  age:18&#125;)watchFn(() =&gt; &#123;  console.log(infoRef.name);  &#125;)watchFn(() =&gt; &#123;  console.log(objRef.name);  &#125;)infoRef.name = &#x27;响应式-小余&#x27;objRef.name = &#x27;响应式-coderwhy&#x27;// 小余// coderwhy// Set(1) &#123; [Function (anonymous)] &#125;// 响应式-小余// Set(1) &#123; [Function (anonymous)] &#125;// 响应式-coderwhy

手撕instanceofconst myInstanceOf=(Left,Right)=&gt;&#123;  if(!Left)&#123;    return false  &#125;  while(Left)&#123;    if(Left.__proto__===Right.prototype)&#123;      return true    &#125;else&#123;      Left=Left.__proto__    &#125;  &#125;  return false&#125;//验证console.log(myInstanceOf(&#123;&#125;,Array));  //false

call，bind，applyfunction foo(x,y)&#123;  console.log(this.a,x+y);&#125;const obj=&#123;  a:1&#125;Function.prototype.myCall=function(context,...args)&#123;  if(typeof this !== &#x27;function&#x27;)  return new TypeError(&#x27;is not a function&#x27;)  const fn = Symbol(&#x27;fn&#x27;) //使用Symbol尽可能降低myCall对其他的影响  context[fn] = this  //this指向foo  const res = context[fn](...args)  //解构，调用fn  delete context[fn]  //不要忘了删除obj上的工具函数fn  return res  //将结果返回&#125;//验证foo.myCall(obj,1,2)   //1,3function foo(x,y)&#123;  console.log(this.a,x+y);&#125;const obj=&#123;  a:1&#125;Function.prototype.myApply=function(context,args)&#123;  if(typeof this !== &#x27;function&#x27;)  return new TypeError(&#x27;is not a function&#x27;)  const fn = Symbol(&#x27;fn&#x27;) //使用Symbol尽可能降低myCall对其他的影响  context[fn] = this  //this指向foo  const res = context[fn](...args)  //解构，调用fn  delete context[fn]  //不要忘了删除obj上的工具函数fn  return res  //将结果返回&#125;//验证foo.myApply(obj,1,2)   //1,3function foo(x,y,z)&#123;  this.name=&#x27;zt&#x27;  console.log(this.a,x+y+z);&#125;const obj=&#123;  a:1&#125;Function.prototype.myBind=function(context,...args)&#123;  if(typeof this !== &#x27;function&#x27;)  return new TypeError(&#x27;It is not a function&#x27;);  context = context || window; // 上下文环境  const _this = this; // 当前的函数的上下文this  return function F(...arg) &#123;    //判断返回出去的F有没有被new，有就要把foo给到new出来的对象    if (this instanceof F) &#123;       return new _this(...args, ...arg);    &#125; else &#123;       _this.call(this, ...args, ...arg);    &#125;  &#125;&#125;//验证const bar=foo.myBind(obj,1,2)console.log(new bar(3));   //undefined 6  foo &#123; name: &#x27;zt&#x27; &#125;

值相等function compare(data1, data2) &#123;  if (typeof data1 != typeof data2) &#123;    return false;  &#125;  if (typeof data1 != &quot;object&quot; &amp;&amp; typeof data1 == typeof data2) &#123;    return data1 === data2;  &#125;  if ((!data1 instanceof Array &amp;&amp; data2 instanceof Array) || (data1 instanceof Array &amp;&amp; !data2 instanceof Array)) &#123;    return false;  &#125; else if (data1 instanceof Array  &amp;&amp; data2 instanceof Array) &#123;    if (data1.length == data2.length) &#123;      for (let i = 0; i &lt; data1.length; i++) &#123;        if (!compare(data1[i], data2[i])) &#123;          return false;        &#125;      &#125;    &#125; else &#123;      return false;    &#125;  &#125; else &#123;      if (Object.keys(data1).length == Object.keys(data2).length) &#123;      for (let key in data1) &#123;        if (!data2[key] || !compare(data1[key], data2[key])) &#123;          return false;        &#125;      &#125;    &#125; else &#123;      return false;    &#125;  &#125;  return true;&#125;

深拷贝function isObject(value) &#123;  const valueType = typeof value  return (value !== null) &amp;&amp; (valueType === &quot;object&quot; || valueType === &quot;function&quot;)&#125;function deepClone(originValue) &#123;  // 判断传入的originValue是否是一个对象类型  if (!isObject(originValue)) &#123;    return originValue  &#125;  const newObject = &#123;&#125;  for (const key in originValue) &#123;    newObject[key] = deepClone(originValue[key])  &#125;  //返回通过递归深层遍历赋值后，全新的数据对象  return newObject&#125;

实现Object.create()创建一个空对象，定义其原型对象并设置其枚举属性
// proto 可以是object 或者functionObject.myCreate = function (proto, defineProperties)&#123;    if((typeof proto === &#x27;object&#x27; &amp;&amp; proto !== null) || typeof proto === &#x27;function&#x27;)&#123;        let obj = &#123;&#125;;        // obj.__proto__ = proto;        Object.setPrototypeOf(obj, proto);        Object.defineProperty(obj, defineProperties);        return obj;    &#125;else &#123;        throw new TypeError(&#x27;类型错误&#x27;);    &#125;&#125;

实现Object.assign（浅拷贝）function myAssign(target,...objs)&#123;    if(target === null || target === undefined)&#123;        throw new TypeError(&quot;can not convert null or undefined to object&quot;)    &#125;    let res = Object(target)    objs.forEach(obj =&gt; &#123;        &#x27;use strict&#x27;        if(obj != null &amp;&amp; obj != undefined)&#123;            for(let key in obj)&#123;                //hasOwnProperty用来判断一个属性是定义在对象本身而不是继承自原型链的                if(Object.prototype.hasOwnProperty.call(obj,key))&#123;                    res[key] = obj[key]                &#125;            &#125;        &#125;    &#125;)    return res&#125;Object.defineProperty(Object,&#x27;myAssign&#x27;,&#123;    value: myAssign,    writable: true,    configurable: true,    enumerable: false&#125;)

trim方法function myTrim(str) &#123;  const reg = /^\s+|\s+$/g;  return str.replace(reg, &#x27;&#x27;);&#125;

模板字符串const render = (template, data) =&gt; &#123;    const reg = /\$\&#123;(.*?)\&#125;/g;    template = template.replace(reg, (match, key) =&gt; &#123;        let keys = key.trim().split(&#x27;.&#x27;);        return keys.reduce((obj, k) =&gt; obj?.[k], data) || &#x27;&#x27;;    &#125;)    return template;&#125;

sleep函数function sleep(ms) &#123;    return new Promise((resolve) =&gt; &#123;        setTimeout(() =&gt; &#123;            console.log(&#x27;sleep...&#x27;)            resolve()        &#125;, ms);    &#125;)&#125;async function test()&#123;    console.log(&#x27;1&#x27;);    await sleep(400)    console.log(&#x27;2&#x27;)&#125;test();

利用setTimeout实现setIntervalfunction coustomSetInterval(callback, time) &#123;    let intervalId = null;    function loop() &#123;        intervalId = setTimeout(() =&gt; &#123;            callback();            loop();        &#125;, time)    &#125;    loop();    return () =&gt; clearTimeout(intervalId)&#125;const interval = coustomSetInterval(() =&gt; &#123;    console.log(&#x27;想你了&#x27;)&#125;, 1000)setTimeout(() =&gt; &#123;    interval()&#125;, 5000)

🚀 Promise 源码实现完全指南 - 从零手写 Promise
🎯 阅读本节你将收获：

深入理解 Promise 内部运行机制
手写一个符合 Promise&#x2F;A+ 规范的 Promise
掌握面试中 Promise 相关的核心考点
理解 async&#x2F;await 的实现原理


📌 开篇：为什么要手写 Promise？在面试中，Promise 相关的题目可以说是必考题。但很多同学只会用，不知道其内部原理。今天我们就一起来揭开 Promise 的神秘面纱，手写一个完整的 Promise！
一、Promise 基础架构 - 搭建地基 🏗️1.1 最简单的 Promise 结构我们先从最简单的结构开始，就像盖房子要先打地基：
class MyPromise &#123;    constructor(executor) &#123;        // executor 是使用者传入的函数，形如 (resolve, reject) =&gt; &#123;&#125;                // 定义 resolve 函数        const resolve = (value) =&gt; &#123;            console.log(&#x27;调用了 resolve，值为：&#x27;, value);        &#125;                // 定义 reject 函数        const reject = (reason) =&gt; &#123;            console.log(&#x27;调用了 reject，原因为：&#x27;, reason);        &#125;                // 立即执行 executor        executor(resolve, reject);    &#125;&#125;// 测试一下new MyPromise((resolve, reject) =&gt; &#123;    resolve(&#x27;成功啦！&#x27;);&#125;);

1.2 Promise 的三种状态 - 状态机 🚦Promise 就像一个有三种状态的交通灯：

🟡 pending（等待态）：初始状态，既不是成功，也不是失败
🟢 fulfilled（成功态）：操作成功完成
🔴 rejected（失败态）：操作失败

重要特性：

状态只能从 pending → fulfilled 或 pending → rejected
状态一旦改变，就永远不会再变（这就是为什么叫 “Promise” - 承诺）

让我们加上状态管理：
class MyPromise &#123;    constructor(executor) &#123;        // 初始状态为 pending        this.status = &#x27;pending&#x27;;        // 成功的值        this.value = undefined;        // 失败的原因        this.reason = undefined;                // resolve 函数：将状态从 pending 改为 fulfilled        const resolve = (value) =&gt; &#123;            // 只有在 pending 状态才能改变状态（保证状态只改变一次）            if (this.status === &#x27;pending&#x27;) &#123;                this.status = &#x27;fulfilled&#x27;;                this.value = value;            &#125;        &#125;                // reject 函数：将状态从 pending 改为 rejected        const reject = (reason) =&gt; &#123;            if (this.status === &#x27;pending&#x27;) &#123;                this.status = &#x27;rejected&#x27;;                this.reason = reason;            &#125;        &#125;                // 立即执行 executor，并传入 resolve 和 reject        try &#123;            executor(resolve, reject);        &#125; catch (error) &#123;            // 如果执行器抛出异常，Promise 应该被拒绝            reject(error);        &#125;    &#125;&#125;

二、实现 then 方法 - Promise 的灵魂 ✨2.1 then 方法的基本实现then 方法是 Promise 的核心，它用来注册当 Promise 状态改变时的回调函数。
class MyPromise &#123;    // ... 前面的代码    then(onFulfilled, onRejected) &#123;        // 如果状态是 fulfilled，执行成功回调        if (this.status === &#x27;fulfilled&#x27;) &#123;            onFulfilled(this.value);        &#125;                // 如果状态是 rejected，执行失败回调        if (this.status === &#x27;rejected&#x27;) &#123;            onRejected(this.reason);        &#125;    &#125;&#125;// 测试同步情况const promise = new MyPromise((resolve, reject) =&gt; &#123;    resolve(&#x27;成功！&#x27;);&#125;);promise.then(    value =&gt; console.log(&#x27;成功:&#x27;, value),    reason =&gt; console.log(&#x27;失败:&#x27;, reason));

2.2 处理异步情况 - 发布订阅模式 📢上面的代码有个问题：如果 executor 中有异步操作怎么办？
const promise = new MyPromise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;        resolve(&#x27;异步成功！&#x27;);    &#125;, 1000);&#125;);// 此时状态还是 pending，then 方法不会执行任何回调！promise.then(value =&gt; console.log(value));

解决方案：使用发布订阅模式，先把回调存起来，等状态改变时再执行：
class MyPromise &#123;    constructor(executor) &#123;        this.status = &#x27;pending&#x27;;        this.value = undefined;        this.reason = undefined;                // 存储成功回调的数组        this.onFulfilledCallbacks = [];        // 存储失败回调的数组        this.onRejectedCallbacks = [];                const resolve = (value) =&gt; &#123;            if (this.status === &#x27;pending&#x27;) &#123;                this.status = &#x27;fulfilled&#x27;;                this.value = value;                // 状态改变时，执行所有的成功回调                this.onFulfilledCallbacks.forEach(fn =&gt; fn());            &#125;        &#125;                const reject = (reason) =&gt; &#123;            if (this.status === &#x27;pending&#x27;) &#123;                this.status = &#x27;rejected&#x27;;                this.reason = reason;                // 状态改变时，执行所有的失败回调                this.onRejectedCallbacks.forEach(fn =&gt; fn());            &#125;        &#125;                try &#123;            executor(resolve, reject);        &#125; catch (error) &#123;            reject(error);        &#125;    &#125;        then(onFulfilled, onRejected) &#123;        if (this.status === &#x27;fulfilled&#x27;) &#123;            onFulfilled(this.value);        &#125;                if (this.status === &#x27;rejected&#x27;) &#123;            onRejected(this.reason);        &#125;                // 如果是 pending 状态，将回调存储起来        if (this.status === &#x27;pending&#x27;) &#123;            this.onFulfilledCallbacks.push(() =&gt; &#123;                onFulfilled(this.value);            &#125;);            this.onRejectedCallbacks.push(() =&gt; &#123;                onRejected(this.reason);            &#125;);        &#125;    &#125;&#125;

2.3 链式调用的实现 - then 返回 Promise 🔗Promise 最强大的特性之一就是链式调用。要实现链式调用，then 方法必须返回一个新的 Promise：
then(onFulfilled, onRejected) &#123;    // then 方法返回一个新的 Promise    return new MyPromise((resolve, reject) =&gt; &#123;        // 封装一个执行函数，统一处理成功和失败的情况        const fulfilledMicrotask = () =&gt; &#123;            // 使用 queueMicrotask 创建微任务，保证异步执行            queueMicrotask(() =&gt; &#123;                try &#123;                    const x = onFulfilled(this.value);                    // 处理返回值（详见下一节）                    resolvePromise(promise2, x, resolve, reject);                &#125; catch (error) &#123;                    reject(error);                &#125;            &#125;);        &#125;;                const rejectedMicrotask = () =&gt; &#123;            queueMicrotask(() =&gt; &#123;                try &#123;                    const x = onRejected(this.reason);                    resolvePromise(promise2, x, resolve, reject);                &#125; catch (error) &#123;                    reject(error);                &#125;            &#125;);        &#125;;                if (this.status === &#x27;fulfilled&#x27;) &#123;            fulfilledMicrotask();        &#125; else if (this.status === &#x27;rejected&#x27;) &#123;            rejectedMicrotask();        &#125; else if (this.status === &#x27;pending&#x27;) &#123;            this.onFulfilledCallbacks.push(fulfilledMicrotask);            this.onRejectedCallbacks.push(rejectedMicrotask);        &#125;    &#125;);&#125;

2.4 处理 then 的返回值 - resolvePromise 🎯这是实现 Promise 最复杂的部分，需要处理各种情况：
function resolvePromise(promise2, x, resolve, reject) &#123;    // 如果 x === promise2，会造成循环引用    if (x === promise2) &#123;        return reject(new TypeError(&#x27;Chaining cycle detected&#x27;));    &#125;        // 如果 x 是 Promise 实例    if (x instanceof MyPromise) &#123;        // 等待 x 的状态改变，然后递归处理        x.then(            value =&gt; resolvePromise(promise2, value, resolve, reject),            reason =&gt; reject(reason)        );        return;    &#125;        // 如果 x 是对象或函数（可能是 thenable）    if (x !== null &amp;&amp; (typeof x === &#x27;object&#x27; || typeof x === &#x27;function&#x27;)) &#123;        let then;        try &#123;            then = x.then;        &#125; catch (error) &#123;            return reject(error);        &#125;                // 如果 then 是函数，认为 x 是 thenable        if (typeof then === &#x27;function&#x27;) &#123;            let called = false; // 防止多次调用            try &#123;                then.call(                    x,                    value =&gt; &#123;                        if (called) return;                        called = true;                        resolvePromise(promise2, value, resolve, reject);                    &#125;,                    reason =&gt; &#123;                        if (called) return;                        called = true;                        reject(reason);                    &#125;                );            &#125; catch (error) &#123;                if (called) return;                reject(error);            &#125;        &#125; else &#123;            // 如果 then 不是函数，直接 resolve            resolve(x);        &#125;    &#125; else &#123;        // 如果 x 是普通值，直接 resolve        resolve(x);    &#125;&#125;

三、实现 Promise 的静态方法 🛠️3.1 Promise.resolve 和 Promise.rejectclass MyPromise &#123;    // 快速创建一个成功的 Promise    static resolve(value) &#123;        // 如果 value 已经是 Promise，直接返回        if (value instanceof MyPromise) &#123;            return value;        &#125;                return new MyPromise(resolve =&gt; resolve(value));    &#125;        // 快速创建一个失败的 Promise    static reject(reason) &#123;        return new MyPromise((resolve, reject) =&gt; reject(reason));    &#125;&#125;

3.2 Promise.all - 一个都不能少 🎯Promise.all 接收一个 Promise 数组，只有全部成功才成功，有一个失败就失败：
static all(promises) &#123;    return new MyPromise((resolve, reject) =&gt; &#123;        const results = [];        let completedCount = 0;                // 处理空数组的情况        if (promises.length === 0) &#123;            resolve(results);            return;        &#125;                promises.forEach((promise, index) =&gt; &#123;            // 将非 Promise 值转换为 Promise            MyPromise.resolve(promise).then(                value =&gt; &#123;                    results[index] = value;                    completedCount++;                                        // 所有 Promise 都成功了                    if (completedCount === promises.length) &#123;                        resolve(results);                    &#125;                &#125;,                reason =&gt; &#123;                    // 有一个失败就直接 reject                    reject(reason);                &#125;            );        &#125;);    &#125;);&#125;

3.3 Promise.race - 谁快用谁 🏃static race(promises) &#123;    return new MyPromise((resolve, reject) =&gt; &#123;        // 空数组永远 pending        if (promises.length === 0) return;                promises.forEach(promise =&gt; &#123;            // 谁先完成就用谁的结果            MyPromise.resolve(promise).then(resolve, reject);        &#125;);    &#125;);&#125;

3.4 Promise.allSettled - 等待所有结果 📊不管成功还是失败，等所有 Promise 都有结果：
static allSettled(promises) &#123;    return new MyPromise((resolve) =&gt; &#123;        const results = [];        let settledCount = 0;                if (promises.length === 0) &#123;            resolve(results);            return;        &#125;                promises.forEach((promise, index) =&gt; &#123;            MyPromise.resolve(promise).then(                value =&gt; &#123;                    results[index] = &#123; status: &#x27;fulfilled&#x27;, value &#125;;                    settledCount++;                    if (settledCount === promises.length) &#123;                        resolve(results);                    &#125;                &#125;,                reason =&gt; &#123;                    results[index] = &#123; status: &#x27;rejected&#x27;, reason &#125;;                    settledCount++;                    if (settledCount === promises.length) &#123;                        resolve(results);                    &#125;                &#125;            );        &#125;);    &#125;);&#125;

3.5 Promise.any - 一个成功就够了 ✅static any(promises) &#123;    return new MyPromise((resolve, reject) =&gt; &#123;        const errors = [];        let rejectedCount = 0;                if (promises.length === 0) &#123;            reject(new AggregateError([], &#x27;All promises were rejected&#x27;));            return;        &#125;                promises.forEach((promise, index) =&gt; &#123;            MyPromise.resolve(promise).then(                value =&gt; &#123;                    // 有一个成功就 resolve                    resolve(value);                &#125;,                reason =&gt; &#123;                    errors[index] = reason;                    rejectedCount++;                                        // 全部失败才 reject                    if (rejectedCount === promises.length) &#123;                        reject(new AggregateError(errors, &#x27;All promises were rejected&#x27;));                    &#125;                &#125;            );        &#125;);    &#125;);&#125;

四、实现 catch 和 finally 🎣4.1 catch - 错误处理catch(onRejected) &#123;    // catch 就是 then 的语法糖    return this.then(null, onRejected);&#125;

4.2 finally - 无论如何都要执行finally(callback) &#123;    return this.then(        // 成功时执行 callback，但传递原来的值        value =&gt; MyPromise.resolve(callback()).then(() =&gt; value),        // 失败时执行 callback，但传递原来的错误        reason =&gt; MyPromise.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)    );&#125;

五、async&#x2F;await 的实现原理 🔮5.1 理解 async&#x2F;awaitasync/await 本质上是 Generator + Promise 的语法糖。让我们看看它是如何工作的：
// async 函数async function fetchData() &#123;    const user = await getUser();    const posts = await getPosts(user.id);    return posts;&#125;// 等价于function fetchData() &#123;    return spawn(function* () &#123;        const user = yield getUser();        const posts = yield getPosts(user.id);        return posts;    &#125;);&#125;

5.2 实现自动执行器function spawn(genFunc) &#123;    return new Promise((resolve, reject) =&gt; &#123;        const gen = genFunc();                function step(nextFunc) &#123;            let next;            try &#123;                next = nextFunc();            &#125; catch (error) &#123;                return reject(error);            &#125;                        // Generator 函数执行完毕            if (next.done) &#123;                return resolve(next.value);            &#125;                        // 将 yield 的值包装成 Promise，然后递归执行            Promise.resolve(next.value).then(                value =&gt; step(() =&gt; gen.next(value)),                error =&gt; step(() =&gt; gen.throw(error))            );        &#125;                // 开始执行        step(() =&gt; gen.next());    &#125;);&#125;

5.3 一个更简单的实现function asyncToGenerator(generatorFunc) &#123;    return function (...args) &#123;        const gen = generatorFunc.apply(this, args);                return new Promise((resolve, reject) =&gt; &#123;            function step(key, arg) &#123;                let generatorResult;                                try &#123;                    generatorResult = gen[key](arg);                &#125; catch (error) &#123;                    return reject(error);                &#125;                                const &#123; value, done &#125; = generatorResult;                                if (done) &#123;                    return resolve(value);                &#125; else &#123;                    return Promise.resolve(value).then(                        val =&gt; step(&#x27;next&#x27;, val),                        err =&gt; step(&#x27;throw&#x27;, err)                    );                &#125;            &#125;                        step(&#x27;next&#x27;);        &#125;);    &#125;;&#125;// 使用示例const getData = asyncToGenerator(function* () &#123;    const data1 = yield fetch(&#x27;/api/1&#x27;);    const data2 = yield fetch(&#x27;/api/2&#x27;);    return [data1, data2];&#125;);getData().then(result =&gt; console.log(result));

🎯 面试高频考点总结
Promise 的状态机制：三种状态，只能单向改变，一旦改变不可逆
then 的链式调用：then 返回新的 Promise，根据回调函数的返回值决定新 Promise 的状态
微任务队列：Promise 的回调在微任务队列中执行
错误处理：catch 能捕获前面所有 then 中的错误
Promise.all vs Promise.race：一个要全部成功，一个要最快完成
async&#x2F;await 原理：Generator + 自动执行器 + Promise

模板渲染引擎&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;模板渲染示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;// 渲染引擎function renderTemplate(template, data) &#123;    // 处理条件判断    template = template.replace(/&#123;&#123;\s*#if\s*(\w+)\s*&#125;&#125;([\s\S]*?)&#123;&#123;\s*\/if\s*&#125;&#125;/g, function (_, condition, content) &#123;        return data[condition] ? content : &#x27;&#x27;;    &#125;);    // 处理循环    template = template.replace(/&#123;&#123;\s*#each\s*(\w+)\s*&#125;&#125;([\s\S]*?)&#123;&#123;\s*\/each\s*&#125;&#125;/g, function (_, arrayKey, content) &#123;        let result = &#x27;&#x27;;        let array = data[arrayKey];        if (Array.isArray(array)) &#123;            array.forEach((item, index) =&gt; &#123;                // 创建一个独立作用域，避免冲突                let temp = content;                // 替换模板内的 &#123;&#123; this &#125;&#125; 为循环项                temp = temp.replace(/&#123;&#123;\s*this\s*&#125;&#125;/g, function () &#123;                    return item;                &#125;);                // 如果是对象，处理它的属性                temp = temp.replace(/&#123;&#123;\s*this\.(\w+)\s*&#125;&#125;/g, function (_, prop) &#123;                    return item[prop] || &#x27;&#x27;;                &#125;);                // 替换循环索引（如果需要）                temp = temp.replace(/&#123;&#123;\s*index\s*&#125;&#125;/g, index);                // 将处理后的结果添加到最终结果中                result += temp;            &#125;);        &#125;        return result;    &#125;);    // 替换变量，一定要放到最后！！    template = template.replace(/\&#123;\&#123;(.*?)\&#125;\&#125;/g, (match, key) =&gt; &#123;        let keys = key.trim().split(&#x27;.&#x27;);        return keys.reduce((obj, k) =&gt; obj?.[k], data) || &#x27;&#x27;;    &#125;)    return template;&#125;// 定义数据const data = &#123;    name: &quot;张三&quot;,    age: 25,    isEmployed: true,    occupation: &quot;工程师&quot;,    hobbies: [&quot;阅读&quot;, &quot;编程&quot;, &quot;旅游&quot;],    friends: [        &#123; name: &quot;李四&quot;, age: 26 &#125;,        &#123; name: &quot;王五&quot;, age: 24 &#125;    ]&#125;;// 定义模板const template = `    &lt;h1&gt;个人信息&lt;/h1&gt;    &lt;p&gt;姓名: &#123;&#123; name &#125;&#125;&lt;/p&gt;    &lt;p&gt;年龄: &#123;&#123; age &#125;&#125;&lt;/p&gt;    &lt;p&gt;职业: &#123;&#123; occupation &#125;&#125;&lt;/p&gt;    &#123;&#123;#if isEmployed&#125;&#125;        &lt;p&gt;当前状态: 在职&lt;/p&gt;    &#123;&#123;/if&#125;&#125;    &lt;h2&gt;兴趣爱好&lt;/h2&gt;    &lt;ul&gt;        &#123;&#123;#each hobbies&#125;&#125;            &lt;li&gt;&#123;&#123; this &#125;&#125;&lt;/li&gt;        &#123;&#123;/each&#125;&#125;    &lt;/ul&gt;    &lt;h2&gt;朋友列表&lt;/h2&gt;    &lt;ul&gt;        &#123;&#123;#each friends&#125;&#125;            &lt;li&gt;&#123;&#123; this.name &#125;&#125; - &#123;&#123; this.age &#125;&#125; 岁&lt;/li&gt;        &#123;&#123;/each&#125;&#125;    &lt;/ul&gt;`;// 渲染模板并插入 HTMLdocument.getElementById(&#x27;app&#x27;).innerHTML = renderTemplate(template, data);

防抖截流const debounce = (fn, ms, Immediate = false) =&gt; &#123;    // Immediate选择是否立即执行    let timer = null;    return function (...thisArgs) &#123;        if (timer) &#123;            clearTimeout(timer)        &#125;        if (Immediate) &#123;            let flag = !timer            flag &amp;&amp; fn.apply(this, thisArgs)            timer = setTimeout(() =&gt; &#123;                timer = null            &#125;, ms)        &#125; else &#123;            timer = setTimeout(() =&gt; &#123;                fn.apply(this, thisArgs)                timer = null            &#125;, ms)        &#125;    &#125;&#125;const throttle = (fn, ms) =&gt; &#123;    let timer = null;    return function (...thisArgs) &#123;        if (!timer) &#123;            fn.apply(this, thisArgs);            timer = setTimeout(() =&gt; &#123;                timer = null;            &#125;, ms);        &#125;    &#125;&#125;

技巧数组去重let arr = [1, 0, 2, 3, 4, 5, 2, 3, 4];//indexOf去重function removeRepeat(arr) &#123;  let res = [];  for (let i of arr) &#123;    if (res.indexOf(i) == -1) &#123;      res.push(i);    &#125;  &#125;  return res;&#125;// set 去重function removeRepeat(arr) &#123;  let res = new Set(arr);  return Array.from(res);&#125;// for循环去重function removeRepeat(arr) &#123;  for (let i = 0; i &lt; arr.length; i++) &#123;    for (let j = i + 1; j &lt; arr.length; j++) &#123;      if (arr[i] == arr[j]) &#123;        arr.splice(j, 1);        j--;      &#125;    &#125;  &#125;  return arr;&#125;// filter 去重function removeRepeat(arr) &#123;  return arr.filter((item, index) =&gt; &#123;    return arr.indexOf(item) == index;  &#125;);&#125;// includes 去重function removeRepeat(arr) &#123;  let res = [];  for (let i of arr) &#123;    if (!res.includes(i)) &#123;      res.push(i);    &#125;  &#125;  return res;&#125;let res = removeRepeat(arr);console.log(res);

快排和归并Array.prototype.quicksort = function (l, r) &#123;    if (l &gt;= r) return this;    let key = this[l];    let i = l - 1, j = r + 1;    while (i &lt; j) &#123;        do i++; while (this[i] &lt; key);        do j--; while (this[j] &gt; key);        if (i &lt; j) [this[i], this[j]] = [this[j], this[i]];    &#125;    this.quicksort(l, j);    this.quicksort(j + 1, r);    return this;&#125;let arr = [5,8,3,6,4,2];console.log(arr.quicksort(0, arr.length-1));Array.prototype.mergesort = function (temp, l, r) &#123;    if (l &gt;= r) return this;    let mid = l + r &gt;&gt; 1;    this.mergesort(temp, l, mid);    this.mergesort(temp, mid + 1, r);    let i = l, j = mid + 1, k = 0;    while (i &lt;= mid &amp;&amp; j &lt;= r) &#123;        if (this[i] &lt;= this[j]) temp[k++] = this[i++];        else temp[k++] = this[j++];    &#125;    while (i &lt;= mid) temp[k++] = this[i++];    while (j &lt;= r) temp[k++] = this[j++];    for (let m = 0, n = l; n &lt;= r; m++, n++) &#123;        this[n] = temp[m];    &#125;    return this;&#125;let arr = [7, 1, 0, 3, 0, 5, 6, 4];console.log(arr.mergesort(Array(arr.length).fill(0), 0, arr.length - 1));

下划线和驼峰相互转换//方式一：操作字符串数组function transformStr2Hump1(str) &#123;    if(str == null) &#123;        return &quot;&quot;;    &#125;    var strArr = str.split(&#x27;-&#x27;);    for(var i = 1; i &lt; strArr.length; i++) &#123;        strArr[i] = strArr[i].charAt(0).toUpperCase() + strArr[i].substring(1);    &#125;    return strArr.join(&#x27;&#x27;);&#125;//方式二：操作字符数组function transformStr2Hump2(str) &#123;    if(str == null) &#123;        return &quot;&quot;;    &#125;    var strArr  =str.split(&#x27;&#x27;);    for(var i = 0; i &lt; strArr.length; i++) &#123;        if(strArr[i] == &quot;-&quot;)&#123;            //删除-            strArr.splice(i, 1);            //将该处改为大写            if(i &lt; strArr.length) &#123;                strArr[i] = strArr[i].toUpperCase();            &#125;        &#125;    &#125;    return strArr.join(&quot;&quot;);&#125;//方式三：利用正则function transformStr2Hump3(str) &#123;    if(str == null) &#123;        return &quot;&quot;;    &#125;    var reg = /-(\w)/g;//匹配字母或数字或下划线或汉字    return str.replace(reg, function($0, $1) &#123;        return $1.toUpperCase();    &#125;)&#125;

懒加载
首先，不要将图片地址放到src属性中，而是放到其它属性(data-original)中。
页面加载完成后，根据scrollTop判断图片是否在用户的视野内，如果在，则将data-original属性中的值取出存放到src属性中。
在滚动事件中重复判断图片是否进入视野，如果进入，则将data-original属性中的值取出存放到src属性中。


 elementNode.getAttribute(name)：方法通过名称获取属性的值。
 elementNode.setAttribute(name, value)：方法创建或改变某个新属性。
 elementNode.removeAttribute(name)：方法通过名称删除属性的值。

//懒加载代码实现var viewHeight = document.documentElement.clientHeight;//可视化区域的高度function lazyload () &#123;    //获取所有要进行懒加载的图片    let eles = document.querySelectorAll(&#x27;img[data-original][lazyload]&#x27;);//获取属性名中有data-original的    Array.prototype.forEach.call(eles, function(item, index) &#123;        let rect;        if(item.dataset.original === &#x27;&#x27;) &#123;            return;        &#125;        rect = item.getBoundingClientRect();        //图片一进入可视区，动态加载        if(rect.bottom &gt;= 0 &amp;&amp; rect.top &lt; viewHeight) &#123;            !function () &#123;                let img = new Image();                img.src = item.dataset.original;                img.onload = function () &#123;                    item.src = img.src;                &#125;                item.removeAttribute(&#x27;data-original&#x27;);                item.removeAttribute(&#x27;lazyload&#x27;);            &#125;();        &#125;    &#125;)&#125;lazyload();document.addEventListener(&#x27;scroll&#x27;, lazyload);

数组扁平化//传入参数 决定扁平化的阶数Array.prototype._flat = function (n) &#123;    let result = [];    let num = n;    for (let item of this) &#123;        // 如果是数组        if (Array.isArray(item)) &#123;            n--;            //   没有扁平化的空间 直接推入            if (n &lt; 0) &#123;                result.push(item);            &#125;            // 继续扁平化 并将n传入 决定item这一个数组中的扁平化            else &#123;                result.push(...item._flat(n));            &#125;        &#125;        // 不是数组直接推入        else &#123;            result.push(item);        &#125;        // 每次循环 重置n 为传入的参数 因为每一项都需要扁平化 需要进行判断        n = num;    &#125;    return result;&#125;;let arr = [1, 2, [3, 4], [5, 6, [7, 8]]];let res = arr._flat(1);console.log(res); // [ 1, 2, 3, 4, 5, 6, [ 7, 8 ] ]

计算属性请不要为所有函数添加缓存！
const computed = (func, content) =&gt; &#123;    let cache = Object.create(null);    content = content || this;    return (...key) =&gt; &#123;        console.log(cache)        if (!cache[key]) &#123;            cache[key] = func.apply(content, key);        &#125;        return cache[key];    &#125;&#125;

有并发限制的Promise调度器class Scheduler&#123;    constructor(limit)&#123;        this.limit = limit;        this.running = 0;        this.queue = [];    &#125;    createTask(callback, duration)&#123;        return ()=&gt;&#123;            return new Promise((resolve, reject)=&gt;&#123;                setTimeout(()=&gt;&#123;                    callback();                    resolve();                &#125;,duration);            &#125;);        &#125;;    &#125;        add(callback, duration)&#123;        const task = this.createTask(callback, duration);        this.queue.push(task);    &#125;        start()&#123;        for(let i=0;i&lt;this.limit;++i)&#123;            this.schedule();        &#125;    &#125;    schedule()&#123;        if(this.queue.length === 0 || this.running &gt;= this.limit)return;        this.running++;        const task = this.queue.shift();                task().then(()=&gt;&#123;            this.running--;            schedule();        &#125;);    &#125;&#125;

网络请求和跨域解决方案原生ajaxfunction sendajax() &#123;    // 1、 初始化xhr对象    const xhr = new XMLHttpRequest();    //  2、 建立连接 设置请求方法和url    xhr.open(&quot;get&quot;, &quot;./data.json&quot;);    //   3、发送请求    xhr.send();    //   4、状态改变时 进行回调    xhr.onreadystatechange = function () &#123;        // readyState 有0-4 五个值        // 0 代表 未初始化 1 代表 初始化成功 2 代表发送请求        // 3 代表返回了部分数据 4 代表返回了全部数据        if (xhr.readyState == 4) &#123;            if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123;                //   进行成功的操作                console.log(xhr.responseText);            &#125;        &#125;    &#125;;&#125;sendajax();

JSONP跨域首先在客户端注册一个callback，然后把callback的名字传给服务器。此时，服务器先生成json数据，然后以JavaScript的语法方式，生成function，function的名字就是传递上来带参数的jsonp，最后将json数据直接以入参的方式，放置在function中，这样子就生成JavaScript语法文档，返回给客户端。客户端浏览器，通过解析，并执行返回JavaScript文档，此时数据作为参数，传入到客户端预先定义好的callback函数中，简单地说，就是利用script标签没有跨域限制地漏洞来达到第三方通讯的目的（href、src 都不受同源策略的限制。）
优点：

它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制，JSONP可以跨越同源策略；
它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；

缺点:

它只支持GET请求而不支持POST等其它类型的HTTP请求
它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。
jsonp在调用失败的时候不会返回各种HTTP状态码。
需要后端配合

function jsonp(&#123;url,params,cb&#125;)&#123;        return new Promise((resolve, reject)=&gt;&#123;                window[cb] = function(data)&#123;                        console.log(data)                        resolve(data);                        document.body.removeChild(script);                &#125;//window对象上设置show方法                params= &#123;...params,cb&#125;                let arrs = [];                for (let key in params)&#123;                        arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`)                &#125;                let script = document.createElement(&#x27;script&#x27;);                script.src = `$&#123;url&#125;?$&#123;arrs.join(&#x27;&amp;&#x27;)&#125;`;                script.onerror = () =&gt; reject(&#x27;加载失败&#x27;)                 document.body.appendChild(script);                &#125;)&#125;jsonp(&#123;        url:&quot;http://localhost:3000/users&quot;,        params:&#123;name:&quot;jin&quot;,age:12&#125;,        cb:&#x27;show&#x27;&#125;).then(data=&gt;&#123;        console.log(data)&#125;)

后端：
let express = require(&#x27;express&#x27;);let app = express();app.get(&#x27;/users&#x27;, function(req, res, next) &#123;        // 模拟的数据        let &#123;name,age,cb&#125; = req.query        let data = `&quot;$&#123;name&#125;现在$&#123;age&#125;岁&quot;`        res.send(`$&#123;cb&#125;($&#123;data&#125;)`);// show(data)&#125;);app.listen(3000)

cors跨域同源策略是不允许接收响应而不是不允许发送请求，所以可以通过在响应头中设置某些字段来允许满足条件的请求跨域，比如设置 Access-Control-Allow-Origin 字段允许来自某个源的请求跨域，比如设置 Access-Control-Allow-Methods 字段允许’GET’或者’POST’方式的请求跨域
后端：
let express = require(&#x27;express&#x27;);let app = express();app.all(&#x27;*&#x27;, function (req, res, next) &#123;  let origin = req.headers.origin        //设置哪个源可以访问我  res.header(&quot;Access-Control-Allow-Origin&quot;,origin);        // 允许携带哪个头访问我  res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;name&quot;);        // 允许哪个方法访问我  res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;POST&quot;);        // 允许携带cookie  res.set(&quot;Access-Control-Allow-Credentials&quot;, true);        // 预检的存活时间  res.header(&quot;Access-Control-Max-Age&quot;, 6);        // 允许前端获取哪个头        res.header(&quot;Access-Control-Expose-Headers&quot;, &quot;name&quot;);        // 请求头的格式  res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);          next();&#125;);app.post(&#x27;/getData&#x27;, function(req, res, next) &#123;        console.log(req.headers)        res.send(&quot;你拿不到数据了！&quot;);&#125;);app.listen(4000)


非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。
非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。
浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 代码修改一下：
// 在请求头的设置中加上if(req.method ===&#x27;OPTIONS&#x27;)&#123;    res.end();//OPTIONS请求不做任何处理&#125;


postMessage跨域「window.postMessage()」 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 https），端口号（443 为 https 的默认值），以及主机 (两个页面的模数 [Document.domain]设置为相同的值) 时，这两个脚本才能相互通信。「window.postMessage()」 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。
用途
1.页面和其打开的新窗口的数据传递
2.多窗口之间消息传递
3.页面与嵌套的 iframe 消息传递
实现
a.html
&lt;iframe src=&quot;http://localhost:4000/b.html&quot; frameborder=&quot;0&quot; id=&quot;frame&quot; onload=&quot;load()&quot;&gt;&lt;/iframe&gt;&lt;script&gt;    function load()&#123;        let frame = document.getElementById(&#x27;frame&#x27;);        frame.contentWindow.postMessage(&#x27;你好&#x27;,&#x27;http://localhost:4000/&#x27;);        //接收        window.onmessage= function(e)&#123;            console.log(e.data)        &#125;    &#125;&lt;/script&gt;

b.html
window.onmessage = function(e)&#123;    console.log(e.data);    //发送    e.source.postMessage(&#x27;hello&#x27;,e.origin)&#125;

本地代理跨域proxy其实就是因为浏览器同源协议无法请求非同源的地址，但是服务器直接没有同源协议，利用将本地请求转到本地服务器进行代理转发，从而绕过了同源协议的限制，通过代理的实现可以解决跨域的问题
通过设置一个 node 后端作为中间层，前端发送的请求首先到达这个中间层，然后再由中间层将请求转发到目标服务器。响应过程也是如此，服务器先响应给中间层，中间层再将响应数据发送回前端。
这个中间层就起到了一个代理的作用。这样，浏览器看到的是同源请求，从而绕过了CORS限制。
假设前端现在要将请求发送给 http://192.168.1.63:3000 这个后端，就可以先由本机的 3001 端口作一个代理
&lt;!-- 前端 --&gt;&lt;body&gt;    &lt;script&gt;        const xhr = new XMLHttpRequest()        xhr.open(&#x27;GET&#x27;, &#x27;https://localhost:3001&#x27;)        xhr.send()        xhr.onreadystatechange = function() &#123;            if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123;                console.log(xhr.responseText)            &#125;        &#125;    &lt;/script&gt;&lt;/body&gt;

本机后端
// 后端const http = require(&#x27;http&#x27;)// 监听本机3001端口，有新请求时调用回调函数http.createServer((req, res)  =&gt; &#123;    // 设置响应头，以允许前端应用访问响应内容    res.writeHead(200, &#123;        &#x27;Access-Control-Allow-Origin&#x27;: &#x27;*&#x27;    &#125;)    // 转发请求到目标服务器，并处理响应    http.request(&#123;        host: &#x27;192.168.1.63&#x27;,        port: 3000,        path: &#x27;/&#x27;,        method: &#x27;GET&#x27;,        headers: &#123;&#125;    &#125;, proxyRes =&gt; &#123;        proxyRes.on(&#x27;data&#x27;, chunk =&gt; &#123;            res.end(chunk.toString())        &#125;)    &#125;).end()    &#125;).listen(3001)

各脚手架的proxy配置：Webpack (4.x)在webpack中可以配置proxy来快速获得接口代理的能力。
const path = require(&quot;path&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123;  entry: &#123;    index: &quot;./index.js&quot;  &#125;,  output: &#123;    filename: &quot;bundle.js&quot;,    path: path.resolve(__dirname, &quot;dist&quot;)  &#125;,  devServer: &#123;    port: 8000,    proxy: &#123;      &quot;/api&quot;: &#123;        target: &quot;http://localhost:8080&quot;      &#125;    &#125;  &#125;,  plugins: [    new HtmlWebpackPlugin(&#123;      filename: &quot;index.html&quot;,      template: &quot;webpack.html&quot;    &#125;)  ]&#125;;

Vue-cli 2.x// config/index.js...proxyTable: &#123;  &#x27;/api&#x27;: &#123;     target: &#x27;http://localhost:8080&#x27;,  &#125;&#125;,...

Vue-cli 3.x// vue.config.js 如果没有就新建module.exports = &#123;  devServer: &#123;    port: 8000,    proxy: &#123;      &quot;/api&quot;: &#123;        target: &quot;http://localhost:8080&quot;      &#125;    &#125;  &#125;&#125;;

viteimport &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import styleImport, &#123; VantResolve &#125; from &#x27;vite-plugin-style-import&#x27;;// https://vitejs.dev/config/export default defineConfig(&#123;  plugins: [    vue(),    styleImport(&#123;      resolves: [VantResolve()],    &#125;),],    server: &#123; //主要是加上这段代码      host: &#x27;127.0.0.1&#x27;,      port: 3000,      proxy: &#123;        &#x27;/api&#x27;: &#123;          target: &#x27;http://127.0.0.1:8888&#x27;,        //实际请求地址          changeOrigin: true,          rewrite: (path) =&gt; path.replace(/^\/api/, &#x27;&#x27;)        &#125;,      &#125;    &#125;&#125;)

nginx反向代理跨域反向代理与本地代理相反。本地代理是客户端搞定的，反向代理就是服务端搞定的
反向代理的是在服务端内部完成。
是服务端（数据应用）向服务端（网页应用）发送数据， 服务端向客户端发送数据 其本质是在服务端（网页应用）通过配置Access-Control-Allow-Origin * 来解决跨域问题。相当于对后端接口进行了统一的cors配置
Access-Control-Allow-Origin: * 值表明，该资源可以被任意外源访问。
    #通过配置nginx文件既可        events&#123;&#125;http&#123;    include       mime.types;    default_type  application/octet-stream;    server&#123;        listen 80;        server_name 127.0.0.1;        root D:/nginx-1.26.1/dist;        index index.html;        location / &#123;                  location /api &#123;                proxy_pass http://127.0.0.1:8080/;                proxy_set_header Host $host;                proxy_set_header X-Real-IP $remote_addr;                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;                proxy_set_header X-Forwarded-Proto $scheme;                # 解决跨域问题                add_header Access-Control-Allow-Origin *;                add_header Access-Control-Allow-Methods &quot;GET, POST, OPTIONS, HEAD, PUT, DELETE&quot;;                add_header Access-Control-Allow-Headers &quot;Origin, X-Requested-With, Content-Type, Accept, Authorization, User-Agent, DNT&quot;;                add_header Access-Control-Max-Age 86400;                            &#125;        &#125;    &#125;&#125;

设计模式单例模式// 单例模式示例代码class Singleton &#123;  constructor() &#123;    if (!Singleton.instance) &#123;      Singleton.instance = this;    &#125;    return Singleton.instance;  &#125;  createInstance() &#123;    const object = &#123; name: &quot;example&quot; &#125;;    return object;  &#125;  getInstance() &#123;    if (!Singleton.instance) &#123;      Singleton.instance = this.createInstance();    &#125;    return Singleton.instance;  &#125;&#125;// 使用示例const instance1 = new Singleton();const instance2 = new Singleton();console.log(instance1 === instance2); // true

工厂模式class Product &#123;  constructor(name) &#123;    this.name = name;  &#125;  getName() &#123;    return this.name;  &#125;&#125;class ProductFactory &#123;  static createProduct(name) &#123;    return new Product(name);  &#125;&#125;// 使用示例const product = ProductFactory.createProduct(&quot;Example Product&quot;);console.log(product.getName()); // &quot;Example Product&quot;

观察者模式class Subject &#123;  constructor() &#123;    this.observers = [];  &#125;  addObserver(observer) &#123;    this.observers.push(observer);  &#125;  removeObserver(observer) &#123;    const index = this.observers.indexOf(observer);    if (index !== -1) &#123;      this.observers.splice(index, 1);    &#125;  &#125;  notify(data) &#123;    this.observers.forEach(observer =&gt; observer.update(data));  &#125;&#125;class Observer &#123;  update(data) &#123;    console.log(`Received data: $&#123;data&#125;`);  &#125;&#125;// 使用示例const subject = new Subject();const observer1 = new Observer();const observer2 = new Observer();subject.addObserver(observer1);subject.addObserver(observer2);subject.notify(&quot;Hello World!&quot;);

装饰器模式interface Component &#123;  operation(): void;&#125;class ConcreteComponent implements Component &#123;  public operation(): void &#123;    console.log(&quot;ConcreteComponent: operation.&quot;);  &#125;&#125;class Decorator implements Component &#123;  protected component: Component;  constructor(component: Component) &#123;    this.component = component;  &#125;  public operation(): void &#123;    console.log(&quot;Decorator: operation.&quot;);    this.component.operation();  &#125;&#125;class ConcreteDecoratorA extends Decorator &#123;  public operation(): void &#123;    super.operation();    console.log(&quot;ConcreteDecoratorA: operation.&quot;);  &#125;&#125;class ConcreteDecoratorB extends Decorator &#123;  public operation(): void &#123;    super.operation();    console.log(&quot;ConcreteDecoratorB: operation.&quot;);  &#125;&#125;// 使用示例const concreteComponent = new ConcreteComponent();const concreteDecoratorA = new ConcreteDecoratorA(concreteComponent);const concreteDecoratorB = new ConcreteDecoratorB(concreteDecoratorA);concreteDecoratorB.operation();

代理模式const target = &#123;  method() &#123;    console.log(&quot;Target method.&quot;);  &#125;&#125;;const proxy = new Proxy(target, &#123;  get(target, prop) &#123;    console.log(`Called $&#123;prop&#125; method.`);    return target[prop];  &#125;&#125;);// 使用示例proxy.method(); // &quot;Called method method. Target method.&quot;

适配器模式class Adaptee &#123;  specificRequest() &#123;    return &quot;适配者中的业务代码被调用&quot;;  &#125;&#125;class Target &#123;  constructor() &#123;    this.adaptee = new Adaptee();  &#125;  request() &#123;    let info = this.adaptee.specificRequest();    return `$&#123;info&#125; - 转换器 - 适配器代码被调用`;  &#125;&#125;// 使用示例let target = new Target();target.request(); // &quot;适配者中的业务代码被调用 - 转换器 - 适配器代码被调用&quot;

MVC模式class Model &#123;  constructor() &#123;    this.data = &#123;      name: &quot;example&quot;,      age: 18,      gender: &quot;male&quot;    &#125;;  &#125;  setData(key, value) &#123;    this.data[key] = value;  &#125;  getData() &#123;    return this.data;  &#125;&#125;class View &#123;  constructor() &#123;    this.container = document.createElement(&quot;div&quot;);  &#125;  render(data) &#123;    const &#123; name, age, gender &#125; = data;    this.container.innerHTML = `      &lt;p&gt;Name: $&#123;name&#125;&lt;/p&gt;      &lt;p&gt;Age: $&#123;age&#125;&lt;/p&gt;      &lt;p&gt;Gender: $&#123;gender&#125;&lt;/p&gt;    `;    document.body.appendChild(this.container);  &#125;&#125;class Controller &#123;  constructor(model, view) &#123;    this.model = model;    this.view = view;    this.view.render(this.model.getData());  &#125;  setData(key, value) &#123;    this.model.setData(key, value);    this.view.render(this.model.getData());  &#125;&#125;// 使用示例const model = new Model();const view = new View();const controller = new Controller(model, view);controller.setData(&quot;age&quot;, 20);

策略模式表单验证情景：
// 验证策略const validationStrategies = &#123;  required: &#123;    validate: (value) =&gt; value !== &#x27;&#x27;,    message: &#x27;该字段不能为空&#x27;  &#125;,    minLength: &#123;    validate: (value, length) =&gt; value.length &gt;= length,    message: (length) =&gt; `最少需要$&#123;length&#125;个字符`  &#125;,    email: &#123;    validate: (value) =&gt; /^\S+@\S+\.\S+$/.test(value),    message: &#x27;请输入有效的邮箱地址&#x27;  &#125;,    phone: &#123;    validate: (value) =&gt; /^1[3-9]\d&#123;9&#125;$/.test(value),    message: &#x27;请输入有效的手机号&#x27;  &#125;,    custom: &#123;    validate: (value, validator) =&gt; validator(value),    message: &#x27;自定义验证失败&#x27;  &#125;&#125;;// 表单验证器class FormValidator &#123;  constructor() &#123;    this.rules = [];  &#125;    // 添加验证规则  addRule(field, strategy, ...params) &#123;    this.rules.push(&#123;      field,      strategy,      params    &#125;);  &#125;    // 执行验证  validate(formData) &#123;    const errors = [];        for (const rule of this.rules) &#123;      const &#123; field, strategy, params &#125; = rule;      const value = formData[field];      const validationStrategy = validationStrategies[strategy];            if (!validationStrategy.validate(value, ...params)) &#123;        errors.push(&#123;          field,          message: typeof validationStrategy.message === &#x27;function&#x27;             ? validationStrategy.message(...params)            : validationStrategy.message        &#125;);      &#125;    &#125;        return &#123;      isValid: errors.length === 0,      errors    &#125;;  &#125;&#125;// 使用示例const validator = new FormValidator();validator.addRule(&#x27;username&#x27;, &#x27;required&#x27;);validator.addRule(&#x27;username&#x27;, &#x27;minLength&#x27;, 3);validator.addRule(&#x27;email&#x27;, &#x27;required&#x27;);validator.addRule(&#x27;email&#x27;, &#x27;email&#x27;);validator.addRule(&#x27;phone&#x27;, &#x27;phone&#x27;);const formData = &#123;  username: &#x27;ab&#x27;,  email: &#x27;invalid-email&#x27;,  phone: &#x27;12345678901&#x27;&#125;;const result = validator.validate(formData);console.log(result);// &#123;//   isValid: false,//   errors: [//     &#123; field: &#x27;username&#x27;, message: &#x27;最少需要3个字符&#x27; &#125;,//     &#123; field: &#x27;email&#x27;, message: &#x27;请输入有效的邮箱地址&#x27; &#125;,//     &#123; field: &#x27;phone&#x27;, message: &#x27;请输入有效的手机号&#x27; &#125;//   ]// &#125;

]]></content>
      <categories>
        <category>秋招准备</category>
      </categories>
      <tags>
        <tag>秋招</tag>
        <tag>ES</tag>
        <tag>面试题</tag>
        <tag>前端手撕</tag>
      </tags>
  </entry>
</search>
